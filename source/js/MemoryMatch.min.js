/* MemoryMatch.js
   Memory Match game implementation. This file implements all of the game types and functionality on the game play screen.
   It also acts as the main game model and coordinates game data, user data, and game state.

 */

// namespace under enginesis object
var enginesisSession = enginesis || {};

'use strict';


var MemoryMatch = {
    GameVersion: "1.0.66",
    platform: "unknown",
    locale: "en-US",
    debugMode: true,
    isTouchDevice: false,
    minimumSplashScreenDisplayTime: 2000,
    assetLoader: null,
    secondaryAssetManifest: null,

    GAMESTATE: {
        INIT:                0,
        SPLASH:              1,
        MENU:                2,
        OPTIONS:             3,
        LEVELSELECT:         4,
        PLAY:                5,
        RESULTS:             6,
        GAMECOMPLETE:        7,
        SHOWAD:             21,
        ACHIEVEMENTS:       22,
        LEADERBOARD:        23,
        STORE:              24,
        MOREGAMES:          25,
        LOADING:            97,
        IDLE:               98,
        UNKNOWN:            99
    },

    GAMEPLAYSTATE: {
        NEW_GAME:            1,
        GET_READY:           2,
        BOARD_SETUP:         3,
        PLAY_WAIT:           4,
        CHOOSE_FIRST_CARD:   5,
        CHOOSE_SECOND_CARD:  6,
        CARDS_MATCH:         7,
        CARDS_NO_MATCH:      8,
        BOARD_CLEAR:         9,
        LOSE:               10,
        WIN:                11,
        LEVEL_UP:           12,
        IDLE:               98,
        UNKNOWN:            99
    },

    CARDSTATE: {
        DOWN:                0,
        UP:                  1,
        REMOVED:             2,
        NOTREADY:            9
    },

    GAMEPLAYTYPE: {
        CONCENTRATION:       1,
        SIMON:               2,
        PATTERN:             3,
        HAYSTACK:            4,
        CHAINS:              5,
        MONTE:               6,
        NEMESIS:             7,
        EYESPY:              8
    },

    ACHIEVEMENT: {
        FASTMATCH:         1,
        FASTCOMBO:         2,
        TRIPLECOMBO:       3,
        QUADBO:            4,
        FIVECOMBOS:        5,
        FIFTYCOMBOS:       6,
        TWENTYFIVECOMBOS:  7,
        FIFTYMATCHES:      8,
        ONEHUNDREDMATCHES: 9,
        TWOFIFTYMATCHES:   10,
        LUCKYGUESS:        11,
        CLAIRVOYANT:       12,
        CHAINGANG:         13,
        CHAINTASTIC:       14,
        ACONTENDER:        15,
        THREESTAR:         16,
        QUICKDRAW:         17,
        MOZART:            18,
        MONTE:             19,
        PICASSO:           20,
        EAGLEEYE:          21
    },

    gameWasInitialized: false,
    gameData: null,
    rows: 0,
    columns: 0,
    cardWidth: 0,
    cardHeight: 0,
    numCardsAvailable: 0,
    cardMargin: 0,
    canvasContainerElement: "canvasArea",
    loaderElement: "loader",
    stageCanvasElement: "memoryMatch",
    assetFileNamePostfix: "",
    cardsFileNamePostfix: "",
    stage: null,
    stageUpdated: false,
    stageWidth: 0,
    stageHeight: 0,
    cssScaledWidth: 0,
    cssScaledHeight: 0,
    stageScaleFactor: 1,
    cardScaleFactor: 1,
    stageAspectRatio: 1.3333,
    fps: 60,
    gamePaused: false,
    boardContainer: null,
    playAreaWidth: 0,
    playAreaHeight: 0,
    gameInProgress: false,
    gameState: 0,
    gamePriorState: 0,
    gameStateStartTime: 0,
    gamePlayState: 0,
    quitPending: false,
    audioMute: false,
    gameLevel: 1,
    gameId: 0,
    challengeGameId: 0,
    challengeAdvanceStreak: 0,
    userBeatAllChallenges: false,
    userBeatAllChallengesFirstTime: false,
    gameNumber: 1,
    isChallengeGame: false,
    playerBeatChallenge: false,
    gameType: 0,
    numberOfGamesInLevel: 1,
    gameScore: 0,
    levelScore: 0,
    totalScore: 0,
    startingLevel: 1,
    startingGameNumber: 1,
    priorBestGameScore: 0,
    levelMatchCounter: 0,
    levelComplete: false,
    lastPlayedDate: null,
    matchCount: 0,
    consecutiveMatchCount: 0,
    chainCount: null,
    numberOfCombos: 0,
    luckyGuessCount: 0,
    missCount: 0,
    moveCountDown: -1,
    levelTolerance: 0,
    gameMatchCount: 0,
    removeMatches: false,
    gameStartTime: 0,
    nextTimerUpdateTime: 0,
    gameInitTime: 0,
    lastMatchTime: 0,
    gameEndTime: 0,
    gamePauseTime: 0,
    cardShowTime: 0,
    cardSelected: null,
    cardTargetValue: 0,
    cardFlipSpeed: 9,
    allCardsOnBoard: null,  // Tracks all the cards on the board
    simonBag: null,         // holds the randomized value list for the Simon, Haystack, EyeSpy games
    simonPlaybackIndex: 0,
    simonUserIndex: 0,
    monteMoves: null,
    monteIndex: 0,
    monteNumberOfMoves: 0,
    chainsGroupDisplayObject: null,
    chainsStreakCount: 0,
    eyeSpyImageGroups: null,
    eyeSpyTargetCardValue: 0,
    eyeSpyMatchCardValue: 0,
    numberOfCardsShowing: 0,
    achievementDisplayQueue: [],
    achievementDisplayTime: 0,
    imageSheetUrl: "",
    imageSheetImage: null,
    imageSheetSpriteWidth: 0,
    imageSheetSpriteHeight: 0,
    particleSpriteData: null,
    backgroundImage: null,
    timeLastFrame: 0,
    timeThisFrame: 0,
    backgroundSoundInstance: null,
    interstitialSoundInstance: null,
    userName: '',
    userId: 1,
    enginesisUserId: 0,
    authToken: '',
    unlockAllLevelsCounter: 0,
    cheatChallengeNoMiss: false,
    secondaryAssetLoaderProgress: 0,


    configureGame: function () {
        // setup the game parameters from the configuration file assets/setup.js
        var loaderObject,
            assetLoader = MemoryMatch.assetLoader;

        loaderObject = assetLoader.getResult("guiSprites1json");
        if (loaderObject != null) {
            this.GameSetup.guiSpritesheet1Frames = loaderObject;
        }
        loaderObject = assetLoader.getResult("guiSprites2json");
        if (loaderObject != null) {
            this.GameSetup.guiSpritesheet2Frames = loaderObject;
        }
        loaderObject = assetLoader.getResult("guiSprites3json");
        if (loaderObject != null) {
            this.GameSetup.mapSpritesheetFrames = loaderObject;
        }
        loaderObject = assetLoader.getResult("guiSprites4json");
        if (loaderObject != null) {
            this.GameSetup.shareIconsFrames = loaderObject;
        }
        this.GameSetup.guiSpritesheet1Frames.images = [assetLoader.getResult("guiSprites1")];
        this.GameSetup.guiSpritesheet2Frames.images = [assetLoader.getResult("guiSprites2")];
        this.GameSetup.mapSpritesheetFrames.images = [assetLoader.getResult("guiSprites3")];
        this.GameSetup.shareIconsFrames.images = [assetLoader.getResult("guiSprites4")];

        MemoryMatch.backgroundImage = assetLoader.getResult("background");
        MemoryMatch.cardMargin = 2;
        MemoryMatch.moveCountDown = -1;
        MemoryMatch.setBoardSize(this.GameSetup.rows, this.GameSetup.columns);
        MemoryMatch.gameData = this.GameSetup.games;
    },

    initializeGame: function () {
        this.gameState = MemoryMatch.GAMESTATE.LOADING;
        this.gamePlayState = MemoryMatch.GAMEPLAYSTATE.IDLE;
        this.gameInitTime = Date.now();
        this.timeLastFrame = Date.now();
        this.configureGame();
        this.restoreUsers();

        // start the Enginesis session
        enginesisSession = enginesis(this.GameSetup.siteId, this.GameSetup.gameId, 0, this.GameSetup.enginesisStage, '', this.GameSetup.developerKey, 'en', this.enginesisCallBack.bind(this));
        enginesisSession.gameTrackingRecord('game', 'load', '', '', null);
        enginesisSession.sessionBegin(this.GameSetup.gameKey);
        // TODO: save authtoken, user id, user name, avatar

        // find canvas and perform the basic setup tasks to get everything in order to start the game
        var canvas = document.getElementById(this.stageCanvasElement);
        this.playAreaWidth = canvas.width;
        this.playAreaHeight = canvas.height;

        // create a new stage and point it at our canvas:
        this.stage = new createjs.Stage(canvas);
        if ( ! MemoryMatch.isTouchDevice) {
            this.stage.enableMouseOver(10); // detecting mouseover is a performance drain, so only do it if we need it
        }
        createjs.Touch.enable(this.stage, true, false);

        this.showBackgroundImage(canvas);
        this.boardContainer = new createjs.Container();
        this.stage.addChild(this.boardContainer);
        this.GameGUI.build(this.stage);
        MemoryMatch.AnimationHandler.init(canvas, this.stage);
        MemoryMatch.gameWasInitialized = true;

        createjs.Ticker.setFPS(this.fps);
        createjs.Ticker.addEventListener("tick", this.onEnterFrame.bind(this));

        this.restoreLastSession();
        window.addEventListener('resize', MemoryMatch.stageSizeChanged, false);
        window.addEventListener('orientationchange', MemoryMatch.stageSizeChanged, false);
        document.addEventListener('pause', MemoryMatch.onPauseGame.bind(this), false);
        document.addEventListener('resume', MemoryMatch.unPauseGame.bind(this), false);
        document.addEventListener(MemoryMatch.getVisibilityChangeEvent(), MemoryMatch.onVisibilityChange.bind(MemoryMatch));

        if (MemoryMatch.isDesiredOrientation()) {
            MemoryMatch.showOrientationMessage(false);
            if (this.getQueryStringValue('level') != null) {
                this.processDeepLink();
            } else {
                this.showMenuScreen();
            }
        } else {
            MemoryMatch.showOrientationMessage(true);
        }
    },

    reinitializeGame: function () {
        var canvas = document.getElementById(this.stageCanvasElement);
        this.playAreaWidth = canvas.width;
        this.playAreaHeight = canvas.height;
        this.configureGame();
        this.showBackgroundImage(canvas);
        if (this.boardContainer != null) {
            this.boardContainer.removeAllChildren();
            this.boardContainer = new createjs.Container();
            this.stage.addChild(this.boardContainer);
        }
        this.GameGUI.build(this.stage);
        MemoryMatch.AnimationHandler.init(canvas, this.stage);
        if (MemoryMatch.isDesiredOrientation()) {
            MemoryMatch.showOrientationMessage(false);
            this.showMenuScreen();
        } else {
            MemoryMatch.showOrientationMessage(true);
        }
    },

    stopGame: function () {
        createjs.Ticker.removeEventListener("tick", MemoryMatch.onEnterFrame);
        createjs.Touch.disable(MemoryMatch.stage);
    },

    saveGame: function () {
        // save all game variables to persistent storage so we can restore the game at the same place
        var gameSaveState;

        if (MemoryMatch.hasHTML5LocalStorage()) {
            gameSaveState = {};
            gameSaveState.gameInProgress = MemoryMatch.gameInProgress;
            gameSaveState.gameLevel = MemoryMatch.gameLevel;
            gameSaveState.gameId = MemoryMatch.gameId;
            gameSaveState.challengeGameId = MemoryMatch.challengeGameId;
            gameSaveState.gameNumber = MemoryMatch.gameNumber;
            gameSaveState.gameState = MemoryMatch.gameState;
            gameSaveState.gamePriorState = MemoryMatch.gamePriorState;
            gameSaveState.gameStateStartTime = MemoryMatch.gameStateStartTime;
            gameSaveState.gamePlayState = MemoryMatch.gamePlayState;
            gameSaveState.numberOfGamesInLevel = MemoryMatch.numberOfGamesInLevel;
            gameSaveState.gameScore = MemoryMatch.gameScore;
            gameSaveState.matchCount = MemoryMatch.matchCount;
            gameSaveState.consecutiveMatchCount = MemoryMatch.consecutiveMatchCount;
            gameSaveState.numberOfCombos = MemoryMatch.numberOfCombos;
            gameSaveState.missCount = MemoryMatch.missCount;
            gameSaveState.moveCountDown = MemoryMatch.moveCountDown;
            gameSaveState.levelTolerance = MemoryMatch.levelTolerance;
            gameSaveState.gameMatchCount = MemoryMatch.gameMatchCount;
            gameSaveState.gameMatchCount = MemoryMatch.gameMatchCount;
            gameSaveState.gameInitTime = MemoryMatch.gameInitTime;
            gameSaveState.gameStartTime = MemoryMatch.gameStartTime;
            gameSaveState.gamePauseTime = MemoryMatch.gamePauseTime;
            gameSaveState.lastMatchTime = MemoryMatch.lastMatchTime;
            // gameSaveState.allCardsOnBoard = // Need to loop through all the cards and save their current values
            // gameSaveState.cardSelected = If a card is currently selected we need to restore that state
            MemoryMatch.saveObjectWithKey(MemoryMatch.getGameKey("gameSaveState"), gameSaveState);
        }
    },

    restoreGame: function () {
        // restore all game variables and reset the game at the same place
        var gameSaveState = MemoryMatch.loadObjectWithKey(MemoryMatch.getGameKey("gameSaveState"));
        return gameSaveState;
    },

    playBackgroundMusic: function () {
        if (MemoryMatch.backgroundSoundInstance !== null) {
            if (MemoryMatch.backgroundSoundInstance.playState !== createjs.Sound.PLAY_SUCCEEDED) {
                MemoryMatch.backgroundSoundInstance.play({delay: 0, loop: -1});
                MemoryMatch.debugLog("playBackgroundMusic: restarting last music");
            }
        } else {
            MemoryMatch.backgroundSoundInstance = createjs.Sound.play("soundIntro", {delay: 0, loop: -1});
            MemoryMatch.debugLog("playBackgroundMusic: starting soundIntro");
        }
    },

    playInterstitialMusic: function (soundReference, looped) {
        var loopCount;

        if (looped == undefined || looped == null) {
            looped = false;
        }
        if (looped) {
            loopCount = -1;
        } else {
            loopCount = 0;
        }
        if (MemoryMatch.interstitialSoundInstance !== null) {
            if (MemoryMatch.interstitialSoundInstance.playState !== createjs.Sound.PLAY_SUCCEEDED) {
                MemoryMatch.interstitialSoundInstance.play({delay: 0, loop: loopCount});
                MemoryMatch.debugLog("playInterstitialMusic: restarting last " + soundReference);
            }
        } else {
            MemoryMatch.interstitialSoundInstance = createjs.Sound.play(soundReference, {delay: 0, loop: loopCount});
            MemoryMatch.debugLog("playInterstitialMusic: starting " + soundReference);
        }
    },

    stopBackgroundMusic: function () {
        if (MemoryMatch.backgroundSoundInstance !== null) {
            MemoryMatch.backgroundSoundInstance.stop();
        }
    },

    stopInterstitialMusic: function () {
        if (MemoryMatch.interstitialSoundInstance !== null) {
            MemoryMatch.interstitialSoundInstance.stop();
            MemoryMatch.interstitialSoundInstance = null;
        }
    },

    restartBackgroundMusic: function () {
        if (MemoryMatch.backgroundSoundInstance !== null) {
            if (MemoryMatch.backgroundSoundInstance.playState == createjs.Sound.PLAY_SUCCEEDED || MemoryMatch.backgroundSoundInstance.playState == createjs.Sound.PLAY_FINISHED) {
                MemoryMatch.backgroundSoundInstance.play({delay: 0, loop: -1});
                MemoryMatch.debugLog("restartBackgroundMusic: restarting last music");
            }
        }
    },

    playShuffleMusic: function (playFlag) {
        if (playFlag) {
            MemoryMatch.playInterstitialMusic("soundShuffling", true);
        } else {
            MemoryMatch.stopInterstitialMusic();
        }
    },

    triggerSoundFx: function (tag, params) {
        if ( ! MemoryMatch.gamePaused) {
            MemoryMatch.debugLog("triggerSoundFx: " + tag);
            createjs.Sound.play(tag, params);
        }
    },

    playNote: function (noteNumber) {
        if (noteNumber == null || noteNumber < 1) {
            noteNumber = 1;
        } else if (noteNumber > 8) {
            noteNumber = 8;
        }
        MemoryMatch.triggerSoundFx("note" + noteNumber.toString(), {interrupt: createjs.Sound.INTERRUPT_NONE, delay: 0, offset:0, loop: false, volume: 1});
    },

    showMenuScreen: function () {
        MemoryMatch.gameCleanUp();
        MemoryMatch.stopInterstitialMusic();
        MemoryMatch.playBackgroundMusic();
        MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.MENU);
        MemoryMatch.MainMenu.setup(MemoryMatch.stage, MemoryMatch.getGameData(false), MemoryMatch.mainMenuCallback);
        MemoryMatch.MainMenu.buildScreen(true);
    },

    mainMenuCallback: function (levelNumber) {
        MemoryMatch.beginGameWithLevelNumber(levelNumber);
    },

    goToHomeScreen: function () {
        MemoryMatch.GameGUI.show(false);
        MemoryMatch.showMenuScreen();
    },

    processDeepLink: function () {
        // if requested level is unlocked then jump to it

        var requestedLevel = this.getQueryStringValue('level'),
            goToMainMenu = true,
            levelData,
            levelAndGameNumber;

        if (requestedLevel != null) {
            if (MemoryMatch.isLevelUnlocked(requestedLevel)) {
                MemoryMatch.gameCleanUp();
                levelAndGameNumber = MemoryMatch.convertLevelNumberToLevelAndGameNumber(requestedLevel);
                MemoryMatch.gameLevel = levelAndGameNumber.levelNumber;
                levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);
                MemoryMatch.numberOfGamesInLevel = levelData.gameCount;
                MemoryMatch.startingLevel = levelAndGameNumber.levelNumber;
                MemoryMatch.startingGameNumber = levelAndGameNumber.gameNumber;
                MemoryMatch.resetUserTotalScore();
                MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
                MemoryMatch.startGameWithNumber(levelAndGameNumber.gameNumber);
                goToMainMenu = false;
            }
        }
        if (goToMainMenu) {
            MemoryMatch.showMenuScreen();
        }
    },

    showSharePopup: function (shareMessage) {
        MemoryMatch.SharePopup.setup(MemoryMatch.stage, {title: "Share", message: "Share " + MemoryMatch.GameSetup.gameTitle + " with your favorite social network:", callback: MemoryMatch.onShareClosed.bind(MemoryMatch), closeButton: true, continueButton: false, noscale: true, shareMessage: shareMessage, domElementEmailForm: 'emailshare'});
        MemoryMatch.SharePopup.buildScreen(true);
    },

    onShareClosed: function (event) {
        MemoryMatch.GameOptions.closePopupFromPopup("continue");
    },

    closeAllPopups: function () {
        if (MemoryMatch.SharePopup.isShowing()) {
            MemoryMatch.SharePopup.closePopup();
        }
        if (MemoryMatch.MessagePopup.isShowing()) {
            MemoryMatch.MessagePopup.closePopup();
        }
        if (MemoryMatch.GameOptions.isShowing()) {
            MemoryMatch.GameOptions.closePopupFromPopup("continue");
        }
    },

    onQuitGame: function () {
        MemoryMatch.gameStartTime = 0;
        MemoryMatch.gamePauseTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.gamePaused = false;
        MemoryMatch.quitPending = true;
        MemoryMatch.gameInProgress = false;
        MemoryMatch.GameGUI.setMessage('');
        MemoryMatch.levelCleanUp();
        MemoryMatch.AnimationHandler.quitPending(true);
        MemoryMatch.AnimationHandler.clearAll();
        MemoryMatch.clearBoard();      // remove all display objects
        MemoryMatch.GameResults.close();
        MemoryMatch.goToHomeScreen();
        MemoryMatch.quitPending = false;
        MemoryMatch.AnimationHandler.quitPending(false);
    },

    onPauseGame: function (pauseFlag) {
        // Pause or unpause the game
        if (pauseFlag === undefined || pauseFlag === null) {
            pauseFlag = true;
        }
        if (pauseFlag && MemoryMatch.gameInProgress) {
            // app went from active to inactive, show GAME PAUSED popup
            MemoryMatch.stopInterstitialMusic();
            MemoryMatch.pauseGameInProgress();
            if ( ! MemoryMatch.GameOptions.isShowing()) {
                MemoryMatch.GameOptions.setup(MemoryMatch.stage, MemoryMatch.GameGUI.onOptionsClosed, true);
                MemoryMatch.GameOptions.buildScreen(true, false);
            }
            this.stage.update(event); // render these updates now as the render loop will be paused
            this.stageUpdated = false;
        } else if (pauseFlag) {
            // stop music
            MemoryMatch.stopBackgroundMusic();
            MemoryMatch.stopInterstitialMusic();
        } else {
            // app went from inactive to active. if we are on the home screen then restart the music
            if (MemoryMatch.gameState == MemoryMatch.GAMESTATE.MENU) {
                MemoryMatch.restartBackgroundMusic();
                MemoryMatch.GameGUI.resume(null);
            }
        }
    },

    unPauseGame: function () {
        MemoryMatch.onPauseGame(false);
    },

    pauseGameInProgress: function () {
        if ( ! MemoryMatch.gamePaused && MemoryMatch.gameInProgress) {
            MemoryMatch.gamePaused = true;
            if (MemoryMatch.gamePauseTime == 0) {
                MemoryMatch.gamePauseTime = Date.now();
            }
            MemoryMatch.saveGame();
            MemoryMatch.turnBackAllCards();
            MemoryMatch.GameGUI.pause(null);
        }
    },

    resumePausedGame: function (event) {
        var pauseTime = Date.now() - MemoryMatch.gamePauseTime;

        // we get here when the Game Paused popup is closed.
        // restore game state, unless we were previewing cards, then start over.
        MemoryMatch.gamePauseTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.gamePaused = false;
        createjs.Touch.enable(MemoryMatch.stage, true, false);
        MemoryMatch.gameStartTime += pauseTime; // update the game timer
        MemoryMatch.updateGameTimers();
        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.SIMON) { // replay the simon pattern and reset user to beginning of current streak
                MemoryMatch.restoreAllCards();
                MemoryMatch.simonUserIndex = 0;
                window.setTimeout(MemoryMatch.simonPlayback.bind(MemoryMatch), 800); // need a delay to wait for the card flip animation to complete
            } else {
                MemoryMatch.restartCurrentChallengeGame(); // restart the current game keeping current streak in tact
            }
        } else if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.BOARD_SETUP) {
            MemoryMatch.replayCurrentGame();
        } else {
            MemoryMatch.restoreGame();
            MemoryMatch.restoreAllCards();
        }
    },

    startGameWithNumber: function (gameNumber) {
        var levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);

        MemoryMatch.gameId = levelData.gameId;
        MemoryMatch.challengeGameId = levelData.challengeGameId;
        MemoryMatch.challengeAdvanceStreak = levelData.challengeAdvanceStreak;
        if (MemoryMatch.shouldShowLevelIntroduction(MemoryMatch.gameLevel)) {
            MemoryMatch.isChallengeGame = false;
            MemoryMatch.gameNumber = 1;
            MemoryMatch.showLevelIntroduction(gameNumber);
        } else {
            MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.PLAY);
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.GET_READY;
            if (gameNumber == 99) {
                MemoryMatch.isChallengeGame = true;
                MemoryMatch.gameNumber = 1;
                MemoryMatch.startLevelChallenge();
            } else {
                gameNumber = Math.min(gameNumber || 1, MemoryMatch.numberOfGamesInLevel); // make sure it is in the supported range 1..N
                MemoryMatch.isChallengeGame = false;
                MemoryMatch.gameNumber = gameNumber;
                MemoryMatch.startNextGame();
            }
        }
    },

    beginGameWithLevelNumber: function (requestedLevel) {
        // if requested level is unlocked then jump to it

        var levelData,
            levelAndGameNumber,
            goToMainMenu = true;

        if (requestedLevel != null) {
            if (MemoryMatch.isLevelUnlocked(requestedLevel)) {
                MemoryMatch.gameCleanUp();
                levelAndGameNumber = MemoryMatch.convertLevelNumberToLevelAndGameNumber(requestedLevel);
                MemoryMatch.gameLevel = levelAndGameNumber.levelNumber;
                levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);
                MemoryMatch.numberOfGamesInLevel = levelData.gameCount;
                MemoryMatch.startingLevel = levelAndGameNumber.levelNumber;
                MemoryMatch.startingGameNumber = levelAndGameNumber.gameNumber;
                MemoryMatch.resetUserTotalScore();
                MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
                MemoryMatch.startGameWithNumber(levelAndGameNumber.gameNumber);
                goToMainMenu = false;
                MemoryMatch.chainsStreakCount = 0;
            }
        }
        if (goToMainMenu) {
            MemoryMatch.showMenuScreen();
        }
    },

    beginNewGame: function (startLevel, startGame) {
        var levelData;
        if (startLevel < 1 || startLevel > MemoryMatch.GameSetup.levels.length) {
            startLevel = 1;
        }
        MemoryMatch.gameLevel = startLevel;
        levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);
        MemoryMatch.gameId = levelData.gameId;
        MemoryMatch.challengeGameId = levelData.challengeGameId;
        MemoryMatch.challengeAdvanceStreak = levelData.challengeAdvanceStreak;
        if (MemoryMatch.gameData != null) {
            MemoryMatch.numberOfGamesInLevel = levelData.gameCount;
        } else {
            MemoryMatch.numberOfGamesInLevel = 1;
        }
        MemoryMatch.gameNumber = Math.min(startGame || 1, MemoryMatch.numberOfGamesInLevel);
        MemoryMatch.startingLevel = startLevel;
        MemoryMatch.startingGameNumber = MemoryMatch.gameNumber;
        MemoryMatch.resetUserTotalScore();
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
        MemoryMatch.startNextLevel();
    },

    startNextGame: function () {
        var gameProgressionData = null,
            thisGameData,
            guiFlashThreshold = 0;

        // Use to setup a game, reset all timers and counters for an individual game
        MemoryMatch.gameInProgress = true;
        MemoryMatch.stopBackgroundMusic();
        MemoryMatch.GameGUI.show(true);
        if (MemoryMatch.gameData != null) {
            thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
            MemoryMatch.gameType = thisGameData.gameType;
            if (thisGameData.progression != null && thisGameData.progression.length >= MemoryMatch.gameNumber) {
                gameProgressionData = thisGameData.progression[MemoryMatch.gameNumber - 1];
            } else {
                gameProgressionData = thisGameData;
            }
            if (gameProgressionData != null) {
                MemoryMatch.rows = gameProgressionData.rows;
                MemoryMatch.columns = gameProgressionData.columns;
                if (MemoryMatch.gameNumber == 1 || ! MemoryMatch.isChallengeGame) {
                    MemoryMatch.moveCountDown = gameProgressionData.tolerance;
                    MemoryMatch.levelTolerance = gameProgressionData.tolerance;
                    if (gameProgressionData.matchCount != null) {
                        MemoryMatch.gameMatchCount = gameProgressionData.matchCount;
                    }
                    guiFlashThreshold = MemoryMatch.moveCountDown > 2 ? 2 : 1;
                }
            }
            if (thisGameData.removeMatches != null) {
                MemoryMatch.removeMatches = thisGameData.removeMatches ? true : false; // make sure it evaluates to a boolean value
            }
            if (thisGameData.cardShowTime != null) {
                MemoryMatch.cardShowTime = thisGameData.cardShowTime;
            } else {
                MemoryMatch.cardShowTime = 500;
            }
            // Get card set based on level
            if (thisGameData.numCards != null) {
                MemoryMatch.numCardsAvailable = thisGameData.numCards;
            }
            if (MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.EYESPY) { // EYESPY will do this itself
                MemoryMatch.loadCardSetForCurrentLevel();
            }
        } else {
            MemoryMatch.moveCountDown = -1;
            MemoryMatch.levelTolerance = 0;
        }
        if ( ! (MemoryMatch.isChallengeGame && MemoryMatch.gameNumber > 1)) { // do not reset if continuing the Challenge game
            MemoryMatch.gameScore = 0;
            MemoryMatch.consecutiveMatchCount = 0;
            MemoryMatch.numberOfCombos = 0;
            MemoryMatch.luckyGuessCount = 0;
            MemoryMatch.missCount = 0;
            MemoryMatch.gameStartTime = 0;
            MemoryMatch.nextTimerUpdateTime = 0;
            MemoryMatch.lastMatchTime = 0;
            MemoryMatch.chainsStreakCount = 0;
        }
        if (MemoryMatch.isChallengeGame) {
            MemoryMatch.priorBestGameScore = MemoryMatch.getPriorBestScoreForGameNumber(MemoryMatch.gameLevel, 99);
            guiFlashThreshold = 0;
            MemoryMatch.playerBeatChallenge = false;
        } else {
            MemoryMatch.priorBestGameScore = MemoryMatch.getPriorBestScoreForGameNumber(MemoryMatch.gameLevel, MemoryMatch.gameNumber);
        }
        MemoryMatch.GameGUI.updateComboMultiplier(0);
        MemoryMatch.matchCount = 0;
        MemoryMatch.chainCount = null;
        MemoryMatch.numberOfCardsShowing = 0;
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.BOARD_SETUP;
        MemoryMatch.GameGUI.updateLevelDisplay(MemoryMatch.gameLevel, MemoryMatch.gameNumber);
        MemoryMatch.GameGUI.setFlashCountThreshold(guiFlashThreshold);
        MemoryMatch.updateMatchCountDisplay();
        MemoryMatch.buildBoard();
    },

    loadCardSetForCurrentLevel: function () {
        var cardSize,
            thisGameData,
            cardAssetId,
            cardSetIndex = 0;

        thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
        cardSize = MemoryMatch.getCardSize(thisGameData);
        if (thisGameData.cardSprites != null) {
            cardSetIndex = 0;
            if (thisGameData.numberOfCardSets > 1) {
                cardSetIndex = MemoryMatch.getRandomNumberBetween(0, thisGameData.numberOfCardSets - 1);
            }
            cardAssetId = MemoryMatch.getSpriteAssetId(cardSetIndex);
        } else {
            cardAssetId = "cards1";
        }
        if ( ! MemoryMatch.setImageSheet(cardAssetId, cardSize.width, cardSize.height)) {
            // if the asset is not available then get the first asset
            cardSetIndex = 0;
            cardAssetId = MemoryMatch.getSpriteAssetId(cardSetIndex);
            MemoryMatch.setImageSheet(cardAssetId, cardSize.width, cardSize.height);
        }
    },

    startLevel: function (levelNumber) {
        // Start at the beginning of the requested level number, for deep-linking into a specific level
        var levelData;
        if (levelNumber < 1 || levelNumber > MemoryMatch.GameSetup.levels.length) {
            levelNumber = 1;
        }
        MemoryMatch.gameLevel = levelNumber;
        levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);
        MemoryMatch.gameId = levelData.gameId;
        MemoryMatch.challengeGameId = levelData.challengeGameId;
        MemoryMatch.challengeAdvanceStreak = levelData.challengeAdvanceStreak;
        if (MemoryMatch.gameData != null) {
            MemoryMatch.numberOfGamesInLevel = levelData.gameCount;
        } else {
            MemoryMatch.numberOfGamesInLevel = 1;
        }
        MemoryMatch.gameNumber = 1;
        MemoryMatch.isChallengeGame = false;
        MemoryMatch.startingLevel = levelNumber;
        MemoryMatch.startingGameNumber = 1;
        MemoryMatch.resetUserTotalScore();
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
        MemoryMatch.startNextLevel();
    },

    startNextLevel: function () {
        // Introduce level
        MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.PLAY);
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.GET_READY;
        MemoryMatch.gameStartTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.gameEndTime = 0;
        MemoryMatch.levelComplete = false;
        MemoryMatch.levelMatchCounter = 0;
        if (MemoryMatch.shouldShowLevelIntroduction(MemoryMatch.gameLevel)) {
            MemoryMatch.showLevelIntroduction(MemoryMatch.gameNumber);
        } else {
            MemoryMatch.startNextGame();
        }
    },

    startLevelChallenge: function () {
        MemoryMatch.ChallengeIntroduction.setup(MemoryMatch.stage, MemoryMatch.startChallengeGame.bind(MemoryMatch));
        MemoryMatch.ChallengeIntroduction.buildScreen(true);
    },

    startChallengeGame: function (nextRequest) {
        if (nextRequest == "home") {
            MemoryMatch.goToHomeScreen();
        } else { // "continue"
            if (MemoryMatch.isChallengeGameUnlocked(MemoryMatch.gameLevel)) {
                MemoryMatch.isChallengeGame = true;
                MemoryMatch.gameNumber = 1;
                MemoryMatch.startNextGame();
            } else {
                MemoryMatch.goToHomeScreen();
            }
        }
    },

    levelIntroductionClosed: function (nextRequest, level, gameNumber) {
        if (nextRequest == 'home') {
            MemoryMatch.goToHomeScreen();
        } else { // "continue"
            MemoryMatch.startGameWithNumber(gameNumber);
        }
    },

    showLevelIntroduction: function (gameNumber) {
        var thisGameData;

        if (MemoryMatch.imageSheetImage == null) {
            thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
            MemoryMatch.gameNumber = gameNumber;
            MemoryMatch.gameId = thisGameData.gameId;
        }
        MemoryMatch.loadCardSetForCurrentLevel();
        MemoryMatch.LevelIntroduction.setup(MemoryMatch.stage, MemoryMatch.levelIntroductionClosed.bind(MemoryMatch), MemoryMatch.gameId, MemoryMatch.gameLevel, gameNumber);
        MemoryMatch.LevelIntroduction.buildScreen(true);
        MemoryMatch.setUserTipSeenForLevel(MemoryMatch.gameLevel);
        MemoryMatch.UserData.flush();
    },

    shouldShowLevelIntroduction: function (gameLevel) {

        // Tip ids are mapped from game ids, assuming a comprehensive tip system would have more than one tip per level.

        var userNotHasSeenLevelIntro,
            gameTipId = MemoryMatch.GameSetup.levels[gameLevel - 1].tipId;

        userNotHasSeenLevelIntro = ! MemoryMatch.UserData.isUserTipSeen(gameTipId);
        return userNotHasSeenLevelIntro;
    },

    setUserTipSeenForLevel: function (gameLevel) {
        var isSet = false,
            gameTipId = MemoryMatch.GameSetup.levels[gameLevel - 1].tipId;

        if (gameTipId != null) {
            MemoryMatch.UserData.setUserTipSeen(gameTipId);
            isSet = true;
        }
        return isSet;
    },

    getNextGameLevel: function () {
        // return the next level from where we are now, the trick is not going past the last level
        var currentLevel = MemoryMatch.gameLevel,
           nextLevel;

        if (currentLevel < 1) {
            nextLevel = 1;
        } else if (currentLevel + 1 > MemoryMatch.GameSetup.levels.length) {
            nextLevel = 1;
        } else {
            nextLevel = currentLevel + 1;
        }
        return nextLevel;
    },

    levelUp: function () {
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LEVEL_UP;
        MemoryMatch.gameLevel = MemoryMatch.getNextGameLevel();
        MemoryMatch.gameNumber = 1;
        if (MemoryMatch.gameLevel == 1) {
            MemoryMatch.goToHomeScreen();
        } else {
            MemoryMatch.startLevel(MemoryMatch.gameLevel);
        }
    },

    replayLastGame: function () {
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.GET_READY;
        MemoryMatch.gameStartTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.gameEndTime = 0;
        MemoryMatch.totalScore -= MemoryMatch.gameScore; // TODO: I'm not sure this is correct for a Challenge game
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
        MemoryMatch.levelComplete = false; // TODO: this should come from prior user data
        if (MemoryMatch.isChallengeGame) {
            MemoryMatch.gameNumber = 1;
            MemoryMatch.startGameWithNumber(99);
        } else {
            MemoryMatch.startGameWithNumber(MemoryMatch.gameNumber);
        }
    },

    replayCurrentGame: function () {
        // Do this ONLY if a game is in progress
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LOSE;
        MemoryMatch.triggerSoundFx("soundMiss", {delay: 100});
        MemoryMatch.gameEndTime = Date.now();
        MemoryMatch.gamePaused = false;
        MemoryMatch.removeAllCards(MemoryMatch.restartGameRemoveCardThenRestart); // calls replayLastGame after cards are removed
    },

    restartCurrentChallengeGame: function () {
        MemoryMatch.gamePaused = false;
        MemoryMatch.removeAllCards(MemoryMatch.restartChallengeGameRemoveCardThenReplay); // calls replayCurrentChallengeGame after cards are removed
    },

    replayCurrentChallengeGame: function () {
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.GET_READY;
        MemoryMatch.gameStartTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.gameEndTime = 0;
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
        MemoryMatch.levelComplete = false;
        if (MemoryMatch.isChallengeGame) {
            MemoryMatch.startNextGame();
        } else {
            MemoryMatch.startGameWithNumber(MemoryMatch.gameNumber);
        }
    },

    levelResultsClosed: function (nextRequest) {
        // We get here when GameResults popup is closed.
        // nextRequest can be "home", "next", "replay"

        // clean up these assets now as we left them on the stage while Results was showing
        if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.NEMESIS) {
            MemoryMatch.Nemesis.removeNemesisCharacter();
        } else if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.CHAINS) {
            MemoryMatch.removeChainsSprites();
        }
        if (nextRequest == "next") {
            // If the next button was requested we need to determine where to go next based on the users current situation
            if (MemoryMatch.canUserAdvance()) {
                if (MemoryMatch.isChallengeGame) {
                    // When a Challenge game is completed check if the game has been completed
                    if (MemoryMatch.userBeatAllChallengesFirstTime) {
                        MemoryMatch.userBeatAllChallengesFirstTime = false;
                        MemoryMatch.showGameCompleted();
                    } else {
                        MemoryMatch.levelUp();
                    }
                } else if (MemoryMatch.gameNumber == MemoryMatch.numberOfGamesInLevel) {
                    MemoryMatch.startLevelChallenge();
                } else {
                    MemoryMatch.gameNumber ++;
                    MemoryMatch.unlockNextGameForLevel(MemoryMatch.gameLevel, MemoryMatch.gameNumber);
                    if (MemoryMatch.shouldShowLevelIntroduction(MemoryMatch.gameLevel)) {
                        MemoryMatch.showLevelIntroduction(MemoryMatch.gameNumber);
                    } else {
                        MemoryMatch.startNextGame();
                    }
                }
            } else {
                MemoryMatch.startNextLevel();
            }
        } else if (nextRequest == "replay") {
            MemoryMatch.replayLastGame();
        } else {
            MemoryMatch.goToHomeScreen();
        }
    },

    levelResults: function () {
        var nextGameNumber,
            nextLevelNumber;

        // Show the level results popup. It will figure out what needs to be shown based on game/level
        // Also unlock the next level now to allow things to work out-of-sequence.

        if ( ! MemoryMatch.GameResults.isShowing()) {
            MemoryMatch.gameInProgress = false;
            if ( ! MemoryMatch.canUserAdvance()) {
                MemoryMatch.gameOver();
                MemoryMatch.levelComplete = false;
            } else if (MemoryMatch.isChallengeGame) {
                MemoryMatch.levelComplete = MemoryMatch.challengePassed();
                if (MemoryMatch.levelComplete) {
                    nextLevelNumber = MemoryMatch.getNextGameLevel();
                    nextGameNumber = MemoryMatch.getNextGameNumber();
                    MemoryMatch.unlockNextGameForLevel(nextLevelNumber, nextGameNumber);
                }
            } else {
                MemoryMatch.levelComplete = MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN;
                nextGameNumber = MemoryMatch.getNextGameNumber();
                MemoryMatch.unlockNextGameForLevel(MemoryMatch.gameLevel, nextGameNumber);
            }
            MemoryMatch.GameGUI.show(false);
            MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.RESULTS);
            MemoryMatch.GameResults.setup(MemoryMatch.stage, MemoryMatch.getGameData(MemoryMatch.isChallengeGame), MemoryMatch.levelResultsClosed);
            MemoryMatch.GameResults.buildScreen(true);
        }
    },

    showGameCompleted: function () {
        MemoryMatch.GameGUI.show(false);
        MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.GAMECOMPLETE);
        MemoryMatch.GameComplete.setup(MemoryMatch.stage, MemoryMatch.gameCompleteClosed);
        MemoryMatch.GameComplete.buildScreen(true);
    },

    gameCompleteClosed: function (request) {
        MemoryMatch.goToHomeScreen();
    },

    levelCleanUp: function () {
        // perform clean up tasks when a level is completed
        switch (MemoryMatch.gameType) {
            case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                MemoryMatch.Nemesis.removeNemesisCharacter();
                break;
            case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                MemoryMatch.removeChainsSprites();
                break;
            case MemoryMatch.GAMEPLAYTYPE.EYESPY:
            case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                MemoryMatch.simonBag = null;
                MemoryMatch.eyeSpyImageGroups = null;
                MemoryMatch.simonUserIndex = 0;
                if (MemoryMatch.cardSelected != null) {
                    MemoryMatch.boardContainer.removeChild(MemoryMatch.cardSelected);
                    MemoryMatch.cardSelected = null;
                }
                break;
            case MemoryMatch.GAMEPLAYTYPE.MONTE:
                MemoryMatch.simonBag = null;
                MemoryMatch.monteMoves = null;
                MemoryMatch.monteIndex = 0;
                MemoryMatch.monteNumberOfMoves = 0;
                break;
            case MemoryMatch.GAMEPLAYTYPE.SIMON:
                MemoryMatch.simonBag = null;
                MemoryMatch.simonPlaybackIndex = 0;
                MemoryMatch.simonUserIndex = 0;
                break;
            case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
            case MemoryMatch.GAMEPLAYTYPE.PATTERN:
            default:
                break;
        }
    },

    gameCleanUp: function () {

        // Reset all game variables to initial state

        MemoryMatch.gameInProgress = false;
        MemoryMatch.gameScore = 0;
        MemoryMatch.levelScore = 0;
        MemoryMatch.consecutiveMatchCount = 0;
        MemoryMatch.GameGUI.updateComboMultiplier(0);
        MemoryMatch.numberOfCombos = 0;
        MemoryMatch.luckyGuessCount = 0;
        MemoryMatch.missCount = 0;
        MemoryMatch.gameStartTime = 0;
        MemoryMatch.nextTimerUpdateTime = 0;
        MemoryMatch.lastMatchTime = 0;
        MemoryMatch.startingLevel = 1;
        MemoryMatch.startingGameNumber = 1;
        MemoryMatch.resetUserTotalScore();
    },

    getLevelData: function (level) {
        if (level == null) {
            level = MemoryMatch.gameLevel;
        }
        if (level < 1) {
            level = 1;
        }
        return MemoryMatch.GameSetup.levels[Math.min(level, MemoryMatch.GameSetup.levels.length) - 1];
    },

    getGameData: function (forChallenge) {
        // Return the game data configuration for the current level, either the game or the challenge.

        var thisGameData = null,
            gameLevelIndex,
            gameIndex,
            gameId,
            i;

        if (forChallenge == null) {
            forChallenge = MemoryMatch.isChallengeGame;
        }
        gameLevelIndex = Math.min(MemoryMatch.gameLevel, MemoryMatch.GameSetup.levels.length) - 1;
        if (MemoryMatch.gameData != null) {
            if (forChallenge) {
                gameId = MemoryMatch.GameSetup.levels[gameLevelIndex].challengeGameId;
            } else {
                gameId = MemoryMatch.GameSetup.levels[gameLevelIndex].gameId;
            }
            for (i = 0; i < MemoryMatch.gameData.length; i ++) {
                if (MemoryMatch.gameData[i].gameId == gameId) {
                    gameIndex = i;
                    break;
                }
            }
            if (gameIndex == null) {
                gameIndex = 0;
            }
            thisGameData = MemoryMatch.gameData[gameIndex];
        }
        return thisGameData;
    },

    getEyeSpyImageGroups: function () {
        var imageGroups = null,
            gameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);

        if (gameData != null) {
            imageGroups = gameData.imageGroups;
        }
        return imageGroups;
    },

    setImageSheet: function (spriteSheetAsset, spriteWidth, spriteHeight) {
        var loadedAsset = MemoryMatch.assetLoader.getResult(spriteSheetAsset);

        if (loadedAsset == null) {
            MemoryMatch.debugLog("setImageSheet: card sprites " + spriteSheetAsset + " not loaded.");
            MemoryMatch.imageSheetImage = null;
        } else if (MemoryMatch.imageSheetImage !== loadedAsset) {
            MemoryMatch.debugLog("setImageSheet: loading card sprites " + spriteSheetAsset + " size (" + spriteWidth + "," + spriteHeight + ")");
            MemoryMatch.imageSheetImage = loadedAsset;
            MemoryMatch.imageSheetSpriteWidth = spriteWidth;
            MemoryMatch.imageSheetSpriteHeight = spriteHeight;
            MemoryMatch.cardWidth = spriteWidth;
            MemoryMatch.cardHeight = spriteHeight;
        } else {
            MemoryMatch.debugLog("setImageSheet: card sprites " + spriteSheetAsset + " already loaded.");
        }
        return MemoryMatch.imageSheetImage != null;
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage.
        var bgImage = new createjs.Bitmap(MemoryMatch.backgroundImage),
            xScale,
            yScale;

        if (MemoryMatch.backgroundImage.width > canvas.width) {
            xScale = canvas.width / MemoryMatch.backgroundImage.width;
        } else {
            xScale = MemoryMatch.backgroundImage.width / canvas.width;
        }
        if (MemoryMatch.backgroundImage.height > canvas.height) {
            yScale = canvas.height / MemoryMatch.backgroundImage.height;
        } else {
            yScale = MemoryMatch.backgroundImage.height / canvas.height;
        }
        bgImage.cache(0, 0, MemoryMatch.backgroundImage.width, MemoryMatch.backgroundImage.height);
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;
        MemoryMatch.stage.addChild(bgImage);
        MemoryMatch.stageUpdated = true;
    },

    setBoardSize: function (numRows, numColumns) {
        MemoryMatch.rows = numRows;
        MemoryMatch.columns = numColumns;
    },

    allAssetsLoaded: function () {
        var totalLoadTime = Date.now() - this.gameStartTime;

        MemoryMatch.assetLoader.removeAllEventListeners();
        if (totalLoadTime < this.minimumSplashScreenDisplayTime) {
            window.setTimeout(this.readyToStart.bind(this), this.minimumSplashScreenDisplayTime - totalLoadTime);
        } else {
            this.readyToStart();
        }
        if (MemoryMatch.secondaryAssetManifest != null && MemoryMatch.secondaryAssetManifest.length > 0) {
            MemoryMatch.beginLoadSecondaryAssets();
        }
    },

    readyToStart: function () {
        MemoryMatch.hideLoader();
        if ( ! MemoryMatch.gameWasInitialized) {
            this.initializeGame();
        } else {
            this.reinitializeGame();
        }
    },

    showLoader: function () {
        if (document.getElementById(this.loaderElement) != null) {
            document.getElementById(this.loaderElement).style.display = "block";
            document.getElementById(this.stageCanvasElement).style.display = "none";
            MemoryMatch.stage.visible = false;
        }
    },

    hideLoader: function () {
        if (document.getElementById(this.loaderElement) != null) {
            document.getElementById(this.loaderElement).style.display = "none";
            document.getElementById(this.stageCanvasElement).style.display = "block";
            if (MemoryMatch.stage != null) {
                MemoryMatch.stage.visible = true;
            }
        }
    },

    assetLoadError: function (event) {
        var item = event.item,
            error = event.error;

        if (item != null) {
            if (error == null) {
                error = "unknown error";
            }
            if (item.ext == 'json' && item.id != null && item.src != null) {
                jQuery.getJSON(item.src, function(jsonObject) {
                    switch (item.id) {
                        case "guiSprites1json":
                            MemoryMatch.GameSetup.guiSpritesheet1Frames = jsonObject;
                            break;
                        case "guiSprites2json":
                            MemoryMatch.GameSetup.guiSpritesheet2Frames = jsonObject;
                            break;
                        case "guiSprites3json":
                            MemoryMatch.GameSetup.mapSpritesheetFrames = jsonObject;
                            break;
                        case "guiSprites4json":
                            MemoryMatch.GameSetup.shareIconsFrames = jsonObject;
                            break;
                        default:
                            break;
                    }
                });
            }
        }
    },

    assetLoadProgress: function (event) {
        var progressPercent = event.progress,
            progress = Math.floor(progressPercent * 100),
            progressText,
            canvas,
            context,
            gradient;

        if (document.getElementById("loaderProgress") != null && event.type == "progress") {

            // Draw a load bar. Starts at 20%, width is 60% of total width, Y center is 65% of total height
            canvas = document.getElementById(MemoryMatch.stageCanvasElement);
            if (canvas != null) {
                context = canvas.getContext('2d');
                context.save();
                context.beginPath();
                context.translate(MemoryMatch.stageWidth * 0.2, MemoryMatch.stageHeight * 0.65);

                // Draw progress frame:
                context.strokeStyle = jQuery('#loaderProgressFrameStroke').css("color");
                gradient = context.createLinearGradient(1, -1, 1, 28);
                gradient.addColorStop(0, jQuery('#loaderProgressFrameTop').css("color"));
                gradient.addColorStop(0.25, jQuery('#loaderProgressFrameMiddle').css("color"));
                gradient.addColorStop(1, jQuery('#loaderProgressFrameBottom').css("color"));
                context.fillStyle = gradient;
                context.moveTo(0, 0);
                context.fillRect(0, 0, MemoryMatch.stageWidth * 0.605, 28 * MemoryMatch.stageScaleFactor);
                context.stroke();

                // Draw progress bar:
                context.strokeStyle = jQuery('#loaderProgressStroke').css("color");
                gradient = context.createLinearGradient(1, -1, 1, 28);
                gradient.addColorStop(0, jQuery('#loaderProgressTop').css("color"));
                gradient.addColorStop(0.25, jQuery('#loaderProgressMiddle').css("color"));
                gradient.addColorStop(1, jQuery('#loaderProgressBottom').css("color"));
                context.fillStyle = gradient;
                context.moveTo(0, 0);
                context.fillRect(0, 0, progressPercent * (MemoryMatch.stageWidth * 0.605), 28 * MemoryMatch.stageScaleFactor);
                context.stroke();

                context.restore();
            }
            if (progress >= 100) {
                progressText = "Ready to play!";
            } else if (progress > 80) {
                progressText = "Oh! This is looking good... " + progress + "%";
            } else if (progress > 50) {
                progressText = "It's getting amazing!... " + progress + "%";
            } else {
                progressText = "We're loading awesomeness... " + progress + "%";
            }
            document.getElementById("loaderProgress").innerText = progressText;
        }
    },

    beginLoadSecondaryAssets: function () {
        var assetLoader = MemoryMatch.assetLoader,
            secondaryAssetManifest = MemoryMatch.secondaryAssetManifest;

        if (secondaryAssetManifest.length > 0) {
            assetLoader.addEventListener("complete", MemoryMatch.secondaryAssetsLoaded.bind(MemoryMatch));
            assetLoader.addEventListener("progress", MemoryMatch.secondaryAssetLoadProgress);
            assetLoader.addEventListener("error", MemoryMatch.secondaryAssetLoadError);
            assetLoader.loadManifest(secondaryAssetManifest);
            MemoryMatch.secondaryAssetManifest = null;
            MemoryMatch.secondaryAssetLoaderProgress = 0;
        }
    },

    secondaryAssetLoadProgress: function (event) {
        var progressPercent = event.progress,
            progress = Math.floor(progressPercent * 100);
        MemoryMatch.secondaryAssetLoaderProgress = progress;
        MemoryMatch.debugLog("Secondary progress " + progress.toString());
    },

    secondaryAssetLoadError: function (event) {
        var item = event.item,
            error = event.error;

        if (item != null) {
            if (error == null) {
                error = "unknown error";
            }
        }
        MemoryMatch.debugLog("Secondary error " + item.toString() + " " + error);
    },

    secondaryAssetsLoaded: function () {
        var assetLoader = MemoryMatch.assetLoader;
        assetLoader.removeAllEventListeners();
        MemoryMatch.debugLog("Secondary load complete!");
    },

    buildBoard: function () {
        // Determine the board layout.
        var distanceBetweenCards = MemoryMatch.cardMargin * 2.0,
            halfCardWidth = MemoryMatch.cardWidth * 0.5,
            halfCardHeight = MemoryMatch.cardHeight * 0.5,
            centerOfBoardX = (MemoryMatch.playAreaWidth * 0.5),
            centerOfBoardY = (MemoryMatch.playAreaHeight * 0.54), // a little extra to account for the HUD
            totalWidthNeeded = ((MemoryMatch.cardWidth + distanceBetweenCards) * MemoryMatch.columns),
            totalHeightNeeded = ((MemoryMatch.cardHeight + distanceBetweenCards) * MemoryMatch.rows),
            numberOfCards = 0,
            spriteData,
            gameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame),
            guiMatchCountLabel = null,
            allCardsShuffled,
            startCardFlipTime = 0,
            cardIndex,
            cardAnimator = null,
            cardValue,
            row,
            column,
            card,
            boardScale,
            boardScaleSmallReduction,
            startCount,
            startMatchCounter = -1;

        // Build a deck of cards based on the type of game we are simulating then shuffle the deck
        MemoryMatch.allCardsOnBoard = [];

        // scale the board based on how many cards are showing. Assumes symmetry.
        MemoryMatch.boardContainer.scaleX = 1.0;
        MemoryMatch.boardContainer.scaleY = 1.0;
        switch (MemoryMatch.gameType) {
            case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
                numberOfCards = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                allCardsShuffled = MemoryMatch.shuffleConcentrationDeck(numberOfCards + 1, MemoryMatch.numCardsAvailable); // one extra for the card back
                MemoryMatch.gameMatchCount = numberOfCards;
                startMatchCounter = MemoryMatch.getRandomNumberBetween(0, MemoryMatch.rows * MemoryMatch.columns - 1);
                break;
            case MemoryMatch.GAMEPLAYTYPE.CHAINS:
            case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                numberOfCards = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                allCardsShuffled = MemoryMatch.shuffleConcentrationDeck(numberOfCards + 1, MemoryMatch.numCardsAvailable); // one extra for the card back
                MemoryMatch.gameMatchCount = numberOfCards;
                if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.NEMESIS) {
                    startMatchCounter = MemoryMatch.getRandomNumberBetween(0, MemoryMatch.rows * MemoryMatch.columns - 1);
                }
                centerOfBoardX *= 0.9; // need to shift left a bit to accommodate the right side GUI sprites
                break;
            case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                if (MemoryMatch.gameMatchCount < 1) {
                    startCount = gameData.startMatchCount;
                    if (startCount == null || startCount < 1) {
                        startCount = 1;
                    }
                    MemoryMatch.gameMatchCount = startCount + MemoryMatch.gameNumber - 1;
                }
                numberOfCards = MemoryMatch.rows * MemoryMatch.columns;
                MemoryMatch.simonBag = MemoryMatch.shuffleUniqueDeck(0, numberOfCards - 1); // indexes of items in allCardsOnBoard, not the card values
                allCardsShuffled = MemoryMatch.shuffleAllCardsUniqueDeck(MemoryMatch.rows, MemoryMatch.columns, MemoryMatch.numCardsAvailable);
                centerOfBoardX *= 0.9; // need to shift left a bit to accommodate the right side target card
                break;
            case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                startCount = gameData.startMatchCount;
                if (startCount == null || startCount < 1) {
                    startCount = 5;
                }
                numberOfCards = startCount + MemoryMatch.gameNumber - 1;
                allCardsShuffled = MemoryMatch.shufflePatternDeck(MemoryMatch.rows, MemoryMatch.columns, numberOfCards, MemoryMatch.numCardsAvailable);
                MemoryMatch.gameMatchCount = numberOfCards;
                guiMatchCountLabel = 'Streak';
                break;
            case MemoryMatch.GAMEPLAYTYPE.SIMON:
                numberOfCards = MemoryMatch.rows * MemoryMatch.columns;
                allCardsShuffled = MemoryMatch.shuffleAllCardsUniqueDeck(MemoryMatch.rows, MemoryMatch.columns, MemoryMatch.numCardsAvailable);
                MemoryMatch.simonBag = MemoryMatch.makeShuffledBag(99, 0, numberOfCards - 1, 2); // indexes of items in allCardsOnBoard, not the card values
                MemoryMatch.gameMatchCount = 99;
                MemoryMatch.simonPlaybackIndex = 0;
                MemoryMatch.simonUserIndex = 0;
                guiMatchCountLabel = 'Streak';
                break;
            case MemoryMatch.GAMEPLAYTYPE.MONTE:
                if (MemoryMatch.monteNumberOfMoves == 0) {
                    if (gameData.shuffleCount == null || gameData.shuffleCount < 1) {
                        gameData.shuffleCount = 5;
                    }
                    MemoryMatch.monteNumberOfMoves = gameData.shuffleCount;
                } else {
                    MemoryMatch.monteNumberOfMoves ++;
                }
                if (gameData.cardAdvance != null && MemoryMatch.gameNumber >= gameData.cardAdvance) {
                    MemoryMatch.columns = gameData.advanceToColumns;
                    totalWidthNeeded = ((MemoryMatch.cardWidth + distanceBetweenCards) * MemoryMatch.columns);
                }
                allCardsShuffled = MemoryMatch.makeMonteDeck(MemoryMatch.rows, MemoryMatch.columns, MemoryMatch.numCardsAvailable);
                MemoryMatch.gameMatchCount = 1;
                guiMatchCountLabel = 'Streak';
                MemoryMatch.playShuffleMusic(true);
                break;
            case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                MemoryMatch.gameMatchCount = 1;
                MemoryMatch.simonUserIndex = 0;
                allCardsShuffled = MemoryMatch.makeEyeSpyDeck(); // TODO: SPECIAL CASE! If allCardsShuffled then no more boards, player wins!
                // makeEyeSpyDeck computes new values for rows/cols, need to determine new play area dimensions
                totalWidthNeeded = ((MemoryMatch.cardWidth + distanceBetweenCards) * MemoryMatch.columns);
                totalHeightNeeded = ((MemoryMatch.cardHeight + distanceBetweenCards) * (MemoryMatch.rows + 1));
                guiMatchCountLabel = 'Streak';
                centerOfBoardY -= halfCardHeight;
                break;
            default:
                numberOfCards = MemoryMatch.rows * MemoryMatch.columns;
                allCardsShuffled = MemoryMatch.shuffleAllCardsUniqueDeck(MemoryMatch.rows, MemoryMatch.columns, MemoryMatch.numCardsAvailable);
                MemoryMatch.gameMatchCount = numberOfCards;
                break;
        }
        if (allCardsShuffled == null) {
            // Player Wins (special case for EYESPY after we showed all possible boards). Instead of showing a new board, show the Game Results popup
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
            MemoryMatch.playerBeatChallenge = true;
            MemoryMatch.levelCleanUp();
            MemoryMatch.gameCompleteUpdateUserStats();
            MemoryMatch.levelResults();
        } else {
            spriteData = new createjs.SpriteSheet({
                "images": [MemoryMatch.imageSheetImage],
                "frames": {"regX": 0, "regY": 0, "width": MemoryMatch.cardWidth, "height": MemoryMatch.cardHeight, "count": 0}
            });

            // deal the cards on to the board
            cardIndex = 0;
            for (row = 0; row < MemoryMatch.rows; row ++) {
                for (column = 0; column < MemoryMatch.columns; column ++) {
                    card = MemoryMatch.makeCard(cardIndex, allCardsShuffled[cardIndex], spriteData);
                    if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.EYESPY) {
                        card.setTransform(column * (MemoryMatch.cardWidth + distanceBetweenCards), (row + 1) * (MemoryMatch.cardHeight + distanceBetweenCards));
                    } else {
                        card.setTransform(column * (MemoryMatch.cardWidth + distanceBetweenCards), row * (MemoryMatch.cardHeight + distanceBetweenCards));
                    }
                    MemoryMatch.boardContainer.addChild(card);
                    MemoryMatch.allCardsOnBoard.push(card);
                    cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(card, startCardFlipTime + (150 * cardIndex), 0, false, card.showCard, null);
                    cardAnimator.showAtBegin = true;
                    if (cardIndex == startMatchCounter) {
                        card.setMatchCounter(Math.ceil((MemoryMatch.rows * MemoryMatch.columns) * 0.5) + 1); // TODO: need to determine where this value should come from
                    }
                    totalWidthNeeded = (column * (MemoryMatch.cardWidth + distanceBetweenCards)) + MemoryMatch.cardWidth;
                    cardIndex ++;
                }
                totalHeightNeeded = (row * (MemoryMatch.cardHeight + distanceBetweenCards)) + MemoryMatch.cardHeight;
            }
            // Scale the board based on how many rows/columns are showing so it fits the play area given the size of the cards.
            boardScaleSmallReduction = MemoryMatch.cardScaleFactor < 0.5 ? 0.08 : 0;
            if (MemoryMatch.rows > 4 || MemoryMatch.columns > 8) {
                boardScale = 0.52 - boardScaleSmallReduction;
            } else if (MemoryMatch.rows > 3 || MemoryMatch.columns > 6) {
                boardScale = 0.64 - boardScaleSmallReduction;
            } else if (MemoryMatch.rows > 2 || MemoryMatch.columns > 4) {
                boardScale = 0.86 - boardScaleSmallReduction;
            } else {
                boardScale = 1.0;
            }
            boardScale = Math.floor(boardScale * 100) * 0.01;
            MemoryMatch.debugLog("Scaling board to " + boardScale.toString() + "% H/W (" + totalWidthNeeded + "," + totalHeightNeeded + ") center (" + centerOfBoardX + "," + centerOfBoardY + ")");
            MemoryMatch.boardContainer.setTransform(centerOfBoardX, centerOfBoardY, boardScale, boardScale, 0, 0, 0, totalWidthNeeded * 0.5 - halfCardWidth, totalHeightNeeded * 0.5 - halfCardHeight);


// Debugging the board placement
//            var bgColor = new createjs.Shape();
//            bgColor.graphics.beginFill("#FF0").drawRoundRect(MemoryMatch.cardWidth * -0.5, MemoryMatch.cardHeight * -0.5, totalWidthNeeded, totalHeightNeeded, 8);
//            bgColor.alpha = 0.3;
//            MemoryMatch.boardContainer.addChild(bgColor);
//            bgColor = new createjs.Shape();
//            bgColor.graphics.beginFill("#F00").drawRect(totalWidthNeeded * 0.5 - halfCardWidth - 4, totalHeightNeeded * 0.5 - halfCardHeight - 4, 8, 8);
//            MemoryMatch.boardContainer.addChild(bgColor);




            // perform post board setup tasks
            switch (MemoryMatch.gameType) {
                case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                    // make a target card
                    cardValue = MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[0]].value;
                    MemoryMatch.cardSelected = MemoryMatch.makeCard(cardIndex, cardValue, spriteData);
                    MemoryMatch.cardSelected.setTransform(MemoryMatch.columns * (MemoryMatch.cardWidth + distanceBetweenCards) + distanceBetweenCards, ((MemoryMatch.rows * (MemoryMatch.cardHeight + distanceBetweenCards)) * 0.5) - (MemoryMatch.cardHeight * 0.5));
                    MemoryMatch.boardContainer.addChild(MemoryMatch.cardSelected);
                    cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, startCardFlipTime + (150 * cardIndex), 0, false, MemoryMatch.cardSelected.showCard, null);
                    cardAnimator.showAtBegin = true;
                    break;
                case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                    // make a target card
                    cardValue = MemoryMatch.eyeSpyTargetCardValue;
                    if (MemoryMatch.cardSelected == null) {
                        MemoryMatch.cardSelected = MemoryMatch.makeCard(cardIndex, cardValue, spriteData);
                        MemoryMatch.cardSelected.setTransform((totalWidthNeeded - MemoryMatch.cardWidth) * 0.5, 0);
                        MemoryMatch.boardContainer.addChild(MemoryMatch.cardSelected);
                    } else {
                        MemoryMatch.cardSelected.setValue(cardValue);
                        MemoryMatch.cardSelected.x = (totalWidthNeeded - MemoryMatch.cardWidth) * 0.5;
                    }
                    cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, startCardFlipTime + (150 * cardIndex), 0, false, MemoryMatch.cardSelected.showCard, null);
                    cardAnimator.showAtBegin = true;
                    break;
                case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                    MemoryMatch.Nemesis.layoutNemesisPath(MemoryMatch.stage);
                    break;
                case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                    MemoryMatch.chainCount = [0];
                    MemoryMatch.layoutChainsPath();
                    break;
                default:
                    break;
            }
            MemoryMatch.GameGUI.setMatchCountLabel(guiMatchCountLabel);
            MemoryMatch.stageUpdated = true;
        }
    },

    shuffleConcentrationDeck: function (numberOfCards, numberOfCardsAvailable) {
        // make a deck with two of each card
        var allCardsAvailable = [],
            allCardsSelected = [],
            i;

        // make a deck of all available cards, then shuffle it
        for (i = 1; i < numberOfCardsAvailable; i ++) {
            allCardsAvailable.push(i);
        }
        allCardsAvailable = MemoryMatch.shuffleArray(allCardsAvailable);
        for (i = 1; i < numberOfCards; i ++) {
            // we need two of every card, 0 is the card back
            allCardsSelected.push(allCardsAvailable[i]);
            allCardsSelected.push(allCardsAvailable[i]);
        }
        return MemoryMatch.shuffleArray(allCardsSelected);
    },

    shufflePatternDeck: function (rows, columns, numberOfCorrectCards, numberOfCardsAvailable) {
        // Make a deck with only 2 cards - correct card, bad card
        var allCards = [],
            i,
            goodCard = MemoryMatch.getRandomNumberBetween(1, numberOfCardsAvailable),
            badCard = MemoryMatch.getRandomNumberBetweenButNot(1, numberOfCardsAvailable, goodCard);
        MemoryMatch.cardTargetValue = goodCard;

        for (i = 0; i < rows * columns; i ++) {
            if (allCards.length < numberOfCorrectCards) {
                allCards.push(goodCard);
            } else {
                allCards.push(badCard);
            }
        }
        return MemoryMatch.shuffleArray(allCards);
    },

    shuffleUniqueDeck: function (startValue, endValue) {
        // Make a deck with each number occurring only once, then shuffle it
        var allItems = [],
            i;

        for (i = startValue; i <= endValue; i ++) {
            allItems.push(i);
        }
        return MemoryMatch.shuffleArray(allItems);
    },

    shuffleAllCardsUniqueDeck: function (rows, columns, numberOfCardsAvailable) {
        // Make a deck with each card occurring only once
        // Remember 0 is the card back
        var allCards = [],
            i;
        numberOfCardsAvailable = Math.max(numberOfCardsAvailable, rows * columns);

        for (i = 1; i <= numberOfCardsAvailable; i ++) {
            allCards.push(i);
        }
        return MemoryMatch.shuffleArray(allCards);
    },

    makeMonteDeck: function (rows, columns, numberOfCardsAvailable) {
        // Make a deck with only 2 cards, the target card and all other cards the same
        // For best results use an odd number of cards 3 (1x3), 5 (1x5), 9 (3x3) work best
        var allCards = [],
            i,
            numberOfCards = rows * columns,
            medianIndex,
            goodCard = MemoryMatch.getRandomNumberBetween(1, numberOfCardsAvailable),
            badCard = MemoryMatch.getRandomNumberBetweenButNot(1, numberOfCardsAvailable, goodCard);
        MemoryMatch.cardTargetValue = goodCard;

        for (i = 1; i <= numberOfCards; i ++) {
            allCards.push(badCard);
        }
        if (numberOfCards % 2 == 0) {
            medianIndex = numberOfCards * 0.5;
        } else {
            medianIndex = (numberOfCards + 1) * 0.5;
        }
        allCards[medianIndex - 1] = goodCard;
        return allCards;
    },

    makeEyeSpyDeck: function () {
        var imageGroups,
            thisGameData,
            difficulty,
            gameData = null,
            allCards = null,
            shuffledCards = null,
            cardAssetId,
            cardSize,
            i,
            eyeSpyIndex,
            foundUnplayedData,
            playerWins,
            searchPass,
            randomBadCards = [],
            randomIndex;

        if (MemoryMatch.eyeSpyImageGroups == null) {
            MemoryMatch.eyeSpyImageGroups = MemoryMatch.buildRandomEyeSpyDataArray();
        }
        difficulty = MemoryMatch.getEyeSpyDifficultyForCurrentGame();
        playerWins = false;

        if (MemoryMatch.eyeSpyImageGroups != null) {
            // make sure difficulty will index a valid array index
            imageGroups = MemoryMatch.eyeSpyImageGroups[difficulty];
            if (imageGroups == null) {
                imageGroups = MemoryMatch.eyeSpyImageGroups[MemoryMatch.eyeSpyImageGroups.length - 1];
            }
            if (imageGroups != null) {
                // loop through the possibilities and find a random index that was not previously played
                eyeSpyIndex = MemoryMatch.getRandomNumberBetween(0, imageGroups.length - 1);
                foundUnplayedData = false;
                searchPass = 0;
                while ( ! foundUnplayedData && searchPass < 2) {
                    gameData = imageGroups[eyeSpyIndex];
                    if ( ! gameData.played) {
                        foundUnplayedData = true;
                    } else {
                        eyeSpyIndex ++;
                        if (eyeSpyIndex >= imageGroups.length) {
                            eyeSpyIndex = 0;
                            searchPass ++;
                        }
                    }
                }
                if ( ! foundUnplayedData && difficulty == 4) { // User played all available combinations, this player beat the game
                    playerWins = true;
                    MemoryMatch.debugLog("Game " + MemoryMatch.gameNumber + " Difficulty " + difficulty + " index " + eyeSpyIndex + " PLAYER WINS");
                } else if ( ! foundUnplayedData) { // Some type of data error
                    eyeSpyIndex = imageGroups.length - 1;
                    gameData = imageGroups[eyeSpyIndex];
                }
            }
            if ( ! playerWins) {
                MemoryMatch.debugLog("Game " + MemoryMatch.gameNumber + " Difficulty " + difficulty + " index " + eyeSpyIndex + " set " + gameData.sprites + " target " + gameData.targetCard + " played? " + (foundUnplayedData ? "NO" : "YES"));
                if (gameData !== null && gameData.matchCard !== null && gameData.badCards !== null && gameData.badCardCount !== null) {
                    gameData.played = true;
                    allCards = [gameData.matchCard];
                    for (i = 0; i < gameData.badCards.length; i ++) {
                        randomBadCards.push(gameData.badCards[i]);
                    }
                    for (i = 0; i < gameData.badCardCount; i ++) {
                        randomIndex = MemoryMatch.getRandomNumberBetween(0, randomBadCards.length - 1);
                        allCards.push(randomBadCards[randomIndex]);
                        randomBadCards.splice(randomIndex, 1);
                    }
                    MemoryMatch.rows = 1;
                    MemoryMatch.columns = allCards.length;
                    thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
                    if (thisGameData.cardSprites != null) {
                        cardAssetId = MemoryMatch.getSpriteAssetId(gameData.sprites);
                    } else {
                        cardAssetId = "cards1";
                    }
                    cardSize = MemoryMatch.getCardSize(thisGameData);
                    MemoryMatch.setImageSheet(cardAssetId, cardSize.width, cardSize.height);
                    shuffledCards = MemoryMatch.shuffleArray(allCards);
                    MemoryMatch.eyeSpyTargetCardValue = gameData.targetCard;
                    MemoryMatch.eyeSpyMatchCardValue = gameData.matchCard;
                }
            }
        }
        return shuffledCards;
    },

    buildRandomEyeSpyDataArray: function () {
        // create a fresh array of the EyeSpy possibilities, arranged by difficulty
        var imageGroups = MemoryMatch.getEyeSpyImageGroups(),
            i,
            eyeSpyDataArray,
            imageGroupData;

        if (imageGroups != null) {
            // organize items by difficulty and set the item to unplayed (so we can track which ones the player has seen)
            eyeSpyDataArray = [];
            for (i = 0; i < imageGroups.length; i ++) {
                imageGroupData = imageGroups[i];
                imageGroupData.played = false;
                if (eyeSpyDataArray[imageGroupData.difficulty] == null) {
                    eyeSpyDataArray[imageGroupData.difficulty] = [];
                }
                eyeSpyDataArray[imageGroupData.difficulty].push(imageGroupData);
            }
        }
        return eyeSpyDataArray;
    },

    getEyeSpyDifficultyForCurrentGame: function () {
        // set difficulty level based on how many games played to this point
        var difficulty,
            gameNumber = MemoryMatch.gameNumber;

        if (gameNumber < 3) { // 2 of diff 1
            difficulty = 1;
        } else if (gameNumber < 6) { // 3 of diff 2
            difficulty = 2;
        } else if (gameNumber <= 9) { // 4 of diff 3
            difficulty = 3;
        } else {
            difficulty = 4; // 6 of diff 4
        }
        return difficulty;
    },

    shuffleArray: function (arrayToShuffle) {
        var cardsToShuffle = arrayToShuffle.length - 1,
            allCardsShuffled = [],
            randomCardIndex,
            i;

        for (i = 0; i < cardsToShuffle; i ++) {
            randomCardIndex = MemoryMatch.getRandomNumberBetween(0, arrayToShuffle.length - 1);
            allCardsShuffled.push(arrayToShuffle[randomCardIndex]);
            arrayToShuffle.splice(randomCardIndex, 1);
        }
        allCardsShuffled.push(arrayToShuffle[0]); // should be the only remaining item
        return allCardsShuffled;
    },

    makeShuffledBag: function (numberOfItems, startValue, endValue, maxConsecutiveAllowed) {
        // build a "bag" of random values starting at startValue and no larger than endValue
        var i,
            shuffledArray = [],
            nextValue = -1,
            lastUsedValue = -1,
            lastUsedValueCount = 1,
            avoidInfiniteLoop = 0;

        if (maxConsecutiveAllowed == null) {
            maxConsecutiveAllowed = 0;
        }
        for (i = 0; i < numberOfItems; i ++) {
            nextValue = MemoryMatch.getRandomNumberBetween(startValue, endValue);
            if (nextValue == lastUsedValue && maxConsecutiveAllowed > 0) {
                lastUsedValueCount ++;
                if (lastUsedValueCount > maxConsecutiveAllowed) {
                    while (nextValue == lastUsedValue && avoidInfiniteLoop < 100) {
                        nextValue = MemoryMatch.getRandomNumberBetween(startValue, endValue);
                        avoidInfiniteLoop ++;
                    }
                    lastUsedValueCount = 1;
                }
            } else {
                lastUsedValueCount = 1;
            }
            shuffledArray.push(nextValue);
            lastUsedValue = nextValue;
        }
        return shuffledArray;
    },

    layoutChainsPath: function () {
        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            numberOfTiles = MemoryMatch.levelTolerance, // how many misses allowed == # of tiles
            tileFrame = "chainCardSlot1",
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame),
            tileGap = 0,
            tileHeight,
            tileSpriteSource = new createjs.Sprite(spriteData, tileFrame),
            tileNumberSource = new createjs.Text("1", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor),
            i,
            tileSprite,
            tileText,
            totalHeightRequired = numberOfTiles * (tileSize.height + tileGap);

        if (MemoryMatch.chainsGroupDisplayObject == null) {
            MemoryMatch.chainsGroupDisplayObject = new createjs.Container();
            MemoryMatch.stage.addChild(MemoryMatch.chainsGroupDisplayObject);
        } else {
            MemoryMatch.chainsGroupDisplayObject.removeAllChildren();
        }

        tileSpriteSource.framerate = 1;
        tileNumberSource.textAlign = 'center';
        tileNumberSource.textBaseline = 'middle';
        tileHeight = tileSize.height; // the first tile is the tallest, use that for reference since all the other tiles are different heights!
        tileGap = tileHeight * 0.25;
        for (i = 0; i < numberOfTiles; i ++) {
            tileSprite = tileSpriteSource.clone();
            tileText = tileNumberSource.clone();
            switch (i) {
                case 0:
                    tileFrame = "chainCardSlot1";
                    break;
                case 1:
                    tileFrame = "chainCardSlot2";
                    break;
                default:
                    tileFrame = "chainCardSlot3";
                    break;
            }
            tileSprite.gotoAndStop(tileFrame);
            tileSprite.name = "chainstile" + i;
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame);
            tileSprite.setTransform(tileSize.width * -0.5, (tileHeight + tileGap) * i, 1, 1, 0, 0, 0, 0, 0);
            tileSprite.width = tileSize.width;
            tileSprite.height = tileSize.height;
            tileText.name = "chainstext" + i;
            tileText.text = (i + 1).toString();
            tileText.setTransform(0, tileSprite.y + (tileSize.height * 0.5), 1, 1, 0, 0, 0, 0, 0);
            MemoryMatch.chainsGroupDisplayObject.addChild(tileSprite);
            MemoryMatch.chainsGroupDisplayObject.addChild(tileText);
        }
        MemoryMatch.chainsGroupDisplayObject.setTransform(MemoryMatch.stageWidth - (tileSize.width * 0.8), (MemoryMatch.stageHeight - totalHeightRequired) * 0.5, 1, 1, 0, 0, 0, 0, 0);
        MemoryMatch.stageUpdated = true;
    },

    updateChainCount: function (isMatch) {
        // Manage an array that tracks each chain. This just makes it so much easier to know the number of matches made at any time in the game.
        if (MemoryMatch.chainCount == null) {
            MemoryMatch.chainCount = [];
        }
        if (isMatch) {
            if (MemoryMatch.chainCount.length < 1) {
                MemoryMatch.chainCount.push(0);
            }
            MemoryMatch.chainCount[MemoryMatch.chainCount.length - 1] ++;
        } else {
            MemoryMatch.chainCount.push(0);
        }
    },

    showChainsMatches: function () {
        // display the match summary for the chains game.
        var chains = MemoryMatch.chainCount,
            spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            i,
            m,
            x = 0,
            y = 0,
            offset = 0,
            matchCount,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            cardFrame = "chainCard",
            cardSize = MemoryMatch.getSpriteFrameSize(spriteFrames, cardFrame),
            cardSpriteName,
            cardSprite,
            tileSprite,
            totalMatchCounter = 0,
            cardSpriteSource = new createjs.Sprite(spriteData, cardFrame),
            animator,
            startAnimationDelay = 250,
            animationDelay;

        if (chains.length > 0) {
            for (i = 0; i < chains.length; i ++) {
                matchCount = chains[i];
                offset = 0;
                tileSprite = MemoryMatch.chainsGroupDisplayObject.getChildByName("chainstile" + i);
                if (tileSprite != null) {
                    x = tileSprite.x + (tileSprite.width - cardSize.width) * 0.5;
                    y = tileSprite.y + (tileSprite.height - cardSize.height) * 0.5;
                    for (m = 0; m < matchCount; m ++) {
                        totalMatchCounter ++;
                        cardSpriteName = "chaincard" + totalMatchCounter;
                        cardSprite = MemoryMatch.chainsGroupDisplayObject.getChildByName(cardSpriteName);
                        if (cardSprite == null) {
                            cardSprite = cardSpriteSource.clone();
                            cardSprite.name = cardSpriteName;
                            MemoryMatch.chainsGroupDisplayObject.addChild(cardSprite);
                            cardSprite.visible = false;
                            animationDelay = startAnimationDelay + (100 * m);
                            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(cardSprite, startAnimationDelay + (100 * m), 0, false, null, null);
                            animator.showAtBegin = true;
                            MemoryMatch.triggerSoundFx("soundCardDeal", {delay: animationDelay});
                        } else {
                            cardSprite.visible = true;
                        }
                        cardSprite.setTransform(x + offset, y - offset);
                        offset += 4 * MemoryMatch.stageScaleFactor;
                    }
                }
            }
        }
    },

    removeChainsSprites: function () {
        if (MemoryMatch.chainsGroupDisplayObject != null) {
            MemoryMatch.chainsGroupDisplayObject.removeAllChildren();
            MemoryMatch.stage.removeChild(MemoryMatch.chainsGroupDisplayObject);
            MemoryMatch.chainsGroupDisplayObject = null;
            MemoryMatch.stageUpdated = true;
        }
    },

    updateGameTimers: function () {
        // if a game is in progress then check if timers need to be changed
        var timeNow = Date.now(),
            referenceTime;

        if (MemoryMatch.gameStartTime > 0) {
            if (MemoryMatch.gameEndTime > 0) {
                referenceTime = MemoryMatch.gameEndTime;
            } else {
                referenceTime = timeNow;
            }
            if (MemoryMatch.nextTimerUpdateTime < referenceTime) {
                MemoryMatch.GameGUI.updateGameTimerDisplay(timeNow - MemoryMatch.gameStartTime);
                MemoryMatch.nextTimerUpdateTime = timeNow + 1000;
            }
        } else {
            MemoryMatch.GameGUI.updateGameTimerDisplay(null);
        }
    },

    updateScoreDisplay: function (matchScore) {
        MemoryMatch.gameScore += matchScore;
        MemoryMatch.totalScore += matchScore;
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
    },

    updateScoreForMatch: function () {
        // when a match is made update the score based on current scoring parameters
        if (MemoryMatch.isChallengeGame) {
            MemoryMatch.updateScoreDisplay(MemoryMatch.gameNumber * 100);
        } else {
            MemoryMatch.updateScoreDisplay((MemoryMatch.gameLevel * 100) + ((MemoryMatch.consecutiveMatchCount - 1) * 100));
        }
    },

    updateScoreForSimon: function () {
        // when a match is made update the score based on Simon scoring parameters
        MemoryMatch.updateScoreDisplay(40 + (MemoryMatch.gameNumber * 10));
    },

    updateScoreForSimonGameAdvance: function () {
        // when a match is made update the score based on Simon scoring parameters
        MemoryMatch.updateScoreDisplay(100 * MemoryMatch.gameNumber);
        if (MemoryMatch.gameNumber > 15) {
            MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.MOZART);
        }
        MemoryMatch.awardChallengeStreakMilestone();
    },

    checkBoardIsReadyForPlay: function () {
        // check all cards for the level are visible
        var numberOfCardsInLevel,
            showCardCountdownTimer = false,
            timerShowTime;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.BOARD_SETUP) {
            numberOfCardsInLevel = MemoryMatch.rows * MemoryMatch.columns;
            MemoryMatch.numberOfCardsShowing ++;
            if (MemoryMatch.numberOfCardsShowing >= numberOfCardsInLevel) {
                switch (MemoryMatch.gameType) {
                    case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
                    case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                        MemoryMatch.gameStartTime = Date.now();
                        MemoryMatch.nextTimerUpdateTime = 0;
                        MemoryMatch.gameEndTime = 0;
                        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                        // we now want to briefly show all cards
                        MemoryMatch.showAllCards(true);
                        showCardCountdownTimer = true;
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowAllCardsWaitComplete);
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                        // we now want to briefly show the cards in the pattern
                        MemoryMatch.gameStartTime = Date.now();
                        MemoryMatch.nextTimerUpdateTime = 0;
                        MemoryMatch.gameEndTime = 0;
                        MemoryMatch.showAllPatternCards(true);
                        showCardCountdownTimer = true;
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowCardsWaitComplete);
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                        // we now want to briefly show all cards
                        MemoryMatch.showAllCards(true);
                        showCardCountdownTimer = true;
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowAllCardsWaitComplete);
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.SIMON:
                        // we now want to show all cards
                        MemoryMatch.showAllCards(true);
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], 2000, 0, false, null, MemoryMatch.onShowAllCardsWaitComplete);
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.MONTE:
                        // we now want to briefly show all cards
                        MemoryMatch.showAllCards(true);
                        showCardCountdownTimer = true;
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowAllCardsMonteWaitComplete);
                        break;
                    case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                        // show the target card
                        MemoryMatch.cardSelected.flip();
                        showCardCountdownTimer = true;
                        MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowTargetCardWaitComplete);
                        MemoryMatch.gameStartTime = Date.now();
                        MemoryMatch.nextTimerUpdateTime = 0;
                        MemoryMatch.gameEndTime = 0;
                        break;
                    default:
                        break;
                }
                if (showCardCountdownTimer) {
                    timerShowTime = Math.floor(MemoryMatch.cardShowTime / 1000);
                    if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.MONTE) {
                        timerShowTime += 2;
                    }
                    MemoryMatch.GameGUI.showTimerCountdown('Study', timerShowTime);
                    MemoryMatch.GameGUI.startTimerCountdown();
                }
            }
        }
    },

    onCardHighlight: function (evt) {
        evt.target.highlight();
    },

    onCardUnhighlight: function (evt) {
        evt.target.unhighlight();
    },

    onCardClicked: function (evt) {
        var cardSelected = evt.target.parent;

        if (cardSelected != null) {
            if ( ! cardSelected.isEnabled) {
                return;
            }
            if (cardSelected.cardSelectedHandler != null) {
                cardSelected.cardSelectedHandler();
            }
        }
        switch (MemoryMatch.gameType) {
            case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
            case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                MemoryMatch.onCardClickedConcentration(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                MemoryMatch.onCardClickedChains(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                MemoryMatch.onCardClickedPattern(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                MemoryMatch.onCardClickedHaystack(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.SIMON:
                MemoryMatch.onCardClickedSimon(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.MONTE:
                MemoryMatch.onCardClickedMonte(cardSelected);
                break;
            case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                MemoryMatch.onCardClickedEyeSpy(cardSelected);
                break;
            default:
                break;
        }
    },

    onCardClickedConcentration: function (secondCardSelected) {
        // this method handles CONCENTRATION and NEMESIS
        var earnedAchievement,
            isMatch = false,
            isMiss = false;

        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return;
        }
        if (secondCardSelected.state != MemoryMatch.CARDSTATE.DOWN) {
            return; // do not allow clicking a card that is not down
        }
        if (MemoryMatch.cardSelected == null) {
            MemoryMatch.cardSelected = secondCardSelected;
            MemoryMatch.cardSelected.select();
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
        } else if (MemoryMatch.cardSelected.cardNum != secondCardSelected.cardNum) {
            if (MemoryMatch.cardSelected.value == secondCardSelected.value) {
                secondCardSelected.select();
                isMatch = true;
                earnedAchievement = MemoryMatch.cardsMatch(MemoryMatch.cardSelected, secondCardSelected);
                if ( ! earnedAchievement) {
                    MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
                }

                // unselect both and remove cards
                MemoryMatch.cardSelected.removeCard(MemoryMatch.onCardRemoveComplete);
                secondCardSelected.removeCard(MemoryMatch.onCardRemoveCompleteLastCard);
                MemoryMatch.cardSelected = null;

                if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.NEMESIS) {
                    MemoryMatch.Nemesis.awakeNemesisCharacter();
                }
                if ((MemoryMatch.matchCount < MemoryMatch.gameMatchCount)) {
                    MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                }
            } else {
                isMiss = true;
                MemoryMatch.cardsDoNotMatch();
                MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});

                // unselect the first card then unflip it after a delay
                MemoryMatch.cardSelected.unselect();
                MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, 400, 0, false, null, MemoryMatch.onCardMissWaitComplete);

                // make the second card the selected card
                MemoryMatch.cardSelected = secondCardSelected;
                MemoryMatch.cardSelected.select();

                if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.NEMESIS) {
                    MemoryMatch.Nemesis.moveNemesisCharacter();
                }
            }
        } else {
            // turning back the first card counts as a miss
            isMiss = true;
            if (MemoryMatch.moveCountDown > 0) {
                MemoryMatch.moveCountDown --;
            }
            MemoryMatch.missCount ++;
            MemoryMatch.consecutiveMatchCount = 0;
            MemoryMatch.GameGUI.updateComboMultiplier(0);
            MemoryMatch.cardSelected.flipBack();
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
            MemoryMatch.cardSelected = null;
            MemoryMatch.updateMatchCountDisplay();
        }
        if (isMiss) {
            MemoryMatch.updateAllActiveMatchCounters();
        }
    },

    onCardClickedChains: function (secondCardSelected) {
        var isMiss = false;

        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return;
        }
        if (secondCardSelected.state != MemoryMatch.CARDSTATE.DOWN) {
            return; // do not allow clicking a card that is not down
        }
        if (MemoryMatch.cardSelected == null) {
            MemoryMatch.cardSelected = secondCardSelected;
            MemoryMatch.cardSelected.flip();
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
        } else if (MemoryMatch.cardSelected.cardNum != secondCardSelected.cardNum) {
            if (MemoryMatch.cardSelected.value == secondCardSelected.value) {
                secondCardSelected.flip();
                MemoryMatch.cardsMatch(MemoryMatch.cardSelected, secondCardSelected);
                MemoryMatch.cardSelected = null;
                MemoryMatch.updateChainCount(true);
                if ((MemoryMatch.matchCount >= MemoryMatch.gameMatchCount)) {
                    MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                    MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
                    MemoryMatch.gameEndTime = Date.now();
                    MemoryMatch.removeAllCards(MemoryMatch.gameCompleteRemoveCardThenAdvance); // user completed the game, but wait for cards to dissolve before advancing
                    MemoryMatch.showChainsMatches();
                } else {
                    MemoryMatch.triggerSoundFx("soundCorrectLess", {delay: 250});
                    MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                }
            } else {
                secondCardSelected.flip();
                isMiss = true;
                MemoryMatch.updateChainCount(false);
                MemoryMatch.showChainsMatches();
                MemoryMatch.cardsDoNotMatch();
                MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});
                // unselect both cards then unflip after a delay
                MemoryMatch.cardSelected.unselect();
                MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, 400, 0, false, null, MemoryMatch.onCardMissWaitComplete);
                MemoryMatch.AnimationHandler.addToAnimationQueue(secondCardSelected, 400, 0, false, null, MemoryMatch.onCardMissWaitCompleteChains);
                MemoryMatch.cardSelected = null;
            }
        }
        if (isMiss) {
            MemoryMatch.updateAllActiveMatchCounters();
        }
    },

    onCardClickedPattern: function (cardSelected) {
        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return;
        }
        if (cardSelected.state != MemoryMatch.CARDSTATE.DOWN) {
            return; // do not allow clicking a card that is not down
        }

        // is this a target card check the card value, 1=hit, 2=miss
        // if a miss? flip it back
        // if a hit, check if game over
        cardSelected.select();
        if (cardSelected.value == MemoryMatch.cardTargetValue || MemoryMatch.cheatChallengeNoMiss) {
            MemoryMatch.cardsMatch(cardSelected, null);
            if (MemoryMatch.matchCount >= MemoryMatch.gameMatchCount) {
                MemoryMatch.gameEndTime = Date.now();
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
                MemoryMatch.GameGUI.updateMatchCountDisplay(MemoryMatch.gameNumber);
                MemoryMatch.removeAllCards(MemoryMatch.gameCompleteRemoveCardThenAdvance); // user completed the game, but wait for cards to dissolve before advancing
                MemoryMatch.awardChallengeStreakMilestone();
            } else {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
            }
        } else {
            MemoryMatch.cardsDoNotMatch();
            MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});
            if (MemoryMatch.moveCountDown > 0 || MemoryMatch.levelTolerance == 0) {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
            } else {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LOSE; // Player lost, but we need to wait for the card to finish flipping
            }
            // unselect this card then unflip it after a delay
            cardSelected.unselect();
            MemoryMatch.AnimationHandler.addToAnimationQueue(cardSelected, 1000, 0, false, null, MemoryMatch.onCardMissWaitComplete);
        }
    },

    onCardClickedHaystack: function (cardSelected) {
        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return; // we are not ready for clicks yet
        }
        if (cardSelected == MemoryMatch.cardSelected) {
            return; // do not allow clicking on the target card
        }
        if (cardSelected.state != MemoryMatch.CARDSTATE.DOWN) {
            return; // do not allow clicking a card that is not down
        }
        cardSelected.select();
        if (cardSelected.value == MemoryMatch.cardSelected.value) {
            MemoryMatch.cardsMatch(cardSelected, null);
            MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
            MemoryMatch.AnimationHandler.addToAnimationQueue(cardSelected, 500, 0, false, null, MemoryMatch.onCardFlipBackWaitComplete);
            MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, 500, 0, false, null, MemoryMatch.onCardFlipBackWaitCompleteTargetCard);
        } else {
            MemoryMatch.cardsDoNotMatch();
            MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});
            if (MemoryMatch.matchCount >= MemoryMatch.gameMatchCount) {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LOSE;
            } else {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
            }
            // unselect this card then unflip it after a delay
            cardSelected.unselect();
            MemoryMatch.AnimationHandler.addToAnimationQueue(cardSelected, 1000, 0, false, null, MemoryMatch.onCardMissWaitComplete);
        }
    },

    onCardClickedSimon: function (cardClicked) {
        // state of the simon game when we wait for the user to tap in the sequence
        var globalCardPoint,
            thisGameData;

        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return; // we are not ready for clicks yet
        }
        cardClicked.unselect();
        cardClicked.specialSelect(1, false);
        MemoryMatch.playNote(cardClicked.cardNum + 1);
        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD) {
            if (cardClicked.value == MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex]].value || MemoryMatch.cheatChallengeNoMiss) {
                MemoryMatch.lastMatchTime = Date.now();
                if (MemoryMatch.simonUserIndex >= MemoryMatch.simonPlaybackIndex) {
                    MemoryMatch.simonUserIndex = 0;
                    MemoryMatch.simonPlaybackIndex ++;
                    MemoryMatch.gameNumber ++;
                    MemoryMatch.GameGUI.updateLevelDisplay(MemoryMatch.gameLevel, MemoryMatch.gameNumber);
                    MemoryMatch.updateMatchCountDisplay();
                    MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.PLAY_WAIT;
                    MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex]], 2000, 0, false, null, MemoryMatch.simonPlayback);
                    MemoryMatch.triggerSoundFx("soundCorrectLess", {delay: 200});
                    MemoryMatch.updateScoreForSimonGameAdvance();
                    globalCardPoint = MemoryMatch.boardContainer.localToGlobal(cardClicked.x, cardClicked.y);
                    MemoryMatch.matchEffectsStars(globalCardPoint.x, globalCardPoint.y, MemoryMatch.simonPlaybackIndex);
                    thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
                    if (MemoryMatch.simonPlaybackIndex >= thisGameData.games) { // user beat the challenge!
                        MemoryMatch.gameEndTime = Date.now();
                        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                        MemoryMatch.playerBeatChallenge = true;
                        MemoryMatch.removeAllCards(MemoryMatch.gameCompleteNextGameOrLevel);
                    }
                } else {
                    MemoryMatch.simonUserIndex ++;
                    MemoryMatch.updateScoreForSimon();
                }
            } else {
                MemoryMatch.missCount ++;
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LOSE;
                MemoryMatch.gameEndTime = Date.now();
                MemoryMatch.triggerSoundFx("soundMiss", {delay: 800});
                MemoryMatch.triggerSoundFx("soundMiss", {delay: 1200});
                MemoryMatch.removeAllCards(MemoryMatch.gameCompleteNextGameOrLevel);
            }
        }
    },

    onCardClickedMonte: function (cardSelected) {
        var globalCardPoint,
            priorState = MemoryMatch.gamePlayState,
            cardAnimator,
            i,
            card;

        if (priorState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && priorState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return;
        }
        if (cardSelected.state != MemoryMatch.CARDSTATE.DOWN) {
            return; // do not allow clicking a card that is not down
        }
        cardSelected.select();
        if (cardSelected.value == MemoryMatch.cardTargetValue || MemoryMatch.cheatChallengeNoMiss) {
            MemoryMatch.cardsMatch(cardSelected, null);
            MemoryMatch.gamePlayState = priorState;
            MemoryMatch.gameEndTime = Date.now();
            MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
            globalCardPoint = MemoryMatch.boardContainer.localToGlobal(cardSelected.x, cardSelected.y);
            MemoryMatch.matchEffectsStars(globalCardPoint.x, globalCardPoint.y, 1);
            MemoryMatch.GameGUI.updateMatchCountDisplay(MemoryMatch.gameNumber);
            MemoryMatch.removeAllCards(MemoryMatch.gameCompleteNextGameOrLevel); // user completed the game, but wait for cards to dissolve before advancing
            MemoryMatch.awardChallengeStreakMilestone();
        } else {
            MemoryMatch.cardsDoNotMatch();
            MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});
            // unselect card then unflip after a delay
            cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(cardSelected, 400, 0, false, null, MemoryMatch.onCardMissWaitComplete);
            if ( ! (MemoryMatch.moveCountDown > 0 || MemoryMatch.levelTolerance == 0)) { // game over? show target card
                for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                    card = MemoryMatch.allCardsOnBoard[i];
                    if (card.value == MemoryMatch.cardTargetValue && card.state == MemoryMatch.CARDSTATE.DOWN) {
                        MemoryMatch.AnimationHandler.addToAnimationQueue(card, 400, 0, false, null, card.select.bind(card));
                        break;
                    }
                }
            }
        }
    },

    onCardClickedEyeSpy: function (cardSelected) {
        var globalCardPoint,
            matchCardValue;

        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD) {
            return;
        }
        if (cardSelected.state != MemoryMatch.CARDSTATE.UP) {
            return; // do not allow clicking a card that is not up
        }
        matchCardValue = MemoryMatch.eyeSpyMatchCardValue;
        if (cardSelected.value == matchCardValue || MemoryMatch.cheatChallengeNoMiss) {
            MemoryMatch.cardsMatch(cardSelected, null);
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
            MemoryMatch.gameEndTime = Date.now();
            MemoryMatch.cardSelected.flip(); // Show user the card briefly before moving on
            MemoryMatch.triggerSoundFx("soundCorrect", {delay: 250});
            globalCardPoint = MemoryMatch.boardContainer.localToGlobal(cardSelected.x, cardSelected.y);
            MemoryMatch.matchEffectsStars(globalCardPoint.x, globalCardPoint.y, 1);
            MemoryMatch.GameGUI.updateMatchCountDisplay(MemoryMatch.gameNumber);
            MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, 1000, 0, false, null, MemoryMatch.onCardFlipCompleteEyeSpy);
            MemoryMatch.awardChallengeStreakMilestone();
        } else {
            MemoryMatch.cardsDoNotMatch();
            MemoryMatch.triggerSoundFx("soundMiss", {delay: 500});
            // unselect card then unflip after a delay
            MemoryMatch.AnimationHandler.addToAnimationQueue(cardSelected, 400, 0, false, null, MemoryMatch.onCardMissWaitComplete);
            if (MemoryMatch.moveCountDown == 0) {
                MemoryMatch.cardSelected.flip(); // Show user the card briefly before moving on
            }
        }
    },

    cardsMatch: function (firstCard, secondCard) {

        // perform variables & state updates when cards match.
        // Return true if an achievement was earned on this match.

        var matchTime = Date.now(),
            midpoint,
            totalMatchesEver,
            totalCombosEver,
            userDataObject,
            earnedAchievement = false;

        if (matchTime - MemoryMatch.lastMatchTime < 1600 && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.PATTERN) {
            earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.FASTMATCH);
        }
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CARDS_MATCH;
        MemoryMatch.lastMatchTime = matchTime;
        MemoryMatch.matchCount ++;
        MemoryMatch.levelMatchCounter ++;
        MemoryMatch.consecutiveMatchCount ++;
        if ( ! MemoryMatch.isChallengeGame && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.CHAINS && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.HAYSTACK) {
            if (MemoryMatch.consecutiveMatchCount > 1) {
                MemoryMatch.numberOfCombos ++;
                if (MemoryMatch.consecutiveMatchCount == 3) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.TRIPLECOMBO) | earnedAchievement;
                } else if (MemoryMatch.consecutiveMatchCount == 4) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.QUADBO) | earnedAchievement;
                }
                if (MemoryMatch.numberOfCombos == 5) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.FIVECOMBOS) | earnedAchievement;
                }
                if (matchTime - MemoryMatch.lastMatchTime < 1600) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.FASTCOMBO) | earnedAchievement;
                }
            }
            MemoryMatch.GameGUI.updateComboMultiplier(MemoryMatch.consecutiveMatchCount);
        }
        // Making a match counts as a "Move" - or not?
//        if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.CONCENTRATION) {
//            if (MemoryMatch.moveCountDown > 0) {
//                MemoryMatch.moveCountDown --;
//            }
//        }
        MemoryMatch.testForCardMatchCounterHit(firstCard, secondCard);
        if ( ! MemoryMatch.isChallengeGame) {
            MemoryMatch.updateMatchCountDisplay();
        }
        MemoryMatch.updateScoreForMatch();

        // Each time a match is made determine if certain achievements based on card matching have been attained

        userDataObject = this.UserData.getUserDataObject();
        if (userDataObject != null && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.PATTERN) {
            totalMatchesEver = (userDataObject['totalMatchCount'] | 0) + MemoryMatch.matchCount;
            totalCombosEver = (userDataObject['totalCombos'] | 0) + MemoryMatch.numberOfCombos;
            if (totalMatchesEver == 50) {
                earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.FIFTYMATCHES) | earnedAchievement;
            } else if (totalMatchesEver == 100) {
                earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.ONEHUNDREDMATCHES) | earnedAchievement;
            } else if (totalMatchesEver == 250) {
                earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.TWOFIFTYMATCHES) | earnedAchievement;
            }
            if (MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.CHAINS) {
                if (totalCombosEver == 25) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.TWENTYFIVECOMBOS) | earnedAchievement;
                } else if (totalCombosEver == 50) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.FIFTYCOMBOS) | earnedAchievement;
                }
            }
        }
        switch (MemoryMatch.gameType) {
            case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
            case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                if (MemoryMatch.gameMatchCount - MemoryMatch.matchCount > 0) { // not valid for the last match
                    if (firstCard.seenCount == 1 && secondCard.seenCount == 0) {
                        MemoryMatch.luckyGuessCount ++;
                        if ( ! MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.CLAIRVOYANT)) {
                            earnedAchievement = true;
                            midpoint = MemoryMatch.getMidpointBetween(MemoryMatch.boardContainer.localToGlobal(firstCard.x, firstCard.y), MemoryMatch.boardContainer.localToGlobal(secondCard.x, secondCard.y));
                            MemoryMatch.showInfoMessage({title: "Psychic!", points: 250, message: 'Match without revealing either card!', x: midpoint.x, y: midpoint.y, sound: 'soundAchievement'});
                        }
                    } else if (secondCard.seenCount == 0) {
                        MemoryMatch.luckyGuessCount ++;
                        if ( ! MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.LUCKYGUESS)) {
                            earnedAchievement = true;
                            midpoint = MemoryMatch.getMidpointBetween(MemoryMatch.boardContainer.localToGlobal(firstCard.x, firstCard.y), MemoryMatch.boardContainer.localToGlobal(secondCard.x, secondCard.y));
                            MemoryMatch.showInfoMessage({title: "Lucky guess!", points: 150, message: 'You never saw that 2nd card!', x: midpoint.x, y: midpoint.y, sound: 'soundAchievement'});
                        }
                    }
                }
                break;

            case MemoryMatch.GAMEPLAYTYPE.MONTE:
                if (MemoryMatch.gameNumber == 10) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.MONTE) | earnedAchievement;
                }
                break;
            case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                if (MemoryMatch.gameNumber >= 14) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.EAGLEEYE) | earnedAchievement;
                }
                 break;
            case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                if (MemoryMatch.matchCount >= MemoryMatch.gameMatchCount && MemoryMatch.gameNumber == 10) {
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.PICASSO) | earnedAchievement;
                }
                break;
            default:
                break;
        }
        return earnedAchievement;
    },

    cardsDoNotMatch: function () {
        // perform variables & state updates when cards do not match
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CARDS_NO_MATCH;
        if (MemoryMatch.moveCountDown > 0) {
            MemoryMatch.moveCountDown --;
        }
        MemoryMatch.missCount ++;
        MemoryMatch.consecutiveMatchCount = 0;
        MemoryMatch.GameGUI.updateComboMultiplier(0);
        if ( ! MemoryMatch.isChallengeGame) {
            MemoryMatch.updateMatchCountDisplay();
        }
    },

    updateMatchCountDisplay: function () {
        var newValue;

        if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.SIMON) {
            newValue = MemoryMatch.simonPlaybackIndex;
        } else if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.PATTERN || MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.MONTE || MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.EYESPY) {
            newValue = MemoryMatch.gameNumber - 1;
        } else {
            if (MemoryMatch.moveCountDown >= 0) {
                newValue = MemoryMatch.moveCountDown;
            } else {
                newValue = MemoryMatch.missCount;
            }
        }
        MemoryMatch.GameGUI.updateMatchCountDisplay(newValue);
    },

    awardChallengeStreakMilestone: function () {

        // Determine if the player has crossed the streak milestone. Note in this case the gameNumber has not yet been
        // incremented so we need to credit the player with one more as she just completed a board.

        var streakMilestoneValue = 5, // TODO: This number may be game dependent
            streakValue;

        if (MemoryMatch.isChallengeGame && MemoryMatch.gamePlayState != MemoryMatch.GAMESTATE.LOSE) {
            if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.SIMON) {
                streakValue = MemoryMatch.simonPlaybackIndex;
            } else if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.PATTERN || MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.MONTE || MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.EYESPY) {
                streakValue = MemoryMatch.gameNumber;
            }
            if (streakValue > 0 && streakValue % streakMilestoneValue == 0) {
                window.setTimeout(MemoryMatch.showChallengeStreakMilestone.bind(MemoryMatch), 1000);
            }
        }
    },

    showChallengeStreakMilestone: function () {
        var bonusPoints = 500;
        MemoryMatch.triggerSoundFx("soundBonus");
        MemoryMatch.GameGUI.flashMatchCountDisplay(true, 6);
        MemoryMatch.updateScoreDisplay(bonusPoints);
        MemoryMatch.showScoreBalloon(bonusPoints, {x: MemoryMatch.stageWidth * 0.8, y: MemoryMatch.stageHeight * 0.94});
    },

    matchEffects: function (x, y, level) {
        var selectAnEffect = Math.random() * 3;
        if (selectAnEffect <= 1) {
            MemoryMatch.matchEffectsBurst(x, y);
            if (level % 6 == 0) {
                MemoryMatch.matchEffectsSplatter(x, y);
            }
        } else if (selectAnEffect <= 2) {
            MemoryMatch.matchEffectsSplatter(x, y);
            if (level % 6 == 0) {
                MemoryMatch.matchEffectsBurst(x, y);
            }
        } else {
            MemoryMatch.matchEffectsSparkler(x, y);
            if (level % 6 == 0) {
                MemoryMatch.matchEffectsSplatter(x, y);
            }
        }
    },

    matchEffectsBurst: function (x, y) {
        MemoryMatch.AnimationHandler.startBurstParticles(Math.random() * 100 + 80, x, y);
    },

    matchEffectsSplatter: function (x, y) {
        MemoryMatch.AnimationHandler.startSplatterParticles(Math.random() * 100 + 80, x, y);
    },

    matchEffectsSparkler: function (x, y) {
        MemoryMatch.AnimationHandler.startSparklerParticles(Math.random() * 100 + 80, x, y);
    },

    matchEffectsStars: function (x, y, level) {
        MemoryMatch.AnimationHandler.startSplatterStars(Math.random() * 40 + 40, x, y);
    },

    onCardRemoveComplete: function (card) {
        card.state = MemoryMatch.CARDSTATE.REMOVED;
    },

    onCardRemoveCompleteLastCard: function (card) {
        card.state = MemoryMatch.CARDSTATE.REMOVED;
        if ((MemoryMatch.matchCount >= MemoryMatch.gameMatchCount)) {
            MemoryMatch.gameComplete(MemoryMatch.GAMEPLAYSTATE.WIN); // user completed the game
        } else {
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
        }
    },

    onCardRemoveCompleteAndDelete: function (card) {
        MemoryMatch.removeCardFromBoard(card);
    },

    onCardMissWaitComplete: function (card) {
        card.flipBack();
        if (MemoryMatch.moveCountDown > 0 || MemoryMatch.levelTolerance == 0) {
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
        } else {
            MemoryMatch.gameComplete(MemoryMatch.GAMEPLAYSTATE.LOSE); // user lost game due to too many misses
        }
    },

    onCardMissWaitCompleteChains: function (card) {
        MemoryMatch.removeAllMatchedCards(null);
        MemoryMatch.onCardMissWaitComplete(card);
    },

    onCardFlipCompleteEyeSpy: function (card) {
        card.flipBack();
        MemoryMatch.removeAllCards(MemoryMatch.gameCompleteNextGameOrLevel); // user completed the game, but wait for cards to dissolve before advancing
    },

    onCardFlipBackWaitComplete: function (card) {
        var gameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);

        card.flipBack();
        if (MemoryMatch.moveCountDown > 0 || MemoryMatch.levelTolerance == 0) {
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_SECOND_CARD;
            if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.HAYSTACK && gameData.removeMatches == 1) {
                card.removeCard(MemoryMatch.onCardRemoveComplete);
            }
        } else {
            MemoryMatch.gameComplete(MemoryMatch.GAMEPLAYSTATE.LOSE); // user lost game
        }
    },

    onCardFlipBackWaitCompleteTargetCard: function (card) {
        card.flipBack();
        if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.HAYSTACK) {
            if (MemoryMatch.matchCount >= MemoryMatch.gameMatchCount) {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                MemoryMatch.gameEndTime = Date.now();
                MemoryMatch.removeAllCards(MemoryMatch.gameCompleteRemoveCardThenAdvance); // user completed the game, but wait for cards to dissolve before advancing
            } else {
                MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.cardSelected, 500, 0, false, null, MemoryMatch.onHaystackNextTargetCard);
            }
        }
    },

    onShowCardsWaitComplete: function (card) {
        if (MemoryMatch.gamePaused) {
            return;
        }
        MemoryMatch.showAllPatternCards(false);
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
        MemoryMatch.GameGUI.hideTimerCountdown();
    },

    onShowAllCardsWaitComplete: function (card) {
        // Some game begin by showing the user some cards. After a timer expires
        // we need to turn the cards over and begin the game.
        var hideTimerCountDown = true;

        if (MemoryMatch.gamePaused) {
            return;
        }
        switch (MemoryMatch.gameType) {
            case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                // show the target card
                MemoryMatch.showAllCards(false);
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                MemoryMatch.cardSelected.flip();
                MemoryMatch.gameStartTime = Date.now();
                MemoryMatch.gameEndTime = 0;
                break;
            case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                MemoryMatch.showAllCards(false);
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                MemoryMatch.gameStartTime = Date.now();
                MemoryMatch.gameEndTime = 0;
                break;
            case MemoryMatch.GAMEPLAYTYPE.SIMON:
                // start the call/response play cycle
                MemoryMatch.simonPlayback();
                break;
            case MemoryMatch.GAMEPLAYTYPE.MONTE:
                // show the target card just a little longer...
                MemoryMatch.showAllCards(false);
                MemoryMatch.monteShuffle();
                hideTimerCountDown = false;
                break;
            case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                // Let user pick a card...
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                break;
            default:
                break;
        }
        if (hideTimerCountDown) {
            MemoryMatch.GameGUI.hideTimerCountdown();
        }
    },

    onShowAllCardsMonteWaitComplete: function (card) {
        // the first phase of Monte shows all the cards. Then all the invalid cards flip over leaving
        // the good card showing for just a bit longer. Then the good card flips over and then
        // we start the shuffle animation.
        var i;

        if (MemoryMatch.gamePaused) {
            return;
        }
        if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.MONTE) { // show the target card just a little longer
            // flip all cards except the target card
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (card.state == MemoryMatch.CARDSTATE.UP && card.value == 2) {
                    card.unselect();
                    card.flipBack();
                } else if (card.state == MemoryMatch.CARDSTATE.UP && card.value == 1) {
                    card.highlight();
                }
            }
            MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], MemoryMatch.cardShowTime, 0, false, null, MemoryMatch.onShowAllCardsWaitComplete);
        }
        MemoryMatch.GameGUI.hideTimerCountdown();
    },

    onShowTargetCardWaitComplete: function (card) {
        if (MemoryMatch.gamePaused) {
            return;
        }
        card.unselect();
        card.flipBack();
        MemoryMatch.showAllCards(true);
        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
        MemoryMatch.GameGUI.hideTimerCountdown();
    },

    showAllPatternCards: function (showFlag) {
        // flip all pattern cards for a glimpse at the pattern
        var i,
            card;

        for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
            card = MemoryMatch.allCardsOnBoard[i];
            if (showFlag && card.value == MemoryMatch.cardTargetValue && card.state == MemoryMatch.CARDSTATE.DOWN) {
                card.select();
            } else if ( ! showFlag && card.value == MemoryMatch.cardTargetValue && card.state == MemoryMatch.CARDSTATE.UP){
                card.unselect();
                card.flipBack();
            }
        }
    },

    showAllCards: function (showFlag) {
        // flip all cards for the player to remember
        var i,
            card;

        if (MemoryMatch.allCardsOnBoard != null) {
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (showFlag && card.state == MemoryMatch.CARDSTATE.DOWN) {
                    card.flip();
                } else if ( ! showFlag && card.state == MemoryMatch.CARDSTATE.UP){
                    card.unselect();
                    card.flipBack();
                }
            }
        }
    },

    turnBackAllCards: function () {
        // flip all cards so they are all face down
        var i,
            card;

        if (MemoryMatch.allCardsOnBoard != null && MemoryMatch.allCardsOnBoard.length > 0) {
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (card.state == MemoryMatch.CARDSTATE.UP) {
                    card.restoreFlag = true;
                    card.flipBack();
                }
            }
        }
    },

    restoreAllCards: function () {
        // flip any card that should be restored
        var i,
            card;

        if (MemoryMatch.allCardsOnBoard != null && MemoryMatch.allCardsOnBoard.length > 0) {
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (card.state == MemoryMatch.CARDSTATE.DOWN && card.restoreFlag) {
                    card.restoreFlag = false;
                    card.flip();
                }
            }
        }
    },

    removeAllCards: function (callMeWhenComplete) {
        var i,
            card;

        if (MemoryMatch.allCardsOnBoard != null && MemoryMatch.allCardsOnBoard.length > 0) {
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (card.state != MemoryMatch.CARDSTATE.REMOVED) {
                    if (callMeWhenComplete != null) {
                        card.removeCard(callMeWhenComplete);
                        callMeWhenComplete = null; // make sure we only call this once, callMeWhenComplete is responsible for deleting card from stage
                    } else {
                        card.removeCard(MemoryMatch.onCardRemoveCompleteAndDelete);
                    }
                } else {
                    MemoryMatch.removeCardFromBoard(card);
                }
            }
            MemoryMatch.allCardsOnBoard = null;
        }
        if (MemoryMatch.cardSelected != null && MemoryMatch.cardSelected.state != MemoryMatch.CARDSTATE.REMOVED) {
            if (callMeWhenComplete != null) {
                MemoryMatch.cardSelected.removeCard(callMeWhenComplete);
                callMeWhenComplete = null; // make sure we only call this once, callMeWhenComplete is responsible for deleting card from stage
            } else {
                MemoryMatch.cardSelected.removeCard(MemoryMatch.onCardRemoveCompleteAndDelete);
            }
            MemoryMatch.cardSelected = null;
        }
        if (callMeWhenComplete != null) { // make sure callMeWhenComplete is called even if no cards are to be removed
            callMeWhenComplete();
        }
    },

    removeAllMatchedCards: function (callMeWhenComplete) {
        var i,
            j,
            card,
            matchedCard,
            cardsToRemove;

        if (MemoryMatch.allCardsOnBoard != null && MemoryMatch.allCardsOnBoard.length > 0) {
            cardsToRemove = [];
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                if (card.state == MemoryMatch.CARDSTATE.UP) {
                    for (j = 0; j < MemoryMatch.allCardsOnBoard.length; j ++) {
                        matchedCard = MemoryMatch.allCardsOnBoard[j];
                        if (matchedCard.state == MemoryMatch.CARDSTATE.UP && matchedCard != card && matchedCard.value == card.value) {
                            cardsToRemove.push(i);
                            cardsToRemove.push(j);
                            card.removeCard(MemoryMatch.onCardRemoveCompleteAndDelete);
                            matchedCard.removeCard(MemoryMatch.onCardRemoveCompleteAndDelete);
                        }
                    }
                }
            }
            if (cardsToRemove.length > 0) {
                cardsToRemove.sort(function(a, b) {return a-b});
                for (i = cardsToRemove.length - 1; i >= 0; i --) {
                    MemoryMatch.allCardsOnBoard.splice(cardsToRemove[i], 1);
                }
            }
        }
        if (callMeWhenComplete != null) {
            callMeWhenComplete();
        }
    },

    clearBoard: function () {
        var i;

        if (MemoryMatch.boardContainer != null && MemoryMatch.boardContainer.getNumChildren() > 0) {
            for (i = MemoryMatch.boardContainer.getNumChildren(); i >= 0; i --) {
                MemoryMatch.boardContainer.removeChildAt(i);
            }
        }
    },

    logBoardState: function (whoCalledMe) {
        // This debug function will show the status of cards in the allCardsOnBoard array
        // and what cards are on the stage, in case the two get out of sync.
        var i,
            aCardIsActive,
            card;

        if (MemoryMatch.allCardsOnBoard != null && MemoryMatch.allCardsOnBoard.length > 0) {
            for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
                card = MemoryMatch.allCardsOnBoard[i];
                MemoryMatch.debugLog(whoCalledMe + ": active card info " + card.toString());
            }
        } else {
            MemoryMatch.debugLog(whoCalledMe + ": board is EMPTY");
        }
        // loop through all children on the stage and find any active cards
        aCardIsActive = false;
        for (i = 0; i < MemoryMatch.boardContainer.getNumChildren(); i ++) {
            card = MemoryMatch.boardContainer.getChildAt(i);
            if (card.state != null) {
                MemoryMatch.debugLog(whoCalledMe + ": dead card info " + card.toString());
                aCardIsActive = true;
            }
        }
        if ( ! aCardIsActive) {
            MemoryMatch.debugLog(whoCalledMe + ": no cards are on the stage");
        }
    },

    onHaystackNextTargetCard: function () {
        var cardIndex = MemoryMatch.simonBag[MemoryMatch.matchCount],
            card = MemoryMatch.allCardsOnBoard[cardIndex],
            cardValue = card.value;
        MemoryMatch.cardSelected.setValue(cardValue);
        MemoryMatch.cardSelected.flip();
    },

    simonPlayback: function () {
        // state of the simon game when we playback the sequence
        var card;

        if (MemoryMatch.gamePaused || MemoryMatch.simonBag == null) {
            return;
        }
        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.PLAY_WAIT) {
            // first time in set everything up for the playback to start
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.PLAY_WAIT;
            MemoryMatch.simonUserIndex = 0;
            MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex]], 500, 0, false, null, MemoryMatch.simonPlayback);
        } else {
            // Play each note until we reach the current index
            if (MemoryMatch.simonUserIndex <= MemoryMatch.simonPlaybackIndex) {
                if (MemoryMatch.simonUserIndex > 0) {
                    MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex - 1]].unselect();
                }
                card = MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex]];
                card.specialSelect(1, true);
                MemoryMatch.AnimationHandler.addToAnimationQueue(card, 500, 0, false, null, MemoryMatch.simonPlayback);
                MemoryMatch.playNote(card.cardNum + 1);
                MemoryMatch.simonUserIndex ++;
                if (MemoryMatch.gameStartTime == 0) {
                    MemoryMatch.gameStartTime = Date.now();
                    MemoryMatch.gameEndTime = 0;
                }
            } else {
                card = MemoryMatch.allCardsOnBoard[MemoryMatch.simonBag[MemoryMatch.simonUserIndex - 1]];
                card.unselect();
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                MemoryMatch.simonUserIndex = 0;
            }
        }
    },

    monteShuffle: function () {
        // Animation to shuffle the Monte cards.
        var i,
            firstCardIndex,
            secondCardIndex,
            thisGameData,
            firstCard,
            secondCard,
            halfTheDistance,
            yOffset,
            controlPoint,
            cardAnimator,
            cardSpeed;

        if (MemoryMatch.gamePaused) {
            return;
        }
        if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.PLAY_WAIT) {
            // first time in set everything up for the shuffle (game state should be BOARD_SETUP)
            // 1. build the animation sequence

            thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
            MemoryMatch.monteMoves = [];
            MemoryMatch.monteIndex = 0;
            // force target card as first shuffle
            firstCardIndex = Math.floor(MemoryMatch.allCardsOnBoard.length * 0.5);
            secondCardIndex = MemoryMatch.getRandomNumberBetweenButNot(0, MemoryMatch.allCardsOnBoard.length - 1, firstCardIndex);
            MemoryMatch.monteMoves.push([firstCardIndex, secondCardIndex]);
            for (i = 0; i < MemoryMatch.monteNumberOfMoves - 1; i ++) {
                firstCardIndex = MemoryMatch.getRandomNumberBetween(0, MemoryMatch.allCardsOnBoard.length - 1);
                secondCardIndex = MemoryMatch.getRandomNumberBetweenButNot(0, MemoryMatch.allCardsOnBoard.length - 1, firstCardIndex);
                MemoryMatch.monteMoves.push([firstCardIndex, secondCardIndex]);
            }
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.PLAY_WAIT;
            MemoryMatch.AnimationHandler.addToAnimationQueue(MemoryMatch.allCardsOnBoard[0], 500, 0, false, null, MemoryMatch.monteShuffle);
        } else {
            // Shuffle pairs of cards until we play out all the moves. Select 2 cards to shuffle. Move the first
            // card to the second, and the second card to the first.
            if (MemoryMatch.monteIndex < MemoryMatch.monteMoves.length) {
                firstCardIndex = MemoryMatch.monteMoves[MemoryMatch.monteIndex][0];
                secondCardIndex = MemoryMatch.monteMoves[MemoryMatch.monteIndex][1];
                firstCard = MemoryMatch.allCardsOnBoard[firstCardIndex];
                secondCard = MemoryMatch.allCardsOnBoard[secondCardIndex];
                cardSpeed = 15;

                // move first card to second, and second to first
                halfTheDistance = (secondCard.x - firstCard.x) * 0.5;
                if (halfTheDistance < 0) {
                    yOffset = secondCard.y - 60;
                } else {
                    yOffset = secondCard.y + 60;
                }
                controlPoint = {x: firstCard.x + halfTheDistance, y: yOffset};

                cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(firstCard, 0, 0, false, null, null);
                cardAnimator.currentPointIndex = 0;
                cardAnimator.arrayOfPoints = MemoryMatch.makeBezierPointArray(firstCard, controlPoint, secondCard, cardSpeed);
                cardAnimator.continueChain = false;
                cardAnimator.tickFunction = MemoryMatch.moveSpriteOnPath;

                cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(secondCard, 0, 0, false, null, null);
                cardAnimator.currentPointIndex = 0;
                cardAnimator.arrayOfPoints = MemoryMatch.makeBezierPointArray(secondCard, controlPoint, firstCard, cardSpeed);
                cardAnimator.continueChain = true;
                cardAnimator.tickFunction = MemoryMatch.moveSpriteOnPath;
            } else { // we played all the shuffles, clean up and let the user find the card
                MemoryMatch.monteMoves = null;
                MemoryMatch.monteIndex = 0;
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.CHOOSE_FIRST_CARD;
                MemoryMatch.gameStartTime = Date.now();
                MemoryMatch.gameEndTime = 0;
                MemoryMatch.playShuffleMusic(false);
            }
        }
    },

    moveSpriteOnPath: function (cardAnimator) {
        var keepAnimating = true,
            card = cardAnimator.actor;

        if (card != null && cardAnimator.arrayOfPoints != null && cardAnimator.arrayOfPoints.length > 0 && cardAnimator.currentPointIndex < cardAnimator.arrayOfPoints.length) {
            card.x = cardAnimator.arrayOfPoints[cardAnimator.currentPointIndex].x;
            card.y = cardAnimator.arrayOfPoints[cardAnimator.currentPointIndex].y;
            cardAnimator.currentPointIndex ++;
            if (cardAnimator.currentPointIndex >= cardAnimator.arrayOfPoints.length) {
                keepAnimating = false;
                cardAnimator.arrayOfPoints = null;
                cardAnimator.currentPointIndex = 0;
                if (cardAnimator.continueChain) {
                    MemoryMatch.monteIndex ++;
                    MemoryMatch.AnimationHandler.addToAnimationQueue(card, 100, 0, false, null, MemoryMatch.monteShuffle);
                }
            }
        } else {
            keepAnimating = false;
        }
        return keepAnimating;
    },

    makeLevelImageAssetName: function (levelNumber, imageNumber) {
        // generate the asset reference for image files for a given level. Assumes the images
        // were defined in the setup data using the same technique.

        return "image-l" + levelNumber + "-i" + imageNumber;
    },

    makeLevelCardDeckAssetName: function (levelNumber, imageNumber) {
        // generate the asset reference for card deck spritesheet for a given level. Assumes the images
        // were defined in the setup data using the same technique.

        return "cards-l" + levelNumber + "-i" + imageNumber;
    },

    gameCompleteTallyFinalScore: function () {
        var playerScore = MemoryMatch.gameScore,
            timeBonus = MemoryMatch.calculateTimeBonus(),
            movesRemainingBonus = MemoryMatch.calculateUnusedMovesBonus(),
            comboBonus = MemoryMatch.calculateComboBonus(),
            achievementBonus = MemoryMatch.calculateAchievementBonus(),
            totalBonusScore = timeBonus + movesRemainingBonus + comboBonus + achievementBonus;

        playerScore += totalBonusScore;
        MemoryMatch.totalScore += totalBonusScore;
        MemoryMatch.GameGUI.updateScoreDisplay(MemoryMatch.totalScore);
        return playerScore;
    },

    gameCompleteNextGameOrLevel: function () {
        var canUserAdvance = false,
            showLevelResults = true,
            finalScore,
            earnedAchievement = false,
            updateUserStats = false,
            gameNumber,
            thisGameData;

        if (MemoryMatch.isChallengeGame) {
            canUserAdvance = true;
        } else {
            canUserAdvance = MemoryMatch.canUserAdvance();
            updateUserStats = true;
        }
        if (canUserAdvance) {
            gameNumber = MemoryMatch.gameNumber;
            if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.LOSE) {
                // user finished a game but was in the lose state, in this case force a Results screen to appear. Clicking Next on that will determine what to do next.
                if (MemoryMatch.isChallengeGame) {
                    updateUserStats = true;
                }
                MemoryMatch.levelCleanUp();
            } else if (MemoryMatch.gameData != null) {
                if ( ! MemoryMatch.isChallengeGame && gameNumber >= MemoryMatch.numberOfGamesInLevel) {
                    // User beat the level, show a level results screen
                    MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                    MemoryMatch.levelCleanUp();
                } else if (MemoryMatch.isChallengeGame) {
                    thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
                    if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.SIMON) {
                        gameNumber = MemoryMatch.simonPlaybackIndex;
                    }
                    if (gameNumber >= thisGameData.games) { // user beat the challenge!
                        MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                        MemoryMatch.playerBeatChallenge = true;
                        MemoryMatch.levelCleanUp();
                        updateUserStats = true;
                        showLevelResults = true;
                    } else {
                        showLevelResults = false;
                        MemoryMatch.gameNumber ++;
                        MemoryMatch.startNextGame();
                    }
                }
            }
        } else {
            // User did not beat this game and cannot unlock the next game (unless they already had unlocked it)
            if (MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.WIN && MemoryMatch.gamePlayState != MemoryMatch.GAMEPLAYSTATE.LOSE) {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.LOSE;
            }
            MemoryMatch.levelCleanUp();
        }
        if (updateUserStats) {
            earnedAchievement = MemoryMatch.gameCompleteUpdateUserStats();
            finalScore = MemoryMatch.gameCompleteTallyFinalScore();
        } else {
            finalScore = MemoryMatch.gameScore;
        }
        if (showLevelResults) {
            MemoryMatch.levelResults();
        }
        MemoryMatch.gameScore = finalScore; // update game score with bonus earned, but after we showed level results (because we do it there too)
        return earnedAchievement;
    },

    gameCompleteUpdateUserStats: function () {
        var earnedAchievement = false,
            starsEarned,
            finalScore,
            gameNumber,
            longestStreak,
            gameTime;

        if (MemoryMatch.isChallengeGame) {
            gameNumber = 99;
            longestStreak = MemoryMatch.gameNumber - 1;
        } else {
            gameNumber = MemoryMatch.gameNumber;
            longestStreak = 0;
        }
        gameTime = MemoryMatch.gameEndTime - MemoryMatch.gameStartTime;
        finalScore = MemoryMatch.gameCompleteTallyFinalScore();
        starsEarned = MemoryMatch.getGameStarsEarned();
        if (MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN) {
            if (gameTime <= 5999 && ! MemoryMatch.isChallengeGame) { // finished game in 5 seconds or less
                earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.QUICKDRAW) | earnedAchievement;
            }
            if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.CHAINS) {
                if (MemoryMatch.missCount == 0) {
                    MemoryMatch.chainsStreakCount ++;
                    if (MemoryMatch.gameNumber >= MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].gameCount) { // is this the last chains game?
                        earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.CHAINTASTIC) | earnedAchievement;
                    }
                } else {
                    MemoryMatch.chainsStreakCount = 0;
                }
                if (MemoryMatch.chainsStreakCount > 1) { // two chains in a row without a miss?
                    earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.CHAINGANG) | earnedAchievement;
                }
            }
        }
        MemoryMatch.updateUserDataStatsForCompletedGamePlay(finalScore, MemoryMatch.matchCount, MemoryMatch.numberOfCombos, gameTime, MemoryMatch.luckyGuessCount);
        MemoryMatch.setGameUserData(MemoryMatch.gameLevel, gameNumber, finalScore, starsEarned, MemoryMatch.gameEndTime, longestStreak);
        if (starsEarned == 3 && MemoryMatch.userEarnedAllStars()) {
            earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.THREESTAR) | earnedAchievement;
        }
        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.challengePassed()) {
                MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.WIN;
                if ( ! MemoryMatch.userBeatAllChallenges) {
                    MemoryMatch.userBeatAllChallenges = MemoryMatch.didUserBeatAllChallenges();
                    if (MemoryMatch.userBeatAllChallenges) {
                        MemoryMatch.userBeatAllChallengesFirstTime = true;
                        earnedAchievement = MemoryMatch.achievementEarned(MemoryMatch.ACHIEVEMENT.ACONTENDER) | earnedAchievement;
                    }
                }
            }
        }
        return earnedAchievement;
    },

    gameComplete: function (winOrLose) {
        if (MemoryMatch.gameEndTime == 0) {
            MemoryMatch.gameEndTime = Date.now();
        }
        MemoryMatch.gamePlayState = winOrLose;
        if (MemoryMatch.moveCountDown <= 0 && MemoryMatch.levelTolerance > 0) {
            // Player lost the game due to running out of moves, wait for the cards to dissolve before moving on
            MemoryMatch.removeAllCards(MemoryMatch.gameCompleteRemoveCardThenAdvance);
        } else {
            MemoryMatch.removeAllCards(null);
            MemoryMatch.gameCompleteNextGameOrLevel();
        }
    },

    gameCompleteRemoveCardThenAdvance: function (card) {
        if (MemoryMatch.gameEndTime == 0) {
            MemoryMatch.gameEndTime = Date.now();
        }
        MemoryMatch.removeCardFromBoard(card);
        MemoryMatch.gameCompleteNextGameOrLevel();
    },

    restartGameRemoveCardThenRestart: function (card) {
        MemoryMatch.removeCardFromBoard(card);
        window.setTimeout(MemoryMatch.replayLastGame.bind(MemoryMatch), 600); // need a delay to wait for the card fade-out animation to complete
    },

    restartChallengeGameRemoveCardThenReplay: function (card) {
        MemoryMatch.removeCardFromBoard(card);
        window.setTimeout(MemoryMatch.replayCurrentChallengeGame.bind(MemoryMatch), 600); // need a delay to wait for the card fade-out animation to complete
    },

    gameOver: function () {
        // point where the game is officially ended
        MemoryMatch.lastPlayedDate = Date.now();
        MemoryMatch.updateUserDataObject(null);
    },

    removeCardFromBoard: function (card) {
        if (card != null) {
            card.state = MemoryMatch.CARDSTATE.REMOVED;
            if (card == MemoryMatch.cardSelected) {
                MemoryMatch.cardSelected = null;
            }
            MemoryMatch.boardContainer.removeChild(card);
        }
    },

    updateAllActiveMatchCounters: function () {
        var i,
            card;

        for (i = 0; i < MemoryMatch.allCardsOnBoard.length; i ++) {
            card = MemoryMatch.allCardsOnBoard[i];
            if (card.matchCounter > 0) {
                card.updateMatchCounter();
            }
        }
    },

    testForCardMatchCounterHit: function (firstCard, secondCard) {
        var score = 0,
            card;

        if (firstCard != null && secondCard != null && (firstCard.matchCounter > 0 || secondCard.matchCounter > 0)) {
            if (firstCard.matchCounter > 0) {
                card = firstCard;
            } else {
                card = secondCard;
            }
            score = (firstCard.matchCounter | secondCard.matchCounter) * 100;
            MemoryMatch.updateScoreDisplay(score);
            MemoryMatch.showScoreBalloonOnCard(score, card);
            MemoryMatch.triggerSoundFx("soundAchievement", {delay: 100});
        }
        return score > 0;
    },

    showScoreBalloonOnCard: function (score, card) {
        var cardPoint = MemoryMatch.boardContainer.localToGlobal(card.x, card.y);
        return MemoryMatch.showScoreBalloon(score, cardPoint);
    },

    showScoreBalloon: function (score, cardPoint) {
        var animator,
            bounds,
            comboBonusText = new createjs.Text("+ " + score.toString(), MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColorBonus);

        comboBonusText.textAlign = "center";
        bounds = comboBonusText.getBounds();
        comboBonusText.maxWidth = bounds.width;;
        comboBonusText.visible = true;
        comboBonusText.setTransform(cardPoint.x, cardPoint.y);
        comboBonusText.shadow = new createjs.Shadow("#000000", 2, 2, 10);
        MemoryMatch.stage.addChild(comboBonusText);
        animator = MemoryMatch.AnimationHandler.addToAnimationQueue(comboBonusText, 250, 0, true, null, null);
        animator.showAtBegin = true;
        animator.vAlpha = -0.011;
        animator.vY = -1.5;
        animator.vXScale = 0.003;
        animator.endXScale = 1.25;
        animator.vYScale = 0.003;
        animator.endYScale = 1.25;
        return true;
    },

    showMessageBalloon: function (iconId, message, points, x, y) {
        // TODO: Show text sprite, animate it
        var animator,
            bounds,
            startX,
            startY,
            width,
            height,
            groupDisplayObject = new createjs.Container(),
            iconSprite,
            iconSize,
            iconScale = 0.25,
            spriteData,
            messageText,
            pointsText;

        if (iconId != null && iconId.length > 0) {
            spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            iconSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, iconId);
            width = (iconSize.width * iconScale) + (16 * MemoryMatch.stageScaleFactor);
            height = iconSize.height * iconScale;
            iconSprite = new createjs.Sprite(spriteData, iconId);
            iconSprite.setTransform(0, height * 0.5, iconScale, iconScale, 0, 0, 0, 0, iconSize.height * 0.5);
            iconSprite.framerate = 1;
            iconSprite.name = "icon";
            groupDisplayObject.addChild(iconSprite);
        } else {
            width = 0;
            height = 0;
        }
        startX = 0;
        messageText = new createjs.Text(message, MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        messageText.textAlign = "left";
        if (height > 0) {
            messageText.textBaseline = "middle";
        }
        messageText.x = width;
        messageText.y = height * 0.5;
        bounds = messageText.getBounds();
        width += bounds.width;
        if (bounds.height > height) {
            height = bounds.height;
        }
        if (bounds.y < 0) {
            startY = bounds.y;
        } else {
            startY = 0;
        }
        messageText.maxWidth = bounds.width;
        messageText.visible = true;
        messageText.shadow = new createjs.Shadow("#000000", 2, 2, 10);
        groupDisplayObject.addChild(messageText);
        if (points != null && points.length > 0) {
            pointsText = new createjs.Text(points, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
            pointsText.textAlign = "left";
            pointsText.x = (20 * MemoryMatch.stageScaleFactor) + width;
            bounds = pointsText.getBounds();
            width += (22 * MemoryMatch.stageScaleFactor) + bounds.width;
            if (bounds.height > height) {
                height = bounds.height;
            }
            pointsText.visible = true;
            pointsText.shadow = messageText.shadow;
            groupDisplayObject.addChild(pointsText);
        }
        width += (12 * MemoryMatch.stageScaleFactor); // need to account for shadows
        height += (12 * MemoryMatch.stageScaleFactor);
        MemoryMatch.stage.addChild(groupDisplayObject);
        groupDisplayObject.setTransform(x, y, 1, 1, 0, 0, 0, width * 0.5, 0);
        groupDisplayObject.cache(startX, startY, width, height);
        animator = MemoryMatch.AnimationHandler.addToAnimationQueue(groupDisplayObject, 250, 0, true, null, null);
        animator.showAtBegin = true;
        animator.vAlpha = -0.011;
        animator.vY = -1.5;
        animator.vXScale = 0.003;
        animator.endXScale = 1.25;
        animator.vYScale = 0.003;
        animator.endYScale = 1.25;
    },

    changeGameState: function (newState) {
        MemoryMatch.gamePriorState = MemoryMatch.gameState;
        MemoryMatch.gameState = newState;
        MemoryMatch.gameStateStartTime = Date.now();
    },

    getNextGameNumber: function () {
        // determine what the next game number will be, and if at the end then return the challenge game id
        var currentGameNumber = MemoryMatch.gameNumber,
            nextGameNumber,
            levelData;

        if (MemoryMatch.isChallengeGame) {
            nextGameNumber = 1;
        } else {
            levelData = MemoryMatch.getLevelData(MemoryMatch.gameLevel);
            currentGameNumber ++;
            if (currentGameNumber > levelData.gameCount) {
                nextGameNumber = 99;
            } else {
                nextGameNumber = currentGameNumber;
            }
        }
        return nextGameNumber;
    },

    restoreLastSession: function () {
        // return true session was restored, false no session previously active
        return false;
    },

    restoreUsers: function () {
        // restore all the user data, and if none, initialize it
        var previousDataLoaded = this.UserData.load(),
            userDataObject;

        if ( ! previousDataLoaded) {
            this.initUserData();
        } else {
            this.UserData.setCurrentUser(this.userId);
            userDataObject = this.UserData.getUserDataObject();
            if (userDataObject != null) {
                this.audioMute = userDataObject['audioMute'] | false;
                this.userBeatAllChallenges = userDataObject['beatAllChallenges'] | false;
                this.lastPlayedDate = userDataObject['lastPlayedDate'];
                createjs.Sound.setMute(this.audioMute);
            }
        }
        // this.UserData.debug();
    },

    updateUserDataStatsForCompletedGamePlay: function (score, matchesEarned, combosEarned, timePlayed, luckyGuesses) {

        // this function updates the user's data for overall statistics. you should call it after the completion of a game.

        var userDataObject = this.UserData.getUserDataObject(),
            numberOfGamesPlayed,
            totalMatchCount,
            totalCombos,
            totalTimePlayed,
            luckyGuessCount,
            bestScore;

        if (userDataObject != null) {
            numberOfGamesPlayed = userDataObject['numberOfGamesPlayed'] | 0;
            totalMatchCount = userDataObject['totalMatchCount'] | 0;
            totalCombos = userDataObject['totalCombos'] | 0;
            totalTimePlayed = userDataObject['totalTimePlayed'] | 0;
            luckyGuessCount = userDataObject['luckyGuessCount'] | 0;
            bestScore = userDataObject['bestScore'] | 0;
            if (score > bestScore) {
                bestScore = score;
            }
            numberOfGamesPlayed ++;
            totalMatchCount += matchesEarned;
            totalCombos += combosEarned;
            luckyGuessCount += luckyGuesses;
            totalTimePlayed += timePlayed;
            userDataObject['numberOfGamesPlayed'] = numberOfGamesPlayed;
            userDataObject['luckyGuessCount'] = luckyGuessCount;
            userDataObject['totalMatchCount'] = totalMatchCount;
            userDataObject['totalCombos'] = totalCombos;
            userDataObject['totalTimePlayed'] = totalTimePlayed;
            userDataObject['bestScore'] = bestScore;
            if (this.lastPlayedDate != null) {
                userDataObject['lastPlayedDate'] = this.lastPlayedDate;
            }
            userDataObject['audioMute'] = this.audioMute;
            userDataObject['beatAllChallenges'] = this.userBeatAllChallenges;
            MemoryMatch.UserData.flush();
        }
    },

    initUserData: function () {
        // Create the first user and unlock first game for all levels
        MemoryMatch.UserData.addUser(1, '', '', '', true);
        MemoryMatch.resetUserData();
    },

    resetUserTotalScore: function () {
        // totalScore is the sum of all best level scores
        var totalScore = 0,
            levelNumber,
            levelScoreCollection,
            i;

        for (levelNumber = 1; levelNumber <= MemoryMatch.GameSetup.levels.length; levelNumber ++) {
            levelScoreCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");
            if (levelScoreCollection != null) {
                for (i = 0; i < levelScoreCollection.length; i ++) {
                    totalScore += levelScoreCollection[i].bestScore;
                }
            }
        }
        MemoryMatch.totalScore = totalScore;
        return totalScore;
    },

    unlockAllLevels: function () {
        var levelNumber,
            gameNumber,
            numberOfGamesInLevel;

        for (levelNumber = 1; levelNumber <= MemoryMatch.GameSetup.levels.length; levelNumber ++) {
            numberOfGamesInLevel = MemoryMatch.GameSetup.levels[levelNumber - 1].gameCount;
            for (gameNumber = 1; gameNumber <= numberOfGamesInLevel; gameNumber ++) {
                MemoryMatch.setGameUserData(levelNumber, gameNumber, 900 + Math.floor(Math.random() * 250), 3, Date.now(), 0);
            }
            MemoryMatch.setGameUserData(levelNumber, 99, 900 + Math.floor(Math.random() * 250), 3, Date.now(), 2);
        }
        MemoryMatch.UserData.flush();
    },

    resetUserData: function () {

        // Reset the user data to initial conditions. Current user will lose everything and start the game as if for the first time!

        var levelNumber,
            userDataObject = MemoryMatch.UserData.getUserDataObject(),
            unlockAllFirstLevels = MemoryMatch.GameSetup.unlockAllFirstLevels || false;

        for (levelNumber = 1; levelNumber <= MemoryMatch.GameSetup.levels.length; levelNumber ++) {
            if (unlockAllFirstLevels || ( ! unlockAllFirstLevels && levelNumber == 1)) {
                MemoryMatch.UserData.setLevelDataItem(levelNumber, "levelScoreCollection", [{gameId: 1, bestScore: 0, starsEarned: 0, lastPlayedDate: 0, playCount: 0}]);
            } else {
                MemoryMatch.UserData.setLevelDataItem(levelNumber, "levelScoreCollection", []);
            }
        }
        MemoryMatch.UserData.clearAllUserAchievements();
        MemoryMatch.UserData.clearAllUserTips();
        userDataObject['audioMute'] = this.audioMute; // keep the Audio setting
        userDataObject['beatAllChallenges'] = false;
        userDataObject['numberOfGamesPlayed'] = 0;
        userDataObject['luckyGuessCount'] = 0;
        userDataObject['totalMatchCount'] = 0;
        userDataObject['totalCombos'] = 0;
        userDataObject['totalTimePlayed'] = 0;
        userDataObject['bestScore'] = 0;
        userDataObject['lastPlayedDate'] = null;
        userDataObject['askBookmark'] = 0;
        MemoryMatch.UserData.flush();
    },

    updateUserDataObject: function (parametersObject) {
        // copy key/values from parameters to userDataObject and save it
        var updated = false,
            key,
            userDataObject = MemoryMatch.UserData.getUserDataObject();

        // if we are given specific parameters to update
        if (parametersObject != null) {
            for (key in parametersObject) {
                if (parametersObject.hasOwnProperty(key)) {
                    userDataObject[key] = parametersObject[key];
                    updated = true;
                }
            }
        } else { // otherwise save what we know we are supposed to be tracking
            userDataObject['audioMute'] = this.audioMute;
            userDataObject['beatAllChallenges'] = this.userBeatAllChallenges;
            updated = true;
        }
        if (updated) {
            MemoryMatch.UserData.flush();
        }
    },

    unlockNextGameForLevel: function (levelNumber, gameNumber) {
        // make sure the level/game score data is initialized.
        // if a record appears in this array then the game is unlocked.
        var i,
            unlocked = false,
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");

        for (i = 0; i < gameScoresCollection.length; i ++) {
            if (gameScoresCollection[i].gameId == gameNumber) {
                unlocked = true;
                break;
            }
        }
        if ( ! unlocked) {
            gameScoresCollection.push({gameId: gameNumber, bestScore: 0, starsEarned: 0, lastPlayedDate: 0, playCount: 0});
            unlocked = true;
            MemoryMatch.UserData.flush();
        }
        return unlocked;
    },

    setGameUserData: function (levelNumber, gameNumber, bestScore, starsEarned, lastPlayedDate, longestStreak) {
        var i,
            gameData,
            dataWasUpdated = false,
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");

        if (gameScoresCollection == null) {
            // this is the first game saved so initialize the collection
            gameScoresCollection = [{gameId: gameNumber, bestScore: bestScore, starsEarned: starsEarned, lastPlayedDate: lastPlayedDate, playCount: 1, longestStreak: longestStreak}];
            dataWasUpdated = MemoryMatch.UserData.setLevelDataItem(levelNumber, "levelScoreCollection", gameScoresCollection);
        } else {
            // find the item matching this gameNumber and update in place
            for (i = 0; i < gameScoresCollection.length; i ++) {
                gameData = gameScoresCollection[i];
                if (gameData.gameId == gameNumber) {
                    gameData.playCount ++;
                    if (bestScore > gameData.bestScore) { // only update if bested
                        gameData.bestScore = bestScore;
                    }
                    if (starsEarned > gameData.starsEarned) { // only update if bested
                        gameData.starsEarned = starsEarned;
                    }
                    if (gameData.longestStreak == null) {
                        gameData.longestStreak = 0;
                    }
                    if (longestStreak > gameData.longestStreak) { // only update if bested
                        gameData.longestStreak = longestStreak;
                    }
                    if (lastPlayedDate == null || lastPlayedDate == 0) {
                        gameData.lastPlayedDate = Date.now();
                    } else {
                        gameData.lastPlayedDate = lastPlayedDate;
                    }
                    dataWasUpdated = true;
                }
            }
            if ( ! dataWasUpdated) {
                gameScoresCollection.push({gameId: gameNumber, bestScore: bestScore, starsEarned: starsEarned, lastPlayedDate: lastPlayedDate, playCount: 1, longestStreak: longestStreak});
                dataWasUpdated = true;
            }
        }
        if (dataWasUpdated) {
            MemoryMatch.UserData.flush();
        }
        return dataWasUpdated;
    },

    getPriorScoreDataForGameNumber: function (gameNumber, gameScoresCollection) {
        var i,
            gameData = null;

        if (gameScoresCollection == null) {
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(MemoryMatch.gameLevel, "levelScoreCollection");
        }
        if (gameScoresCollection != null && gameScoresCollection.length > 0) {
            for (i = 0; i < gameScoresCollection.length; i ++) {
                if (gameScoresCollection[i].gameId == gameNumber) {
                    gameData = gameScoresCollection[i];
                    break;
                }
            }
        }
        return gameData;
    },

    getPriorBestScoreForGameNumber: function (gameLevel, gameNumber) {
        var i,
            priorBestScore = 0,
            gameScoresCollection;

        gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(gameLevel, "levelScoreCollection");
        if (gameScoresCollection != null && gameScoresCollection.length > 0) {
            for (i = 0; i < gameScoresCollection.length; i ++) {
                if (gameScoresCollection[i].gameId == gameNumber) {
                    priorBestScore = gameScoresCollection[i].bestScore;
                    break;
                }
            }
        }
        return priorBestScore;
    },

    getGameLevelNumberOffset: function (levelNumber) {
        // for a given level, determine the game number to offset to get a contiguous game counter across all levels
        var gameLevelIndex,
            startGameNumberOffset = 0;

        levelNumber --;
        for (gameLevelIndex = 0; gameLevelIndex < MemoryMatch.GameSetup.levels.length; gameLevelIndex ++) {
            if (levelNumber > gameLevelIndex) {
                startGameNumberOffset += MemoryMatch.GameSetup.levels[gameLevelIndex].gameCount + 1;
            } else {
                break;
            }
        }
        return startGameNumberOffset;
    },

    isChallengeGameUnlocked: function (levelNumber) {

        // The Challenge game is unlocked if player earned at least 1 stars on all games in the level

        var i,
            starsNeeded = 1,
            gamesWithTwoOrMoreStars = 0,
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");

        if (gameScoresCollection != null && gameScoresCollection.length > 0) {
            for (i = 0; i < gameScoresCollection.length; i ++) {
                if (gameScoresCollection[i].starsEarned >= starsNeeded) {
                    gamesWithTwoOrMoreStars ++;
                } else {
                    break;
                }
            }
        }
        return gamesWithTwoOrMoreStars >= MemoryMatch.getLevelData(levelNumber).gameCount;
    },

    determineLevelStars: function (levelNumber) {
        // Logic assumes 3 stars per game.
        // Must play all games in level to earn any level stars.
        // The number of stars earned in a level is determined from the stars earned in each individual game:
        // Beat the challenge game + half the games with 3 stars and at least 2 stars in each game = 3 stars

        var levelStars = 0,
            i,
            gamesWithThreeOrMoreStars = 0,
            gamesWithTwoOrMoreStars = 0,
            gamesWithOneOrMoreStars = 0,
            totalStarCount = 0,
            averageStars,
            gamesInLevel = MemoryMatch.getLevelData(levelNumber).gameCount,
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");

        if (gameScoresCollection.length >= gamesInLevel) {
            if (gameScoresCollection != null && gameScoresCollection.length > 0) {
                for (i = 0; i < gameScoresCollection.length; i ++) {
                    totalStarCount += gameScoresCollection[i].starsEarned;
                    if (gameScoresCollection[i].starsEarned > 2) {
                        gamesWithThreeOrMoreStars ++;
                    }
                    if (gameScoresCollection[i].starsEarned > 1) {
                        gamesWithTwoOrMoreStars ++;
                    }
                    if (gameScoresCollection[i].starsEarned > 0) {
                        gamesWithOneOrMoreStars ++;
                    }
                }
            }
            averageStars = totalStarCount / gamesInLevel;
            if (gamesWithThreeOrMoreStars >= (gamesInLevel * 0.5) && gamesWithTwoOrMoreStars >= gamesInLevel) {
                levelStars = 3;
            } else if (gamesWithTwoOrMoreStars >= (gamesInLevel * 0.5) && gamesWithOneOrMoreStars >= gamesInLevel) {
                levelStars = 2;
            } else if (averageStars >= 1.5) { // 9+ stars
                levelStars = 1;
            } else {
                levelStars = 0;
            }
        }
        return levelStars;
    },

    userEarnedAllStars: function () {

        // Logic assumes 3 stars per game.
        // Returns true if user earned all stars in all games (except Challenge games)

        var allStarsEarned = true,
            levelIndex,
            levelNumber,
            i,
            gamesInLevel,
            gameScoresCollection;

        for (levelIndex = 0; levelIndex < MemoryMatch.GameSetup.levels.length; levelIndex ++) {
            levelNumber = levelIndex + 1;
            gamesInLevel = MemoryMatch.getLevelData(levelNumber).gameCount;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");
            if (gameScoresCollection.length >= gamesInLevel) { // make sure user played all games in level
                if (gameScoresCollection != null && gameScoresCollection.length > 0) {
                    for (i = 0; i < gameScoresCollection.length; i ++) {
                        if (gameScoresCollection[i].gameId < 99 && gameScoresCollection[i].starsEarned < 3) {
                            allStarsEarned = false;
                            break;
                        }
                    }
                }
            } else {
                allStarsEarned = false;
            }
            if ( ! allStarsEarned) {
                break;
            }
        }
        return allStarsEarned;
    },

    getGameStarsEarned: function () {
        var hasPriorData = MemoryMatch.getPriorScoreDataForGameNumber(MemoryMatch.gameNumber, null),
            gameStarsEarned = MemoryMatch.starsEarnedInCurrentGame();

        if (hasPriorData !== null && hasPriorData.starsEarned > gameStarsEarned) { // stars earned is the greater of current stars earned or previous stars earned
            gameStarsEarned = hasPriorData.starsEarned;
        }
        return gameStarsEarned;
    },

    getPriorGameStarsEarned: function () {
        var gameStarsEarned = 0,
            hasPriorData = MemoryMatch.getPriorScoreDataForGameNumber(MemoryMatch.gameNumber, null);

        if (hasPriorData && hasPriorData.starsEarned > 0) {
            gameStarsEarned = hasPriorData.starsEarned;
        }
        return gameStarsEarned;
    },

    calculateTimeBonus: function () {
        var totalGameTime,
            timeBonus = 0;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            totalGameTime = MemoryMatch.gameEndTime - MemoryMatch.gameStartTime;
            timeBonus = (3000 * (MemoryMatch.rows * MemoryMatch.columns)) - totalGameTime;
            if (timeBonus > 0) {
                timeBonus = Math.max(100, Math.min(1000, Math.floor(timeBonus / 1000) * 100));
            } else {
                timeBonus = 0;
            }
        }
        return timeBonus;
    },

    calculateUnusedMovesBonus: function () {
        var bonus = 0;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN && MemoryMatch.levelTolerance > 0) {
            bonus = (MemoryMatch.levelTolerance - MemoryMatch.missCount) * 100;
        }
        return bonus;
    },

    calculateComboBonus: function () {
        var bonus = 0;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            bonus = MemoryMatch.numberOfCombos * 100;
        }
        return bonus;
    },

    calculateAchievementBonus: function () {
        var bonus = 0;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            bonus = 0; // TODO: We ned to add up the values of the individual achievements earned in this level
        }
        return bonus;
    },

    canUserAdvance: function () {
        // TODO: user just completed a game, we need to verify they earned a score/stars to advance to the next game
        // They would automatically advance if they already unlocked the next game. Otherwise we need to
        // check their current results to see if the unlocked the next level.

        var canUserAdvance = false,
            hasPriorData = MemoryMatch.getPriorScoreDataForGameNumber(MemoryMatch.getNextGameNumber(), null);

        if (hasPriorData != null) {
            canUserAdvance = true; // user already has the next game unlocked
        } else if (MemoryMatch.isChallengeGame) {
            canUserAdvance = MemoryMatch.challengePassed(); // did user beat challenge?
        } else {
            canUserAdvance = MemoryMatch.getGameStarsEarned() > 0 && MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN; // did user beat the game?
            if ( ! canUserAdvance && (MemoryMatch.gameNumber == MemoryMatch.getLevelData(MemoryMatch.gameLevel).gameCount)) { // if last game in level can we get to Challenge Game now?
                canUserAdvance = MemoryMatch.isChallengeGameUnlocked(MemoryMatch.gameLevel)
            }
        }
        return canUserAdvance;
    },

    isGameUnlocked: function (gameNumber) {
        // Check if a specific game in the current level is unlocked

        var unlocked = false,
            hasPriorData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, null);

        if (hasPriorData != null) {
            unlocked = true;
        }
        return unlocked;
    },

    convertLevelNumberToLevelAndGameNumber: function (levelNumber) {
        // Convert level number (e.g. 28) to level and game number (e.g. 4, 99)

        var i,
            levelStartOffset,
            matched,
            gameNumber;

        levelStartOffset = 0;
        matched = false;
        for (i = 0; i < MemoryMatch.GameSetup.levels.length; i ++) {
            gameNumber = MemoryMatch.GameSetup.levels[i].gameCount + 1;
            if (levelNumber <= levelStartOffset + gameNumber) {
                gameNumber = levelNumber - levelStartOffset;
                levelNumber = i + 1;
                if (gameNumber > MemoryMatch.GameSetup.levels[i].gameCount) {
                    gameNumber = 99; // the Challenge Game
                }
                matched = true;
                break;
            } else {
                levelStartOffset += gameNumber;
            }
        }
        if ( ! matched) {
            levelNumber = 1;
            gameNumber = 1;
        }
        return {levelNumber: levelNumber, gameNumber: gameNumber};
    },

    isLevelUnlocked: function (levelNumber, gameNumber) {
        // Check if a specific game in the current level is unlocked
        // if gameNumber is null then levelNumber is absolute value game number (level - 1 * numberOfLevels + levelNumber % number of games in level)
        // if gameNumber is provided then levelNumber and gameNumber as per standard game rules

        var unlocked = false,
            i,
            levelAndGameNumber,
            gameScoresCollection,
            gameData = null;

        if (gameNumber === undefined || gameNumber === null) {
            // convert levelNumber to levelNumber and gameNumber, e.g 28 to 4, 7
            levelAndGameNumber = MemoryMatch.convertLevelNumberToLevelAndGameNumber(levelNumber);
            levelNumber = levelAndGameNumber.levelNumber;
            gameNumber = levelAndGameNumber.gameNumber;
        }
        gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");
        if (gameScoresCollection != null && gameScoresCollection.length > 0) {
            for (i = 0; i < gameScoresCollection.length; i ++) {
                if (gameScoresCollection[i].gameId == gameNumber) {
                    gameData = gameScoresCollection[i];
                    break;
                }
            }
        }
        if (gameData != null) {
            unlocked = true;
        }
        return unlocked;
    },

    challengePassed: function () {
        return MemoryMatch.isChallengeGame && (MemoryMatch.gameNumber - 1) >= MemoryMatch.challengeAdvanceStreak;
    },

    didUserBeatChallenge: function (landNumber) {
        var i,
            challengePassed = false,
            gameScoresCollection,
            challengeAdvanceStreak;

        if (landNumber < 1) {
            landNumber = 1;
        } else if (landNumber > MemoryMatch.GameSetup.levels) {
            landNumber = MemoryMatch.GameSetup.levels;
        }
        gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(landNumber, "levelScoreCollection");
        challengeAdvanceStreak = MemoryMatch.GameSetup.levels[landNumber - 1].challengeAdvanceStreak;
        if (gameScoresCollection != null && gameScoresCollection.length > 0) {
            for (i = 0; i < gameScoresCollection.length; i ++) {
                if (gameScoresCollection[i].gameId == 99 && gameScoresCollection[i].longestStreak >= challengeAdvanceStreak) {
                    challengePassed = true;
                    break;
                }
            }
        }
        return challengePassed;
    },

    didUserBeatAllChallenges: function () {
        var challengesPassed = 0,
            i,
            levelIndex,
            levelNumber,
            challengeAdvanceStreak,
            gameScoresCollection;

        for (levelIndex = 0; levelIndex < MemoryMatch.GameSetup.levels.length; levelIndex ++) {
            levelNumber = levelIndex + 1;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(levelNumber, "levelScoreCollection");
            challengeAdvanceStreak = MemoryMatch.GameSetup.levels[levelIndex].challengeAdvanceStreak;
            if (gameScoresCollection != null && gameScoresCollection.length > 0) {
                for (i = 0; i < gameScoresCollection.length; i ++) {
                    if (gameScoresCollection[i].gameId == 99 && gameScoresCollection[i].longestStreak >= challengeAdvanceStreak) { // TODO: is challenge game and user beat it
                        challengesPassed ++;
                    }
                }
            }
        }
        return challengesPassed >= MemoryMatch.GameSetup.levels.length;
    },

    calculateLevelAccuracy: function () {
        var accuracy = 0,
            possibleMatches;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            if (MemoryMatch.gameType == MemoryMatch.GAMEPLAYTYPE.HAYSTACK) {
                accuracy = Math.floor((1 - (MemoryMatch.missCount / MemoryMatch.levelTolerance)) * 100);
            } else {
                possibleMatches = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                accuracy = Math.floor((possibleMatches / (MemoryMatch.matchCount + MemoryMatch.missCount)) * 100);
            }
        }
        return accuracy;
    },

    starsEarnedInCurrentGame: function () {
        // Determine the number of stars earned in the game just played based on parameters of that game type
        var starsEarned = 0,
            possibleMatches = 0,
            accuracy,
            gameLevel = MemoryMatch.gameNumber;

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            switch (MemoryMatch.gameType) {
                case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
                case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                    accuracy = MemoryMatch.calculateLevelAccuracy();
                    possibleMatches = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                    if (possibleMatches < 7) {
                        if (accuracy >= 54) {
                            starsEarned = 3;
                        } else if (accuracy > 44) {
                            starsEarned = 2;
                        } else {
                            starsEarned = 1;
                        }
                    } else {
                        if (accuracy > 49) {
                            starsEarned = 3;
                        } else if (accuracy > 34) {
                            starsEarned = 2;
                        } else {
                            starsEarned = 1;
                        }
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                    possibleMatches = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                    if (MemoryMatch.missCount < 1) {
                        starsEarned = 3;
                    } else if (possibleMatches > 4 && MemoryMatch.missCount < 2) {
                        starsEarned = 3;
                    } else if (possibleMatches > 5 && MemoryMatch.missCount < 4) {
                        starsEarned = 2;
                    } else if (possibleMatches > 4 && MemoryMatch.missCount < 3) {
                        starsEarned = 2;
                    } else if (possibleMatches > 3 && MemoryMatch.missCount < 2) {
                        starsEarned = 2;
                    } else {
                        starsEarned = 1;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                    possibleMatches = MemoryMatch.rows * MemoryMatch.columns;
                    if (possibleMatches > 6) {
                        if (MemoryMatch.missCount < 3) {
                            starsEarned = 3;
                        } else if (MemoryMatch.missCount < 4) {
                            starsEarned = 2;
                        } else {
                            starsEarned = 1;
                        }
                    } else if (possibleMatches > 4) {
                        if (MemoryMatch.missCount < 2) {
                            starsEarned = 3;
                        } else if (MemoryMatch.missCount < 3) {
                            starsEarned = 2;
                        } else {
                            starsEarned = 1;
                        }
                    } else {
                        if (MemoryMatch.missCount < 1) {
                            starsEarned = 3;
                        } else if (MemoryMatch.missCount < 2) {
                            starsEarned = 2;
                        } else {
                            starsEarned = 1;
                        }
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                case MemoryMatch.GAMEPLAYTYPE.MONTE:
                    if (gameLevel > 9) {
                        starsEarned = 3;
                    } else if (gameLevel > 5) {
                        starsEarned = 2;
                    } else if (gameLevel > 3) {
                        starsEarned = 1;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.SIMON:
                    gameLevel --;
                    if (gameLevel > 15) {
                        starsEarned = 3;
                    } else if (gameLevel > 9) {
                        starsEarned = 2;
                    } else if (gameLevel > 3) {
                        starsEarned = 1;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                    if (gameLevel > 10) {
                        starsEarned = 3;
                    } else if (gameLevel > 5) {
                        starsEarned = 2;
                    } else {
                        starsEarned = 1;
                    }
                    break;
                default:
                    break;
            }
        }
        return starsEarned;
    },


    hiFiveEarnedInCurrentGame: function () {
        // Determine a encouragement message for the game just played
        var message = '',
            possibleMatches,
            accuracy,
            gameLevel = MemoryMatch.gameNumber,
            wordsOfEncouragement = ['Amazing', 'Spectacular', 'Awesome', 'Sensational', 'Impressive', 'Inspiring', 'Magnificent', 'Wonderful'],
            sampleWord = wordsOfEncouragement[Math.floor(Math.random() * wordsOfEncouragement.length)];

        if (MemoryMatch.isChallengeGame || MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            switch (MemoryMatch.gameType) {
                case MemoryMatch.GAMEPLAYTYPE.CONCENTRATION:
                case MemoryMatch.GAMEPLAYTYPE.NEMESIS:
                    accuracy = MemoryMatch.calculateLevelAccuracy();
                    if (accuracy > 49) {
                        message = sampleWord;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.CHAINS:
                    possibleMatches = (MemoryMatch.rows * MemoryMatch.columns) * 0.5;
                    if (MemoryMatch.missCount < 1) {
                        message = 'Perfect!';
                    } else if (possibleMatches > 3 && MemoryMatch.missCount < 2) {
                        message = sampleWord;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.HAYSTACK:
                    possibleMatches = MemoryMatch.rows * MemoryMatch.columns;
                    if (possibleMatches > 4) {
                        if (MemoryMatch.missCount < 2) {
                            message = sampleWord;
                        }
                    } else {
                        if (MemoryMatch.missCount < 1) {
                            message = 'Perfect!';
                        }
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.EYESPY:
                case MemoryMatch.GAMEPLAYTYPE.MONTE:
                    if (gameLevel > 7) {
                        message = sampleWord;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.SIMON:
                    gameLevel --;
                    if (gameLevel > 8) {
                        message = sampleWord;
                    }
                    break;
                case MemoryMatch.GAMEPLAYTYPE.PATTERN:
                    if (gameLevel > 6) {
                        message = sampleWord;
                    }
                    break;
                default:
                    break;
            }
        }
        return message;
    },

    showInfoMessage: function (parameters) {
        var standardParameters = {x: 0, y: 0, width: 900, height: 270, title: '', message: '', icon: 'iconCards', points: null, sound: '', callback: null},
            pointsText;

        if (parameters != null) {
            if (parameters.title != null) {
                standardParameters.title = parameters.title;
            }
            if (parameters.message != null) {
                standardParameters.message = parameters.message;
            }
            if (parameters.points != null) {
                if (parameters.points > 0) {
                    pointsText = "+" + parameters.points.toString();
                } else if (parameters.points < 0) {
                    pointsText = parameters.points.toString();
                }
                standardParameters.points = pointsText;
                MemoryMatch.updateScoreDisplay(parameters.points);
            }
            if (parameters.x != null) {
                standardParameters.x = parameters.x;
            } else {
                standardParameters.x = MemoryMatch.stageWidth * 0.8;
            }
            if (parameters.y != null) {
                standardParameters.y = parameters.y;
            } else {
                standardParameters.y = MemoryMatch.stageHeight * 0.9;
            }
            if (parameters.sound != null) {
                standardParameters.sound = parameters.sound;
            }
            if (parameters.callback != null) {
                standardParameters.callback = parameters.callback;
            }
            MemoryMatch.achievementDisplayQueue.push(standardParameters);
        }
    },

    achievementEarned: function (achievementId) {
        // call this to determine if the achievement is earned and initiate the GUI effects
        // Achievements are queued so we can handle multiple achievements earned at the same time
        var earned = false,
            alreadyEarned = MemoryMatch.didUserEarnAchievement(achievementId);

        if ( ! alreadyEarned) {
            earned = MemoryMatch.UserData.setUserAchievement(achievementId);
            if (earned) {
                MemoryMatch.UserData.flush();
            }
            MemoryMatch.achievementDisplayQueue.push(achievementId);
        }
        return ! alreadyEarned;
    },

    didUserEarnAchievement: function (achievementId) {
        return MemoryMatch.UserData.isUserAchievementSet(achievementId);
    },

    getUserAchievements: function () {
        return MemoryMatch.UserData.getUserAchievements();
    },

    processAchievementQueue: function () {
        var now,
            id,
            objectType,
            achievementInfo;
//        var objectToDisplay;

        if (MemoryMatch.achievementDisplayQueue.length > 0) {
            now = Date.now();
            if ((now - MemoryMatch.achievementDisplayTime) > 2000) {
                MemoryMatch.achievementDisplayTime = now;
                id = MemoryMatch.achievementDisplayQueue.splice(0, 1)[0];
                objectType = Object.prototype.toString.call(id); // is it an Array or is it a Number?
                if (objectType.indexOf('Number') >= 0) { // just Achievement Id, make a AchievementItem and show it
//                    objectToDisplay = new MemoryMatch.AchievementItem(MemoryMatch.stage, {achievementId: id, autoClose: true, icon: 'metal', sound: 'soundBonus', callback: null});
//                    if (objectToDisplay != null) {
//                        objectToDisplay.playSound();
//                    }
                    // get title
                    achievementInfo = MemoryMatch.getAchievementInfo(id);
                    if (achievementInfo != null) {
                        MemoryMatch.showMessageBalloon("metal", achievementInfo.name, null, MemoryMatch.stageWidth * 0.5, MemoryMatch.stageHeight * 0.96);
                        MemoryMatch.triggerSoundFx('soundAchievement', {delay: 350});
                    }
                } else { // Just show the message at location indicated
                    MemoryMatch.showMessageBalloon(null, id.title, id.points, id.x, id.y);
                    if (id.sound != null) {
                        MemoryMatch.triggerSoundFx(id.sound, {delay: 100});
                    }
                }
            }
        }
    },

    onEnterFrame: function (event) {
        var deltaTime = createjs.Ticker.getInterval();
        this.AnimationHandler.onEnterFrame(event, deltaTime);
        if ( ! this.gamePaused) {
            this.updateGameTimers();
        }
        this.processAchievementQueue();
        this.stage.update(event); // TODO: to improve performance, try not to call stage.update()
        this.stageUpdated = false;
    },

    //====================================================================================
    //
    // the following functions are our typical game helper functions generic to all games
    // TODO: Consider moving all these methods to a Util object
    //
    //====================================================================================

    debugLog: function (message) {
        var logMessage = [],
            i,
            numberOfArgs = arguments.length;

        if (numberOfArgs > 1) {
            logMessage.push(message);
            for (i = 1; i < numberOfArgs; i ++) {
                logMessage.push(arguments[i]);
            }
            message = logMessage.join(' ');
        }
        if (MemoryMatch.debugMode && MemoryMatch.messageField != null) {
            MemoryMatch.messageField.text = message;
        }
        if (MemoryMatch.debugMode) {
            try {
                console.log(message);
            } catch (e) {
                // no way to handle a failed console log?
            }
        }
    },

    hasHTML5LocalStorage: function () {
        // Determine if this device supports local storage
        var hasSupport = false;
        try {
            hasSupport = 'localStorage' in window && window['localStorage'] !== null;
        } catch (e) {
            hasSupport = false;
        }
        return hasSupport;
    },

    isValidEmail: function (email) {
        var re = /\S+@\S+\.\S+/;
        return re.test(email);
    },

    isAppBookmarked: function () {
        var isBookmarked = ("standalone" in window.navigator) && window.navigator.standalone;
        return isBookmarked;
    },

    isDeviceiOS: function () {
        return ['iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) >= 0;
    },

    getVendorPrefix: function () {

        // Return a prefix for the browser we are currently running on based on the document.hidden property being available.

        var prefixes = ['moz', 'ms', 'o', 'webkit'],
            i,
            testPrefix,
            result = null;

        if ( ! 'hidden' in document) {
            // Loop through all the possible prefixes we know to check
            for (i = 0; i < prefixes.length; i++) {
                testPrefix = prefixes[i] + 'Hidden';
                if (testPrefix in document) {
                    result = prefixes[i];
                    break;
                }
            }
        }
        return result;
    },

    isDocumentHidden: function () {
        var hiddenProperty,
            vendorPrefix = MemoryMatch.getVendorPrefix();

        if (vendorPrefix != null) {
            hiddenProperty = vendorPrefix + 'Hidden';
        } else {
            hiddenProperty = 'hidden';
        }
        return document[hiddenProperty];
    },

    getVisibilityChangeEvent: function () {
        var visibilityChangeEvent,
            vendorPrefix = MemoryMatch.getVendorPrefix();

        if (vendorPrefix != null) {
            visibilityChangeEvent = vendorPrefix + 'visibilitychange';
        } else {
            visibilityChangeEvent = 'visibilitychange';
        }
        return visibilityChangeEvent;
    },

    saveObjectWithKey: function (key, object) {
        // save object is local storage
        if (MemoryMatch.hasHTML5LocalStorage() && key != null && object != null) {
            window.localStorage[key] = JSON.stringify(object);
        }
    },

    loadObjectWithKey: function (key) {
        // save object is local storage
        var jsonData,
            object = null;

        if (MemoryMatch.hasHTML5LocalStorage() && key != null) {
            jsonData = window.localStorage[key];
            if (jsonData != null) {
                object = JSON.parse(jsonData);
            }
        }
        return object;
    },

    getGameKey: function (key) {
        var result = MemoryMatch.GameSetup.clientId + "." + MemoryMatch.GameSetup.gameName;
        if (key != null) {
            result += "." + key;
        }
        return result;
    },

    getAchievementInfo: function (achievementId) {
        var achievements = MemoryMatch.GameSetup.achievements,
            achievementInfo = null,
            itemFound = false,
            i;

        for (i = 0; i < achievements.length; i ++ ) {
            achievementInfo = achievements[i];
            if (achievementInfo.id == achievementId) {
                itemFound = true;
                break;
            }
            achievementInfo = null;
        }
        return achievementInfo;
    },

    getRandomNumberBetween: function (bottom, top) {
        return Math.floor(Math.random() * (1 + top - bottom)) + bottom;
    },

    getRandomNumberBetweenButNot: function (bottom, top, notThisOne) {
        var newValue = notThisOne,
            tryCounter = 0;

        while (notThisOne == newValue && tryCounter < 50) {
            newValue = MemoryMatch.getRandomNumberBetween(bottom, top);
            tryCounter ++;
        }
        return newValue;
    },

    /**
     * @description Replace key:value pairs into a string. This provides a template-like formatting using {key} string replacement.
     * @method tokenReplace
     * @param {sourceString} string that contains %TOKEN% to be replaced if matched by a params object key.
     * @param {Object} The replacement object, which contains <pre>{KEY1:"value", KEY2: "value", ...}</pre> properties.
     * @return {String} A string with all replaced string values. Note that values defined in the source string
     * that are not found in the replacement object will remain with %TOKEN%.
     **/
    tokenReplace: function(sourceString, params) {
        var key,
            result = sourceString;

        for (key in params) {
            if (params.hasOwnProperty(key)) {
                result = result.replace(new RegExp("%" + key + "%", "ig"), params[key]);
            }
        }
        return result;
    },

    replaceChar: function (str, char) {
        // this should be a String extension
        // String.prototype.replaceChar
        var pos = str.indexOf(char);
        if (pos > 0) {
            return str.substr(0, pos) + str.substr(pos + 1);
        } else if (pos == 0) {
            return str.substr(1);
        } else {
            return str;
        }
    },

    formatTimeAsString: function (sourceTimeInMilliseconds, showLeadingMinutes, showLeadingHours) {
        // return time in format sss, mm:ss, or h:mm:ss
        var seconds,
            minutes,
            hours,
            timeAsString = '';

        if (sourceTimeInMilliseconds == null) {
            sourceTimeInMilliseconds = 0;
        }
        if (showLeadingMinutes == null) {
            showLeadingMinutes = false;
        }
        if (showLeadingHours == null) {
            showLeadingHours = false;
        }
        if (sourceTimeInMilliseconds > 1000) {
            seconds = Math.floor(sourceTimeInMilliseconds / 1000) % 60;
        } else {
            seconds = 0;
        }
        if (sourceTimeInMilliseconds > 60000) {
            minutes = Math.floor(sourceTimeInMilliseconds / 60000) % 60;
        } else {
            minutes = 0;
        }
        if (sourceTimeInMilliseconds > 3600000) {
            hours = Math.floor(sourceTimeInMilliseconds / 3600000);
        } else {
            hours = 0;
        }
        if (hours > 0 || showLeadingHours) {
            timeAsString = hours.toString() + ":";
        }
        if (minutes > 0 || timeAsString.length > 0 || showLeadingMinutes) {
            if ((timeAsString.length > 0 && minutes < 10) && ! (showLeadingMinutes && minutes == 0)) {
                timeAsString += "0";
            }
            timeAsString += minutes.toString() + ":";
        }
        if (seconds > 0 || timeAsString.length > 0) {
            if (timeAsString.length > 0 && seconds < 10) {
                timeAsString += "0";
            }
            timeAsString += seconds.toString();
        }
        return timeAsString;
    },

    formatNumberWithGroups: function (value) {
        var valueAsString = value.toString(),
            isNegative = value < 0,
            i;

        // Add commas to 3-digit groups
        if (isNegative) {
            valueAsString = valueAsString.substring(1, valueAsString.length);
        }
        if (valueAsString.length > 3) {
            for (i = valueAsString.length - 3; i >= 1; i -= 3) {
                valueAsString = valueAsString.substring(0, i) + "," + valueAsString.substring(i, valueAsString.length);
            }
        }
        if (isNegative) {
            valueAsString = '-' + valueAsString;
        }
        return valueAsString;
    },

    htmlColorStringToColorArray: function (htmlColorValue) {
        var hexCharacters = "0123456789ABCDEF",
            result = [0, 0, 0],
            i,
            colorIndex = 0;

        if (htmlColorValue.charAt(0) == "#") {
            htmlColorValue = htmlColorValue.slice(1);
        }
        htmlColorValue = htmlColorValue.toUpperCase();
        if (htmlColorValue.length == 3) {
            for (i = 0; i < 3; i ++) {
                result[colorIndex ++] = hexCharacters.indexOf(htmlColorValue.charAt(i));
            }
        } else if (htmlColorValue.length == 6) {
            for (i = 0; i < 6; i += 2) {
                result[colorIndex ++] = (hexCharacters.indexOf(htmlColorValue.charAt(i)) * 16) + hexCharacters.indexOf(htmlColorValue.charAt(i + 1));
            }
        }
        return result;
    },

    queryStringToObject: function (queryString) {
        // convert a string "token=value&token=value..." into a key/value array
        // Will skip over anything before the first ? if it is found in the string

        var i,
            numberOfParts,
            keyValuePair,
            propertyObject = {},
            parts = queryString.replace(/.*?[\?]/, "");

        parts = parts.split('&');
        numberOfParts = parts.length;
        for (i = 0; i < numberOfParts; i ++) {
            if (parts[i] !== null && parts[i].length > 0) {
                keyValuePair = parts[i].split('=');
                propertyObject[decodeURIComponent(keyValuePair[0])] = decodeURIComponent(keyValuePair[1]);
            }
        }
        return propertyObject;
    },

    getQueryStringValue: function (key) {
        var queryDict = {},
            value = null;

        location.search.substr(1).split("&").forEach(function(item) {
            var itemValue = item.split("=");
            queryDict[itemValue[0]] = itemValue[1];
        });
        if (queryDict[key] != null) {
            value = queryDict[key];
        }
        return value;
    },

    setPlatform: function () {
        MemoryMatch.platform = navigator.platform;
        MemoryMatch.locale = navigator.language;
        if (Modernizr != null && Modernizr.touch != null) {
            MemoryMatch.isTouchDevice = Modernizr.touch;
        } else {
            MemoryMatch.isTouchDevice = false;
        }
    },

    getSpriteFrameSize: function (spriteSheet, spriteFrame) {
        var spriteWidth = 0,
            spriteHeight = 0;

        if (spriteSheet !== null && spriteSheet.frames !== null && spriteFrame !== null && spriteFrame.length > 0) {
            if (spriteSheet.animations[spriteFrame] == null) {
                MemoryMatch.debugLog("getSpriteFrameSize: No spritesheet data for " + spriteFrame);
            } else {
                spriteWidth = spriteSheet.frames[spriteSheet.animations[spriteFrame][0]][2];
                spriteHeight = spriteSheet.frames[spriteSheet.animations[spriteFrame][0]][3];
            }
        }
        return {width: spriteWidth, height: spriteHeight};
    },

    getSpriteFrameWidth: function (spriteSheet, spriteFrame) {
        var spriteWidth = 0;

        if (spriteSheet !== null && spriteSheet.frames !== null && spriteFrame !== null && spriteFrame.length > 0) {
            if (spriteSheet.animations[spriteFrame] == null) {
                MemoryMatch.debugLog("getSpriteFrameWidth: No spritesheet data for " + spriteFrame);
            } else {
                spriteWidth = spriteSheet.frames[spriteSheet.animations[spriteFrame][0]][2];
            }
        }
        return spriteWidth;
    },

    getSpriteFrameHeight: function (spriteSheet, spriteFrame) {
        var spriteHeight = 0;

        if (spriteSheet !== null && spriteSheet.frames !== null && spriteFrame !== null && spriteFrame.length > 0) {
            if (spriteSheet.animations[spriteFrame] == null) {
                MemoryMatch.debugLog("getSpriteFrameHeight: No spritesheet data for " + spriteFrame);
            } else {
                spriteHeight = spriteSheet.frames[spriteSheet.animations[spriteFrame][0]][3];
            }
        }
        return spriteHeight;
    },

    makeBezierPointArray: function (startPoint, controlPoint, endPoint, numberOfPoints) {
        // Build an array of points following a Bezier curve
        // b = ((1-t)*(1-t)) * p0 + 2*(1-t)*t*p1 + (t*t)*p2 where t ranges from 0 to 1.

        var arrayOfPointsOnTheCurve = [],
            t, t1, t1s, ts, tt12,
            cx,
            cy,
            last,
            prev,
//            angle,
            tIncrement = 1 / numberOfPoints;

        t = 0;
        while (t <= 1) {
            t1 = 1 - t;
            t1s = t1 * t1;
            ts = t * t;
            tt12 = 2 * t * t1;
            cx = t1s * startPoint.x + tt12 * controlPoint.x + ts * endPoint.x;
            cy = t1s * startPoint.y + tt12 * controlPoint.y + ts * endPoint.y;
            arrayOfPointsOnTheCurve.push({x: cx, y: cy});
            t += tIncrement;
        }
        last = arrayOfPointsOnTheCurve.length - 1;
        prev = arrayOfPointsOnTheCurve.length - 2;
//        angle = Math.atan2(arrayOfPointsOnTheCurve[last].y - arrayOfPointsOnTheCurve[prev].y, arrayOfPointsOnTheCurve[last].x - arrayOfPointsOnTheCurve[prev].x);
        return arrayOfPointsOnTheCurve;
    },

    getMidpointBetween: function (objectA, objectB) {
        return {x: objectA.x + Math.round((objectB.x - objectA.x) * 0.5), y: objectA.y + Math.round((objectB.y - objectA.y) * 0.5)};
    },

    //====================================================================================
    //
    // makeCard returns an object-like card entity to handle all properties and methods
    // of our cards. A card is a createjs.Container.
    //
    //====================================================================================

    makeCard: function (cardNumber, cardValue, spriteData) {
        var cardMatchCounterPositionIndex = MemoryMatch.GameSetup.cardMatchCounterPosition,
            cardMatchCounterPosition,
            cardHighlight,
            cardBackSprite,
            cardFrontSprite,
            cardMatchCounter,
            cardMatchCounterBg,
            cardMatchCounterBgSize,
            cardMatchColor,
            guiSpriteFrames = MemoryMatch.GameSetup.guiSpritesheet1Frames,
            guiSpriteData = new createjs.SpriteSheet(guiSpriteFrames),
            cardBorderWidth = MemoryMatch.cardMargin * 2.0,
            card = new createjs.Container();

        card.SPRITEINDEX = {
            SPRITE_HIGHLIGHT:    0,
            SPRITE_CARDBACK:     1,
            SPRITE_MATCHBG:      2,
            SPRITE_MATCHCOUNTER: 3,
            SPRITE_CARDFACE:     4,
            SPRITE_SPECIALFX:    5
        };

        // layer 0 is the card highlight to indicate the card is selected
        cardHighlight = card.addChild(new createjs.Shape());
        cardHighlight.graphics.beginFill("#FF0").drawRoundRect(MemoryMatch.cardMargin * -1.0, MemoryMatch.cardMargin * -1.0, MemoryMatch.cardWidth + cardBorderWidth, MemoryMatch.cardHeight + cardBorderWidth, 8);
        cardHighlight.alpha = 0.0;
        cardHighlight.visible = false;

        // layer 1 is the card back
        cardBackSprite = new createjs.Sprite(spriteData, 0);
        card.addChild(cardBackSprite);
        cardBackSprite.gotoAndStop(0);
        cardBackSprite.visible = false;

        // layer 2 & 3 is the card match counter
        cardMatchCounterBg = new createjs.Sprite(guiSpriteData, 'cardCounter');
        card.addChild(cardMatchCounterBg);
        cardMatchCounterBg.visible = false;
        cardMatchCounterBgSize = MemoryMatch.getSpriteFrameSize(guiSpriteFrames, 'cardCounter');

        cardMatchColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (cardMatchColor == null) {
            cardMatchColor = MemoryMatch.GameSetup.cardMatchCounterColor;
        }
        if (cardMatchColor == null) {
            cardMatchColor = '#00FF00';
        }
        cardMatchCounter = new createjs.Text("", MemoryMatch.getScaledFontSize(MemoryMatch.GameSetup.cardMatchCounterSize) + " " + MemoryMatch.GameSetup.cardMatchCounterFont, cardMatchColor);
        cardMatchCounter.textAlign = 'center';
        if (cardMatchCounterPositionIndex === null) {
            cardMatchCounterPositionIndex = 4;
        }
        switch (cardMatchCounterPositionIndex) {
            case 1: // top-left
                cardMatchCounterPosition = {x: MemoryMatch.cardHeight * 0.16, y: MemoryMatch.cardHeight * 0.28};
                cardMatchCounter.textAlign = "left";
                cardMatchCounterBg.setTransform(0, 0, 1, 1, 0, 0, 0, 0, 0);
                break;
            case 2: // top-right
                cardMatchCounterPosition = {x: MemoryMatch.cardHeight * 0.84, y: MemoryMatch.cardHeight * 0.28};
                cardMatchCounter.textAlign = "right";
                cardMatchCounterBg.setTransform(MemoryMatch.cardWidth, 0, 1, 1, 0, 0, 0, cardMatchCounterBgSize.width, 0);
                break;
            case 4: // bottom-left
                cardMatchCounterPosition = {x: MemoryMatch.cardHeight * 0.16, y: MemoryMatch.cardHeight * 0.72};
                cardMatchCounter.textAlign = "left";
                cardMatchCounterBg.setTransform(0, MemoryMatch.cardHeight, 1, 1, 0, 0, 0, 0, cardMatchCounterBgSize.height);
                break;
            case 3: // bottom-right
            default:
                cardMatchCounterPosition = {x: MemoryMatch.cardHeight * 0.84, y: MemoryMatch.cardHeight * 0.72};
                cardMatchCounter.textAlign = "right";
                cardMatchCounterBg.setTransform(MemoryMatch.cardWidth, MemoryMatch.cardHeight, 1, 1, 0, 0, 0, cardMatchCounterBgSize.width, cardMatchCounterBgSize.height);
                break;
        }
        cardMatchCounter.x = cardMatchCounterPosition.x; // Place counter in lower right corner of card
        cardMatchCounter.y = cardMatchCounterPosition.y;
        cardMatchCounter.maxWidth = 86 * MemoryMatch.stageScaleFactor; // allow 2 digits at scale
        card.addChild(cardMatchCounter);
        cardMatchCounter.visible = false;

        // layer 4 is the card face
        cardFrontSprite = new createjs.Sprite(spriteData, 0);
        card.addChild(cardFrontSprite);
        cardFrontSprite.gotoAndStop(cardValue);
        cardFrontSprite.visible = false;

        card.bounds = new createjs.Rectangle(MemoryMatch.cardMargin * -1.0, MemoryMatch.cardMargin * -1.0, MemoryMatch.cardWidth + cardBorderWidth, MemoryMatch.cardHeight + cardBorderWidth);
        card.cardNum = cardNumber;
        card.name = "Card" + cardValue;
        card.value = cardValue;
        card.isSelected = false;
        card.isEnabled = true;    // Allow cards to be non-interactive
        card.seenCount = 0;
        card.restoreFlag = false; // indicates a card flip state was saved to be later restored
        card.isPattern = false;  // for Pattern Match game
        card.sequenceNumber = 0; // for Simon game
        card.state = MemoryMatch.CARDSTATE.NOTREADY; // trace the state of the card: 0=Down, 1=Up, 2=Removed, 9=not ready
        card.matchCounter = 0;
        card.cardSelectedHandler = null;
        card.on("click", MemoryMatch.onCardClicked, MemoryMatch);
        card.on("rollover", this.onCardHighlight, this);
        card.on("rollout", this.onCardUnhighlight, this);
        card.cursor = "pointer";
        card.regX = (MemoryMatch.cardWidth + cardBorderWidth) * 0.5;
        card.regY = (MemoryMatch.cardHeight + cardBorderWidth) * 0.5;
        card.cache(card.bounds.x, card.bounds.y, card.bounds.width, card.bounds.height, 1);

        card.setValue = function (cardValue) {
            // reset this card to the requested value
            var cardFace = this.getChildAt(this.SPRITEINDEX.SPRITE_CARDFACE);
            this.value = cardValue;
            cardFace.gotoAndStop(cardValue);
            this.updateCache();
        }

        card.kill = function () {
            card.removeAllChildren();
            guiSpriteFrames = null;
            guiSpriteData = null;
        }

        card.toggleFace = function () {
            var cardBack = this.getChildAt(this.SPRITEINDEX.SPRITE_CARDBACK),
                cardFace = this.getChildAt(this.SPRITEINDEX.SPRITE_CARDFACE),
                showingMatchCounter = false;

            if (cardBack.visible && ! cardFace.visible) {
                cardBack.visible = false;
                cardFace.visible = true;
            } else {
                cardBack.visible = true;
                cardFace.visible = false;
                if (this.matchCount > 0) {
                    showingMatchCounter = true;
                }
            }
            this.showMatchCounter(showingMatchCounter);
            this.updateCache();
        }

        card.highlight = function () {
            var cardHighlight;

            if (this.isEnabled &&  ! this.isSelected) {
                cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT);
                cardHighlight.alpha = 0.5;
                this.updateCache();
            }
        }

        card.unhighlight = function () {
            var cardHighlight;

            if (this.isEnabled && ! this.isSelected) {
                cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT);
                cardHighlight.alpha = 0.0;
                this.updateCache();
            }
        }

        card.preSelect = function () {
            var cardHighlight;

            if ( ! this.isSelected) {
                cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT);
                cardHighlight.alpha = 0.8;
                this.updateCache();
            }
        }

        card.select = function () {
            var cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT);
            cardHighlight.alpha = 0.8;
            this.isSelected = true;
            this.flip();
            this.updateCache();
        }

        card.specialSelect = function (cardSelectType, showHighlight) {
            var centerX = MemoryMatch.cardWidth * 0.5,
                centerY = MemoryMatch.cardHeight * 0.5,
                cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT),
                shapeFx,
                cardAnimator;

            if (showHighlight) {
                this.isSelected = true;
                cardHighlight.alpha = 0.8;
            }
            if (cardSelectType == 1) {
                centerX = MemoryMatch.cardWidth * 0.5;
                centerY = MemoryMatch.cardHeight * 0.5;
                shapeFx = this.addChild(new createjs.Shape()); // TODO: Must be at layer SPRITEINDEX.SPRITE_SPECIALFX
                shapeFx.graphics.setStrokeStyle(4, "round").beginStroke("#FFFFFF").drawCircle(0, 0, 5).drawCircle(0, 0, 10);
                shapeFx.setTransform(centerX, centerY, 1, 1);
                shapeFx.alpha = 0.6;
                shapeFx.mask = cardHighlight;
                cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this, 0, 0, false, null, null);
                cardAnimator.tickFunction = this.updateSelect;
            }
            if (showHighlight || cardSelectType == 1) {
                this.updateCache();
            }
        }

        card.updateSelect = function (cardAnimator) {
            var keepAnimating = true,
                shapeFx,
                newScale,
                newAlpha,
                card = cardAnimator.actor;

            if (card != null) {
                shapeFx = card.getChildAt(card.SPRITEINDEX.SPRITE_SPECIALFX);
                if (shapeFx != null) {
                    newScale = shapeFx.scaleX * 1.3;
                    shapeFx.scaleX = newScale;
                    shapeFx.scaleY = newScale;
                    newAlpha = shapeFx.alpha * 0.91;
                    shapeFx.alpha = newAlpha;
                    if (newAlpha < 0.05) {
                        keepAnimating = false;
                        card.removeChildAt(card.SPRITEINDEX.SPRITE_SPECIALFX);
                    }
                }
                card.updateCache();
            }
            return keepAnimating;
        }

        card.flip = function () {
            // begin card flip animation
            var cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this, 0, 0, false, null, this.flipAnimationPhaseTwo);
            if (cardAnimator != null) {
                cardAnimator.vYSkew = MemoryMatch.cardFlipSpeed;
                cardAnimator.endYSkew = 90;
            }
            MemoryMatch.triggerSoundFx("soundCardFlip");
        }

        card.showMatchCounter = function (showFlag) {
            var matchCounter = card.getChildAt(card.SPRITEINDEX.SPRITE_MATCHCOUNTER),
                matchCounterBg = card.getChildAt(card.SPRITEINDEX.SPRITE_MATCHBG);

            if (matchCounter != null && matchCounterBg != null) {
                if (showFlag == null) {
                    showFlag = true;
                }
                matchCounterBg.visible = showFlag;
                matchCounter.visible = showFlag;
            }
        }

        card.flipAnimationPhaseTwo = function (card) {
            var cardAnimator,
                cardImage = card.getChildAt(card.SPRITEINDEX.SPRITE_CARDFACE);

            cardImage.visible = true;
            card.seenCount ++;
            if (card.matchCounter > 0) {
                card.showMatchCounter(false);
            }
            cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(card, 0, 0, false, null, card.flipAnimationComplete);
            if (cardAnimator != null) {
                cardAnimator.vYSkew = -1.0 * MemoryMatch.cardFlipSpeed;
                cardAnimator.endYSkew = 0;
            }
            card.updateCache();
        }

        card.unflipAnimationPhaseTwo = function (card) {
            var cardBack = card.getChildAt(card.SPRITEINDEX.SPRITE_CARDBACK),
                cardImage = card.getChildAt(card.SPRITEINDEX.SPRITE_CARDFACE),
                cardAnimator;

            cardBack.visible = true;
            cardImage.visible = false;
            if (card.matchCounter > 0) {
                card.showMatchCounter(true);
            }
            cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(card, 0, 0, false, null, card.flipAnimationComplete);
            if (cardAnimator != null) {
                cardAnimator.vYSkew = -1.0 * MemoryMatch.cardFlipSpeed;
                cardAnimator.endYSkew = 0;
            }
            card.updateCache();
        }

        card.flipAnimationComplete = function (card) {
            var cardFace = card.getChildAt(card.SPRITEINDEX.SPRITE_CARDFACE);

            card.skewY = 0;
            if (cardFace.visible) {
                card.state = MemoryMatch.CARDSTATE.UP;
            } else {
                card.state = MemoryMatch.CARDSTATE.DOWN;
            }
            card.updateCache();
        }

        card.unselect = function () {
            var cardHighlight = this.getChildAt(card.SPRITEINDEX.SPRITE_HIGHLIGHT);

            this.isSelected = false;
            cardHighlight.alpha = 0.0;
            cardHighlight.scaleX = 1.0;
            cardHighlight.scaleY = 1.0;
            this.updateCache();
        }

        card.flipBack = function () {
            // begin card flip animation
            var cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this, 0, 0, false, null, this.unflipAnimationPhaseTwo);

            this.unselect();
            if (cardAnimator != null) {
                cardAnimator.vYSkew = MemoryMatch.cardFlipSpeed;
                cardAnimator.endYSkew = 90;
            }
        }

        card.showCard = function (cardToShow) {
            var cardBackSprite = cardToShow.actor.getChildAt(card.SPRITEINDEX.SPRITE_CARDBACK);

            MemoryMatch.triggerSoundFx("soundCardDeal");
            cardBackSprite.visible = true;
            cardToShow.actor.showMatchCounter(cardToShow.actor.matchCounter > 0);
            cardToShow.actor.regX = MemoryMatch.cardWidth * 0.5;
            cardToShow.actor.regY = MemoryMatch.cardHeight * 0.5;
            cardToShow.actor.state = MemoryMatch.CARDSTATE.DOWN;
            MemoryMatch.checkBoardIsReadyForPlay();
            cardToShow.actor.updateCache();
        }

        card.showCardDemo = function () {
            var cardBackSprite = this.getChildAt(card.SPRITEINDEX.SPRITE_CARDBACK);

            cardBackSprite.visible = true;
            this.showMatchCounter(this.matchCounter > 0);
            this.regX = MemoryMatch.cardWidth * 0.5;
            this.regY = MemoryMatch.cardHeight * 0.5;
            this.state = MemoryMatch.CARDSTATE.DOWN;
            this.updateCache();
        }

        card.removeCard = function (callMeWhenComplete) {
            var cardAnimator,
                cardHighlight = this.getChildAt(this.SPRITEINDEX.SPRITE_HIGHLIGHT);

            this.isSelected = false;
            this.matchCount = 0;
            this.state = MemoryMatch.CARDSTATE.REMOVED;
            this.cardSelectedHandler = null;
            cardHighlight.alpha = 0.0;
            cardHighlight.scaleX = 1.0;
            cardHighlight.scaleY = 1.0;
            this.updateCache();

            // begin card fade animation
            cardAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this, 500, 0, false, null, callMeWhenComplete);
            if (cardAnimator != null) {
                cardAnimator.vAlpha = -0.05;
                cardAnimator.endAlpha = 0;
            }
        }

        card.setMatchCounter = function (startValue) {
            var matchCounter = this.getChildAt(card.SPRITEINDEX.SPRITE_MATCHCOUNTER),
                showingMatchCounter = false;

            this.matchCounter = startValue;
            if (this.matchCounter > 0) {
                matchCounter.text = this.matchCounter.toString();
                showingMatchCounter = this.state == MemoryMatch.CARDSTATE.DOWN;
            } else {
                matchCounter.text = "";
            }
            this.showMatchCounter(showingMatchCounter);
            this.updateCache();
        }

        card.updateMatchCounter = function () {
            var matchCounter = this.getChildAt(card.SPRITEINDEX.SPRITE_MATCHCOUNTER),
                showingMatchCounter = false;

            if (this.matchCounter > 0) {
                this.matchCounter --;
                if (this.matchCounter > 0) {
                    matchCounter.text = this.matchCounter.toString();
                    showingMatchCounter = true;
                } else {
                    matchCounter.text = "";
                }
            }
            this.showMatchCounter(showingMatchCounter);
            this.updateCache();
        }

        card.toString = function () {
            return "CardNum=" + this.cardNum + "; Name=" + this.name + "; Value=" + this.value + "; State=" + this.state + "; Selected=" + (this.isSelected ? "YES" : "NO") + "; Seen=" + this.seenCount + "; MatchCount=" + this.matchCounter.toString();
        }
        return card;
    },

    //====================================================================================
    //
    // Startup code and HTML5 interface functions
    //
    //====================================================================================

    showOrientationMessage: function (showFlag) {

        // we detected the device is not in the orientation we want, prompt the user to rotate the device

        var backgroundGroup,
            groupName = 'orientationMessage',
            backgroundCover,
            icon,
            iconImageAsset,
            textMessage,
            canvas,
            stageWidth,
            stageHeight,
            backgroundColor;

        backgroundGroup = MemoryMatch.stage.getChildByName(groupName);
        if (showFlag) {
            if (backgroundGroup != null) {
                return;
            }
            canvas = MemoryMatch.stage.canvas;
            stageWidth = canvas.width;
            stageHeight = canvas.height;
            backgroundColor = MemoryMatch.GameSetup.achievementBackgroundColor;

            backgroundGroup = new createjs.Container();
            backgroundGroup.name = groupName;

            backgroundCover = new createjs.Shape();
            backgroundCover.graphics.beginFill(backgroundColor).drawRect(0, 0, stageWidth, stageHeight);
            backgroundCover.alpha = 1;
            backgroundCover.addEventListener("click", this.onClickIgnore);
            backgroundGroup.addChild(backgroundCover);

            textMessage = new createjs.Text(MemoryMatch.GameSetup.GUIStrings.orientationMessage, MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
            textMessage.textAlign = "center";
            textMessage.x = stageWidth * 0.5;
            textMessage.y = stageHeight * 0.5;
            textMessage.lineWidth = stageWidth * 0.9;
            textMessage.maxWidth = stageWidth * 0.9;
            textMessage.lineHeight = textMessage.getMeasuredLineHeight() * 1.5;
            backgroundGroup.addChild(textMessage);

            iconImageAsset = MemoryMatch.assetLoader.getResult("orientationIcon");
            icon = new createjs.Bitmap(iconImageAsset);
            icon.setTransform(stageWidth * 0.5, (stageHeight - iconImageAsset.height) * 0.5, 1, 1, 0, 0, 0, iconImageAsset.width * 0.5, iconImageAsset.height * 0.5);
            backgroundGroup.addChild(icon);

            MemoryMatch.stage.addChild(backgroundGroup);
        } else {
            if (backgroundGroup != null) {
                backgroundGroup.removeAllChildren();
                MemoryMatch.stage.removeChild(backgroundGroup);
            }
        }
    },

    onClickIgnore: function (event) {
    },

    stageSizeChanged: function (event) {
        // if a game is in progress you need to reload the assets and redraw

        var priorAssetPostfix = MemoryMatch.assetFileNamePostfix;

        MemoryMatch.closeAllPopups();
        if (MemoryMatch.gameState != MemoryMatch.GAMESTATE.MENU) {
            MemoryMatch.goToHomeScreen();
        }
        MemoryMatch.setCanvasSize(null);
        if (MemoryMatch.assetFileNamePostfix != priorAssetPostfix) { // Oh-boy! The size changed and our current assets won't fit. Need to reload everything!
            MemoryMatch.AnimationHandler.clearAllParticles();
            MemoryMatch.AnimationHandler.clearAllAnimations();
            MemoryMatch.MainMenu.killScreen();
            MemoryMatch.GameGUI.destroy();
            MemoryMatch.stage.removeAllChildren();
            MemoryMatch.changeGameState(MemoryMatch.GAMESTATE.LOADING);
            MemoryMatch.gamePlayState = MemoryMatch.GAMEPLAYSTATE.IDLE;
            MemoryMatch.showLoader();
            MemoryMatch.loadAllAssets(true);
        } else {
            if (MemoryMatch.isDesiredOrientation()) {
                MemoryMatch.showOrientationMessage(false);
            } else {
                MemoryMatch.showOrientationMessage(true);
            }
        }
    },

    setCanvasSize: function (canvas) {
        // here we are going to set the stage resolution based on our current device display area
        // this game is always landscape orientation. Also important the aspect ratio of every entry must be the same.
        // this logic assumes the game canvas is inside a container <div> and is placed relative to that container
        var supportedResolutions = [
            {width: 2048, height: 1536, scaleFactor: 1, cardScaleFactor: 1, assetPostfix: "100", cardsPostfix: "100"},
            {width: 1024, height: 768, scaleFactor: 0.5, cardScaleFactor: 0.5, assetPostfix: "50", cardsPostfix: "50"},
            {width: 480, height: 360, scaleFactor: 0.24, cardScaleFactor: 0.25, assetPostfix: "24", cardsPostfix: "26"}],
            currentWidth = window.innerWidth,
            currentHeight = window.innerHeight,
            windowAspectRatio = currentWidth / currentHeight,
            resolutionIndex = -1,
            containerDiv = document.getElementById(MemoryMatch.canvasContainerElement), // the container <div>
            i;

        if (canvas == null) {
            canvas = document.getElementById(MemoryMatch.stageCanvasElement);
        }
        // match current stage resolution to the best fit resolution we can support
        for (i = 0; i < supportedResolutions.length; i ++) {
            // compare currentWidth and currentHeight against supportedResolutions[i].width/height within some tolerance (75%)
            // if smaller then try next resolution and scale down
            if (currentWidth >= Math.ceil(supportedResolutions[i].width * 0.6) && currentHeight >= Math.ceil(supportedResolutions[i].height * 0.6)) {
                resolutionIndex = i;
                break;
            }
        }
        if (resolutionIndex == -1) { // if nothing matches then use smallest resolution
            resolutionIndex = supportedResolutions.length - 1;
        }

        // remember what we decided so our graphics placement logic can do the right thing
        MemoryMatch.assetFileNamePostfix = supportedResolutions[resolutionIndex].assetPostfix;
        MemoryMatch.cardsFileNamePostfix = supportedResolutions[resolutionIndex].cardsPostfix;
        MemoryMatch.stageAspectRatio = supportedResolutions[resolutionIndex].width / supportedResolutions[resolutionIndex].height;
        MemoryMatch.stageScaleFactor = supportedResolutions[resolutionIndex].scaleFactor;
        MemoryMatch.cardScaleFactor = supportedResolutions[resolutionIndex].cardScaleFactor;
        MemoryMatch.stageWidth = supportedResolutions[resolutionIndex].width;
        MemoryMatch.stageHeight = supportedResolutions[resolutionIndex].height;
        canvas.width = MemoryMatch.stageWidth;
        canvas.height = MemoryMatch.stageHeight;

        // Now let CSS scale and center the containing <div> based on the the best fit of our game stage relative
        // to the maximum available screen space
        if (windowAspectRatio > MemoryMatch.stageAspectRatio) { // window width is too wide relative to desired game width
            currentWidth = Math.floor(currentHeight * MemoryMatch.stageAspectRatio);
        } else { // window height is too high relative to desired game height
            currentHeight = Math.floor(currentWidth / MemoryMatch.stageAspectRatio);
        }
        containerDiv.style.width = currentWidth + 'px';
        containerDiv.style.height = currentHeight + 'px';
        containerDiv.style.marginTop = (currentHeight * -0.5) + 'px';
        containerDiv.style.marginLeft = (currentWidth * -0.5) + 'px';
        MemoryMatch.cssScaledWidth = currentWidth;
        MemoryMatch.cssScaledHeight = currentHeight;
        MemoryMatch.debugLog("setCanvasSize: Width: " + MemoryMatch.stageWidth + ", Height: " + MemoryMatch.stageHeight +  ", prefix: " + MemoryMatch.assetFileNamePostfix +  ", aspect: " + MemoryMatch.stageAspectRatio +  ", scale: " + MemoryMatch.stageScaleFactor);
    },

    isPortrait: function () {
        return (window.innerWidth / window.innerHeight) < 1.0;
    },

    isLandscape: function () {
        return (window.innerWidth / window.innerHeight) >= 1.0;
    },

    isDesiredOrientation: function () {
        var orientationRequired = MemoryMatch.GameSetup.orientation,
            correctOrientation = false;

        if ( ! MemoryMatch.isTouchDevice) {
            correctOrientation = true;
        } else if (orientationRequired == undefined || orientationRequired == null || orientationRequired == '') {
            correctOrientation = true;
        } else {
            orientationRequired = orientationRequired.toLowerCase();
            correctOrientation = (orientationRequired == 'landscape' && MemoryMatch.isLandscape()) || (orientationRequired == 'portrait' && MemoryMatch.isPortrait());
        }
        return correctOrientation;
    },

    shouldAskUserToBookmarkApp: function () {
        var isAppBookmarked = MemoryMatch.isAppBookmarked(),
            isIosDevice = MemoryMatch.isDeviceiOS(),
            userDataObject = this.UserData.getUserDataObject(),
            askedUserToBookmark = userDataObject['askBookmark'] | 0,
            shouldAsk = false;

        if (isIosDevice && ! isAppBookmarked && askedUserToBookmark < 5) {
            askedUserToBookmark ++;
            userDataObject['askBookmark'] = askedUserToBookmark;
            this.UserData.flush();
            shouldAsk = true;
        }
        return shouldAsk;
    },

    captureDebugInformation: function () {
        var debugData = '',
            canvas = document.getElementById(this.stageCanvasElement);

        debugData += '<div class="debug">';
        debugData += '<p>Stage: (' + MemoryMatch.stageWidth + ',' + MemoryMatch.stageHeight + '); Canvas:  (' + canvas.width + ',' + canvas.height + '); CSS: (' + MemoryMatch.cssScaledWidth + ',' + MemoryMatch.cssScaledHeight + '); Scale factor: ' + MemoryMatch.stageScaleFactor + '; Aspect Ratio: ' + MemoryMatch.stageAspectRatio + '</p>';
        debugData += '<p>CSS scale width: ' + (MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth)) + ', CSS scale height: ' + (MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight)) + '</p>';
        debugData += '</div>';
        return debugData;
    },

    onVisibilityChange: function (event) {
        var isHidden = MemoryMatch.isDocumentHidden();
        MemoryMatch.debugLog("onVisibilityChange: hidden? " + (isHidden ? 'YES' : 'NO'));
        MemoryMatch.onPauseGame(isHidden);
    },

    makeResolutionBasedFileNameFromFileName: function (filename, isCards) {
        // to support more efficient asset loading, we make asset sets based on target resolution, then load
        // the assets needed to support that resolution. This function makes the file name corresponding to the
        // assets we need, to allow the code to reference the asset files independent of target resolution.

        var assetFileNameResolutionPostfix,
            sourceFileNameParts,
            fileExtension,
            newFileName,
            i;

        if (isCards == null) {
            isCards = false;
        }
        if (MemoryMatch.assetFileNamePostfix != "") {
            newFileName = "";
            sourceFileNameParts = filename.split(".");
            fileExtension = sourceFileNameParts[sourceFileNameParts.length - 1];
            if (isCards) {
                assetFileNameResolutionPostfix = '-' + MemoryMatch.cardsFileNamePostfix;
            } else {
                assetFileNameResolutionPostfix = '-' + MemoryMatch.assetFileNamePostfix;
            }
            if (sourceFileNameParts.length > 2) {
                for (i = 0; i < sourceFileNameParts.length - 1; i ++) {
                    newFileName += (i > 0 ? "." : "") + sourceFileNameParts[i];
                }
                newFileName += assetFileNameResolutionPostfix + "." + fileExtension;
            } else if (sourceFileNameParts.length == 2) {
                newFileName = sourceFileNameParts[0] + assetFileNameResolutionPostfix + "." + fileExtension;
            } else {
                newFileName = sourceFileNameParts[0] + assetFileNameResolutionPostfix;
            }
        } else {
            newFileName = filename;
        }
        return newFileName;
    },

    makeResolutionBasedJsonFileFromFileName: function (filename) {
        // following makeResolutionBasedFileNameFromFileName(), make a json file to match the spritesheet

        var assetFileNameResolutionPostfix,
            sourceFileNameParts,
            newFileName,
            i;

        if (MemoryMatch.assetFileNamePostfix != "") {
            newFileName = "";
            sourceFileNameParts = filename.split(".");
            assetFileNameResolutionPostfix = '-' + MemoryMatch.assetFileNamePostfix;
            if (sourceFileNameParts.length > 2) {
                for (i = 0; i < sourceFileNameParts.length - 1; i ++) {
                    newFileName += (i > 0 ? "." : "") + sourceFileNameParts[i];
                }
                newFileName += assetFileNameResolutionPostfix + ".json";
            } else {
                newFileName = sourceFileNameParts[0] + assetFileNameResolutionPostfix + ".json";
            }
        } else {
            newFileName = filename;
        }
        return newFileName;
    },

    getSpriteAssetId: function (cardSetIndex) {
        var cardAssetId;

        if (MemoryMatch.isChallengeGame) {
            cardAssetId = 'cards' + MemoryMatch.challengeGameId.toString() + '-' + cardSetIndex;
        } else {
            cardAssetId = 'cards' + MemoryMatch.gameId.toString() + '-' + cardSetIndex;
        }
        return cardAssetId;
    },

    getCardSize: function (gameData) {
        var cardWidth,
            cardHeight;

        if (gameData.cardWidth == null || gameData.cardWidth < 1) {
            cardWidth = MemoryMatch.GameSetup.cardWidth;
        } else {
            cardWidth = gameData.cardWidth;
        }
        cardWidth = Math.ceil(cardWidth * MemoryMatch.cardScaleFactor);
        if (gameData.cardHeight == null || gameData.cardHeight < 1) {
            cardHeight = MemoryMatch.GameSetup.cardHeight;
        } else {
            cardHeight = gameData.cardHeight;
        }
        cardHeight = Math.ceil(cardHeight * MemoryMatch.cardScaleFactor);
        return {width: cardWidth, height: cardHeight};
    },

    qualifiedFolder: function (folderName) {
        var resultName = '';

        if (folderName != null) {
            if (folderName.substr(folderName.length - 1) != '/') {
                resultName = folderName + '/';
            } else {
                resultName = folderName;
            }
        }
        return resultName;
    },

    getScaledFontSize: function (requestedSizeAt100Percent) {
        return Math.floor(requestedSizeAt100Percent * MemoryMatch.cardScaleFactor) + "px";
    },

    isFullScreenAvailable: function () {
        return window.screenfull !== false;
    },

    goFullScreen: function () {
        if (window.screenfull !== false) {
            window.screenfull.toggle(document.getElementById(MemoryMatch.canvasContainerElement));
        }
    },

    enginesisCallBack: function (enginesisResponse) {
        if (enginesisResponse != null && enginesisResponse.fn != null) {
            switch (enginesisResponse.fn) {
                case "SessionBegin":
                    break;
                default:
                    break;
            }
        }
    },

    loadAllAssets: function (reloadFlag) {

        // assetManifest array defines all the assets we require to load before the game starts.
        // We are loading everything required by the game before we start. This way a user can "deep-link"
        // to any level and we don't have to worry about those assets being ready.
        // Note some assets are based on resolution, which could change.

        var soundAssetName,
            gameLevelIndex,
            gameData,
            imageArray,
            imageIndex,
            assetLoader,
            assetsFolder = MemoryMatch.qualifiedFolder(MemoryMatch.GameSetup.assetsFolder),
            guiSpritesArray,
            i,
            objectType,
            assetManifest = [
                {src:MemoryMatch.makeResolutionBasedFileNameFromFileName(assetsFolder + MemoryMatch.GameSetup.backgroundImage), id:"background"},
                {src:MemoryMatch.makeResolutionBasedFileNameFromFileName(assetsFolder + MemoryMatch.GameSetup.popupBackground), id:"popup-bg"},
                {src:MemoryMatch.makeResolutionBasedFileNameFromFileName(assetsFolder + MemoryMatch.GameSetup.orientationIcon), id:"orientationIcon"},
                {src:assetsFolder + MemoryMatch.GameSetup.particleSprite, id:"particles"}
            ],
            secondaryAssetManifest = [],
            chosenManifest = null;

        guiSpritesArray = MemoryMatch.GameSetup.guiSprites;
        if (guiSpritesArray != null && guiSpritesArray.length > 0) {
            for (i = 0; i < guiSpritesArray.length; i ++) {
                assetManifest.push({src:MemoryMatch.makeResolutionBasedFileNameFromFileName(assetsFolder + guiSpritesArray[i]), id: "guiSprites" + (i + 1)});
                assetManifest.push({src:MemoryMatch.makeResolutionBasedJsonFileFromFileName(assetsFolder + guiSpritesArray[i]), id: "guiSprites" + (i + 1) + "json"});
            }
        }

        // All level based assets are under GameSetup.levels
        for (gameLevelIndex = 0; gameLevelIndex < MemoryMatch.GameSetup.games.length; gameLevelIndex ++) {
            gameData = MemoryMatch.GameSetup.games[gameLevelIndex];
            if (gameData.cardSprites != null) {
                objectType = Object.prototype.toString.call(gameData.cardSprites); // is it an Array or is it a String?
                if (objectType.indexOf('String') >= 0) { // just a single card sprite reference
                    gameData.numberOfCardSets = 1;
                    assetManifest.push({src: "assets/" + MemoryMatch.makeResolutionBasedFileNameFromFileName(gameData.cardSprites, true), id: 'cards' + gameData.gameId.toString() + '-0'});
                } else {
                    gameData.numberOfCardSets = gameData.cardSprites.length;
                    chosenManifest = assetManifest;
                    for (i = 0; i < gameData.numberOfCardSets; i ++) {
                        chosenManifest.push({src: "assets/" + MemoryMatch.makeResolutionBasedFileNameFromFileName(gameData.cardSprites[i], true), id: 'cards' + gameData.gameId.toString() + '-' + i.toString()});
                        // First time through add the asset to load immediately. All remaining assets set to load later.
                        chosenManifest = secondaryAssetManifest;
                    }
                }
            }
            if (gameData.images != null) {

                // If images property exists, it is an array of image objects {image:x, cardSprites: y}.
                // To reference them later, use makeLevelImageAssetName() and makeLevelCardDeckAssetName().
                // We are going to load only the first asset immediately, then all the other assets after the game begins.

                imageArray = gameData.images;
                for (imageIndex = 0; imageIndex < imageArray.length; imageIndex ++) {
                    if (imageArray[imageIndex].image != null && imageArray[imageIndex].image.length > 0) {
                        assetManifest.push({src: assetsFolder + MemoryMatch.makeResolutionBasedFileNameFromFileName(imageArray[imageIndex].image), id: MemoryMatch.makeLevelImageAssetName(gameData.gameId, imageIndex)});
                    }
                    if (imageArray[imageIndex].cardSprites != null && imageArray[imageIndex].cardSprites.length > 0) {
                        assetManifest.push({src: assetsFolder + MemoryMatch.makeResolutionBasedFileNameFromFileName(imageArray[imageIndex].cardSprites, true), id: MemoryMatch.makeLevelCardDeckAssetName(gameData.gameId, imageIndex)});
                    }
                }
            }
        }
        assetLoader = new createjs.LoadQueue(false, '', 'Anonymous');
        if ( ! reloadFlag) { // these assets are not resolution dependent and only need to be loaded once
            // All sounds are located in the structure GameSetup.Sounds
            for (soundAssetName in MemoryMatch.GameSetup.Sounds) {
                if (MemoryMatch.GameSetup.Sounds.hasOwnProperty(soundAssetName)) {
                    assetManifest.push({src: assetsFolder + MemoryMatch.GameSetup.Sounds[soundAssetName], id: soundAssetName});
                }
            }
            assetLoader.installPlugin(createjs.Sound);
            if ( ! createjs.Sound.initializeDefaultPlugins()) {
                MemoryMatch.debugLog("CreateJS.Sound error cannot init");
            }
            if (createjs.Sound.BrowserDetect.isIOS || createjs.Sound.BrowserDetect.isAndroid) {
                MemoryMatch.debugLog("CreateJS.Sound error iOS or Android issues!");
            }
            createjs.Sound.registerPlugins([createjs.HTMLAudioPlugin, createjs.WebAudioPlugin, createjs.FlashPlugin]);
            createjs.Sound.alternateExtensions = ["mp3"];
        }
        MemoryMatch.assetLoader = assetLoader;
        assetLoader.addEventListener("complete", MemoryMatch.allAssetsLoaded.bind(MemoryMatch));
        assetLoader.addEventListener("progress", MemoryMatch.assetLoadProgress);
        assetLoader.addEventListener("error", MemoryMatch.assetLoadError);
        assetLoader.loadManifest(assetManifest);
        assetLoader.setMaxConnections(4);
        if (secondaryAssetManifest.length > 0) {
            MemoryMatch.secondaryAssetManifest = secondaryAssetManifest;
        }
    }
};

function runTests() {
    // Use this method to perform all unit tests

    // return; // tests are off for now.

    var testNum = 0,
        testData,
        a,
        ri,
        i;

    testNum ++;
    testData = MemoryMatch.queryStringToObject('http://www.xyz.com/test.php?test=1&value=2&reg=this+is+a+test&grip=supercalofraga');
    MemoryMatch.debugLog("Test", testNum, "Expect:", '{"test":"1","value":"2","reg":"this+is+a+test","grip":"supercalofraga"}');
    MemoryMatch.debugLog("Test", testNum, "Result:", JSON.stringify(testData));

    testNum ++;
    testData = MemoryMatch.tokenReplace("This is %TEST% on object %OBJ% for real.", {TEST: "a test", OBJ: "my object"});
    MemoryMatch.debugLog("Test", testNum, "Expect:", 'This is a test on object my object for real.');
    MemoryMatch.debugLog("Test", testNum, "Result:", testData);

    testNum ++;
    ri = MemoryMatch.getRandomNumberBetweenButNot(1,3,2);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{%d} number between 1 and 3 but not 2');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);

    testNum ++;
    a = MemoryMatch.shuffleAllCardsUniqueDeck(1, 8, 8);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{%a} array of 8 numbers, no duplicates');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));

    testNum ++;
    a = MemoryMatch.makeMonteDeck(1, 3, 3);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[2,1,2]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    a = MemoryMatch.makeMonteDeck(1, 5, 5);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[2,2,1,2,2]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    a = MemoryMatch.makeMonteDeck(3, 3, 9);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[2,2,2,2,1,2,2,2,2]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));

    testNum ++;
    a = MemoryMatch.makeShuffledBag(150, 1, 4, 3);
    MemoryMatch.debugLog("Test " + testNum + " makeShuffledBag Expect: " + '[array of 150 items 1-4 no more than 3 repeat]');
    MemoryMatch.debugLog("Test " + testNum + " makeShuffledBag Result: " + JSON.stringify(a));

    testNum ++;
    for (i=0; i < 10; i ++) {
        a = MemoryMatch.shuffleUniqueDeck(i, i+12);
        MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{%a} array of 13 numbers, ' + i + '-' + (i+12) + ', no duplicates');
        MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    }

    testNum ++;
    testData = MemoryMatch.makeResolutionBasedFileNameFromFileName("file1.jpg");
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'file1-50.jpg');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    testData = MemoryMatch.makeResolutionBasedFileNameFromFileName("file");
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'file-50');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    testData = MemoryMatch.makeResolutionBasedFileNameFromFileName("file.file.file.png");
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'file.file.file-50.png');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    testData = MemoryMatch.makeResolutionBasedJsonFileFromFileName("file.png");
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'file-50.json');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);

    // Validate our Min/Max logic
    testNum ++;
    i = 0;
    testData = Math.min(i || 1, 10);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '1');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    i = null;
    testData = Math.min(i || 1, 10);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '1');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    i = 7;
    testData = Math.min(i || 1, 10);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '7');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);
    i = 99;
    testData = Math.min(i || 1, 10);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '10');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + testData);

    // Achievements unit tests
    testNum ++;
    MemoryMatch.restoreUsers();
    testData = MemoryMatch.achievementEarned(5);
    i = MemoryMatch.achievementEarned(7);
    ri = MemoryMatch.achievementEarned(19);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[true,true,true]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify([testData,i,ri]));
    testNum ++;
    testData = MemoryMatch.didUserEarnAchievement(5);
    i = MemoryMatch.didUserEarnAchievement(19);
    ri = MemoryMatch.didUserEarnAchievement(20);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[true,true,false]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify([testData,i,ri]));
    testNum ++;
    a = MemoryMatch.getUserAchievements();
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[5,7,19]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));

    testNum ++;
    a = MemoryMatch.getVendorPrefix();
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '<string> or null');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + a);
    a = MemoryMatch.isDocumentHidden();
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'false');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    a = MemoryMatch.getVisibilityChangeEvent();
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'visibilitychange (or vendor prefix)');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + a);

    testNum ++;
    ri = MemoryMatch.getQueryStringValue('level');
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '2');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);

    testNum ++;
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(1);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:1,gameNumber:1}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(7);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:1,gameNumber:99}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(10);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:2,gameNumber:3}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(13);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:2,gameNumber:6}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(14);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:2,gameNumber:99}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(28);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:4,gameNumber:99}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    ri = MemoryMatch.convertLevelNumberToLevelAndGameNumber(78);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '{levelNumber:4,gameNumber:99}');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));

    testNum ++;
    a = MemoryMatch.UserData.setUserTipSeen(3);
    ri = MemoryMatch.UserData.getUserTips();
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + '[false,false,true]');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(ri));
    a = MemoryMatch.UserData.isUserTipSeen(3);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'true');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    a = MemoryMatch.UserData.isUserTipSeen(2);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'false');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));
    a = MemoryMatch.UserData.isUserTipSeen(1);
    MemoryMatch.debugLog("Test " + testNum + " Expect: " + 'false');
    MemoryMatch.debugLog("Test " + testNum + " Result: " + JSON.stringify(a));

    testNum ++;
    ri = MemoryMatch.formatNumberWithGroups(900);
    MemoryMatch.debugLog("Test " + testNum + " Expect: 900");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(-900);
    MemoryMatch.debugLog("Test " + testNum + " Expect: -900");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(900900900900);
    MemoryMatch.debugLog("Test " + testNum + " Expect: 900,900,900,900");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(-900900900900);
    MemoryMatch.debugLog("Test " + testNum + " Expect: -900,900,900,900");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(9009);
    MemoryMatch.debugLog("Test " + testNum + " Expect: 9,009");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(-9009);
    MemoryMatch.debugLog("Test " + testNum + " Expect: -9,009");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(90909);
    MemoryMatch.debugLog("Test " + testNum + " Expect: 90,909");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
    ri = MemoryMatch.formatNumberWithGroups(-90909);
    MemoryMatch.debugLog("Test " + testNum + " Expect: -90,909");
    MemoryMatch.debugLog("Test " + testNum + " Result: " + ri);
};

function onGooglePlusLoaded () {
    if (enginesisSession != null && enginesisSession.ShareHelper != null) {
        enginesisSession.ShareHelper.onGooglePlusLoaded(null);
    }
};

//====================================================================================
// initApp is called from the page load. This is the entry point. When assets are loaded
// we call MemoryMatch.allAssetsLoaded
//====================================================================================
function initApp() {
    MemoryMatch.setPlatform();
    MemoryMatch.debugLog("Loading " + MemoryMatch.GameSetup.gameTitle + " version " + MemoryMatch.GameVersion + " on " + MemoryMatch.platform + " using locale " + MemoryMatch.locale + (MemoryMatch.isTouchDevice ? " / Touch" : " / Mouse"));
    if (document.getElementById(MemoryMatch.loaderElement) != null) {
        // show canvas under loader so we can implement a loadbar until we get everything setup for EaselJS to take over
        document.getElementById(MemoryMatch.loaderElement).style.display = "block";
        document.getElementById(MemoryMatch.stageCanvasElement).style.display = "block";
    }

    // Determine canvas size, it will determine which assets need to be loaded
    MemoryMatch.setCanvasSize(null);
    MemoryMatch.loadAllAssets(false);

//    runTests(); // run unit tests
}

/**
 * AchievementItem.js
 *
 * Build a display object representing an achievement.
 * An achievement item displays an icon, title, description, and points value
 * Construct one of these with a parameters object using this format:
 * {achievementId: 1, width: 300, height: 90, title: 'Title', message: 'Message', icon: 'iconCards', sound: 'soundAsset', borderColor:'#FFFFFF', backgroundColor: '#FFFFFF', callback: function}
 *
 */
// namespace to MemoryMatch
MemoryMatch = MemoryMatch || {};

(function() {

    'use strict';

    var AchievementItem = function(displayObject, parameters) {
        this.setParameters(displayObject, parameters);
        this.buildItem();
    };
    var p = AchievementItem.prototype;

    p.parentDisplayObject = null;
    p.groupDisplayObject = null;
    p.achievementId = null;
    p.x = 0;
    p.y = 0;
    p.width = -1;
    p.height = -1;
    p.marginTop = 0;
    p.marginLeft = 0;
    p.centerX = 0;
    p.marginX = 0;
    p.lineHeight = 0;
    p.title = null;
    p.message = null;
    p.value = null;
    p.icon = null;
    p.sound = null;
    p.borderColor = MemoryMatch.GameSetup.achievementBorderColor;
    p.backgroundColor = MemoryMatch.GameSetup.achievementBackgroundColor;
    p.fontColorEarned = MemoryMatch.GameSetup.achievementFontColorEarned;
    p.fontColorUnearned = MemoryMatch.GameSetup.achievementFontColorUnearned;
    p.autoClose = false;
    p.earned = true;

    p.setParameters = function (displayObject, parameters) {
        var achievementInfo;

        this.parentDisplayObject = displayObject;
        if (parameters !== null) {
            if (parameters.achievementId !== null) {
                this.achievementId = parameters.achievementId;
                achievementInfo = this.getAchievementInfo(this.achievementId);
                if (achievementInfo != null) {
                    this.title = achievementInfo.name;
                    this.message = achievementInfo.description;
                    this.icon = achievementInfo.icon;
                    this.value = achievementInfo.value;
                }
            }
            if (parameters.width != null) {
                this.width = parameters.width;
            } else if (this.width < 1) {
                this.width = (920 * MemoryMatch.stageScaleFactor) | 0;
            }
            if (parameters.height != null) {
                this.height = parameters.height;
            } else if (this.height < 1) {
                this.height = (290 * MemoryMatch.stageScaleFactor) | 0;
            }
            if (parameters.x != null) {
                this.x = parameters.x;
            } else if (this.x < 1) {
                this.x = (this.width * 0.5) | 0;
            }
            if (parameters.y != null) {
                this.y = parameters.y;
            } else if (this.y < 1) {
                this.y = this.parentDisplayObject.canvas.height - this.height;
            }
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title === null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message === null) {
                this.message = "";
            }
            if (parameters.value != null) {
                this.value = parameters.value;
            }
            if (parameters.icon != null) {
                this.icon = parameters.icon;
            } else if (this.icon === null) {
                this.icon = null;
            }
            if (parameters.backgroundColor != null) {
                this.backgroundColor = parameters.backgroundColor;
            }
            if (parameters.borderColor != null) {
                this.borderColor = parameters.borderColor;
            }
            if (parameters.sound != null) {
                this.sound = parameters.sound;
            }
            if (parameters.autoClose != null) {
                this.autoClose = parameters.autoClose;
            }
            if (parameters.earned != null) {
                this.earned = parameters.earned;
            }
        }
    };

    p.getAchievementInfo = function (achievementId) {
        return MemoryMatch.getAchievementInfo(achievementId);
    };

    p.getBounds = function () {
        return this.groupDisplayObject.getBounds();
    }

    p.buildItem = function () {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.marginTop = (8 * MemoryMatch.stageScaleFactor) | 0;
        this.marginLeft = (8 * MemoryMatch.stageScaleFactor) | 0;
        this.drawBackground();
        this.setupIcon();
        this.setupTitleText();
        this.setupDescriptionText();
        this.setupValueText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.x, this.y, 1, 1, 0, 0, 0, (this.width * 0.5) | 0, (this.height * 0.5) | 0);
        this.groupDisplayObject.visible = true;
        if (this.autoClose) {
//            this.closeStartAnimation();
            window.setTimeout(this.closeStartAnimation.bind(this), 500);
        }
    };

    p.drawBackground = function () {
        var shape = new createjs.Shape();
        shape.x = 0;
        shape.y = 0;
        var graphics = shape.graphics;
        graphics.beginFill(this.backgroundColor);
        graphics.beginStroke(this.borderColor);
        graphics.setStrokeStyle(1);
        graphics.drawRoundRect(0, 0, this.width, this.height, 12);
        this.groupDisplayObject.addChild(shape);
        this.groupDisplayObject.setBounds(0, 0, this.width, this.height);
        return shape;
    };

    p.setupIcon = function () {
        // add the icon on top of the button frame, left-middle justified
        var colorFilter,
            spriteData,
            iconSize,
            iconSprite,
            iconScale = 1;

        if (this.icon != null) {
            spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            iconSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, this.icon);
            iconSprite = new createjs.Sprite(spriteData, this.icon);
            iconSprite.setTransform((this.width * 0.005) | 0, (this.height * 0.5) | 0, iconScale, iconScale, 0, 0, 0, 0, (iconSize.height * 0.5) | 0);
            iconSprite.framerate = 1;
            iconSprite.name = "icon";
            if ( ! this.earned) {
                colorFilter = new createjs.ColorFilter(0.3, 0.3, 0.3, 1);
                iconSprite.filters = [colorFilter];
                iconSprite.cache(0, 0, iconSize.width, iconSize.height);
            }
            this.groupDisplayObject.addChild(iconSprite);
        }
    };

    p.setupTitleText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(42) + " " + MemoryMatch.GameSetup.guiBoldFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
        titleTextField.textAlign = "center";
        titleTextField.x = (this.width * 0.5) | 0;
        titleTextField.y = (this.height * 0.1) | 0;
        titleTextField.lineWidth = (this.width * 0.8) | 0;
        titleTextField.maxWidth = (this.width * 0.8) | 0;
        titleTextField.name = "title";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupDescriptionText = function () {
        var titleTextField;
        var message;

        if (this.earned) {
            message = this.message;
        } else {
            message = '???';
        }
        titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(40) + " " + MemoryMatch.GameSetup.guiMediumFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
        titleTextField.textAlign = "left";
        titleTextField.x = (this.width * 0.28) | 0;
        titleTextField.y = (this.height * 0.36) | 0;
        titleTextField.lineWidth = (this.width * 0.72) | 0;
        titleTextField.maxWidth = (this.width * 0.72) | 0;
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.2;
        titleTextField.name = "description";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupValueText = function () {
        var valueTextField;
        if (this.value != null) {
            valueTextField = new createjs.Text(this.value.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiMediumFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
            valueTextField.textAlign = "right";
            valueTextField.x = (this.width * 0.96) | 0;
            valueTextField.y = (this.height * 0.6) | 0;
            valueTextField.lineWidth = (this.width * 0.8) | 0;
            valueTextField.maxWidth = (this.width * 0.8) | 0;
            valueTextField.name = "value";
            this.groupDisplayObject.addChild(valueTextField);
        }
    };

    p.isShowing = function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    };

    p.playSound = function () {
        if (this.sound != null) {
            MemoryMatch.triggerSoundFx(this.sound, {delay: 0});
        }
    };

    p.closeStartAnimation = function () {
        var duration = 2.5; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 250, duration * 1000, true, null, this.closeComplete.bind(this));
        animator.showAtBegin = true;
        animator.vAlpha = -1 / (duration * MemoryMatch.fps);
        animator.endAlpha = 0;
    };

    p.closeComplete = function () {
        this.killObject();
    };

    p.killObject = function () {
        // remove all display objects and object references:
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    };

    MemoryMatch.AchievementItem = AchievementItem;

}());

/**
 * Created by jf on 12/3/13.
 *
 * This is a rudimentary Animation system.
 * Call init to supply information where the sprites will be used.
 * Then call one of the start* functions to emit a specific set of particle behavior.
 * Then call onEnterFrame in the game loop to update the particle sprites.
 *
 */

MemoryMatch.AnimationHandler = {
    canvas: null,
    stage: null,
    imgSeq: null,
    spriteTemplateParticles: null,
    spriteTemplateStars: null,
    activeCardQueue: null,
    allParticles: null,
    isQuitPending: false,
    maxWidth: 0,
    maxHeight: 0,


    init: function (_canvas, _stage) {
        var spriteDataParticles = {
            images: [MemoryMatch.assetLoader.getResult("particles")],
            frames: MemoryMatch.GameSetup.particleFrames
            },
            spriteSize;

        this.canvas = _canvas;
        this.stage = _stage;
        this.imgSeq = new Image();
        // set up an animation instance, which we will clone when we need to
        this.spriteTemplateParticles = new createjs.Sprite(new createjs.SpriteSheet(spriteDataParticles));
        this.spriteTemplateStars = new createjs.Sprite(new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames), 'particleStar');
        spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'particleStar');
        this.spriteTemplateStars.regX = spriteSize.width * 0.5;
        this.spriteTemplateStars.regY = spriteSize.height * 0.5;
        this.allParticles = [];
        this.activeCardQueue = [];
        this.maxHeight = this.canvas.height;
        this.maxWidth = this.canvas.width;
    },

    quitPending: function (quitFlag) {
        this.isQuitPending = quitFlag;
    },

    destroy: function () {
        // call this if you are finished and want to dealloc the references
        this.clearAllParticles();
        this.clearAllAnimations();
        this.activeCardQueue = null;
        this.allParticles = null;
        this.spriteTemplateParticles = null;
        this.spriteTemplateStars = null;
        this.canvas = null;
        this.stage = null;
        this.imgSeq = null;
    },

    queueSize: function () {
        return (this.activeCardQueue === null ? 0 : this.activeCardQueue.length) + (this.allParticles === null ? 0 : this.allParticles.length);
    },

    addToAnimationQueue: function (actor, delay, duration, removeFromStage, startFunction, endFunction) {
        // actor: display object to animate
        // delay: ms from now to begin animating
        // duration: ms from begin to end animation
        // removeFromStage: true to kill this object when animation is complete
        // startFunction is called on first tick animation begins (after delay)
        // endFunction is called on last tick when animation ends
        var animationObject = null;

        if (actor == null) {
            return; // Nothing to animate!
        }
        if (delay == null) {
            delay = 0;
        }
        if (removeFromStage == null) {
            removeFromStage = false;
        }
        animationObject = {};
        animationObject.actor = actor;
        animationObject.addTime = Date.now();
        animationObject.startTime = animationObject.addTime + delay;
        animationObject.started = false;
        animationObject.markedForRemoval = false;
        if (duration != null) {
            if (duration == 0) {
                animationObject.endTime = 0;
            } else {
                animationObject.endTime = animationObject.startTime + duration;
            }
        } else {
            animationObject.endTime = 0;
        }
        animationObject.removeFromStage = removeFromStage;
        animationObject.startFunction = startFunction;
        animationObject.endFunction = endFunction;
        this.activeCardQueue.push(animationObject);
        return animationObject;
    },

    updateAnimations: function (deltaTime) {
        // Each object on the queue is expected to be a DisplayObject, Sprite, or Container.
        // Animations Parameters:
        //  .actor        : the display object that is the target of the animation
        //  .addTime      : time stamp this animation was added to the queue
        //  .startTime    : time stamp this animation will begin its animation
        //  .removeFromStage : true object will be removed at endTime, false it will remain in display list
        // Optional parameters, when provided they are processed:
        //  .endTime      : time stamp when this object should be removed from animation queue
        //  .vX           : move object with this X velocity
        //  .endX         : X value at endTime (mitigates rounding errors). If vX is not provided will be used to calc vX.
        //  .vY           : move object with this Y velocity
        //  .endY         : Y value at endTime (mitigates rounding errors). If vY is not provided will be used to calc vY.
        //  .vAlpha       : alpha "velocity" amount of alpha to subtract (- to add) over startTime to endTime
        //  .endAlpha     : alpha value at endTime (mitigates rounding errors)
        //  .vRotation    : rotation "velocity" amount of rotation over startTime to endTime
        //  .endRotation  : rotation value at endTime (mitigates rounding errors)
        //  .vXScale      : amount to scale-X each tick
        //  .endXScale    : scale-X value at endTime (mitigates rounding errors)
        //  .vYScale      : amount to scale-Y each tick
        //  .endYScale    : scale-Y value at endTime (mitigates rounding errors)
        //  .vXSkew       : amount to skew-X each tick
        //  .endXSkew     : skew-X value at endTime (mitigates rounding errors)
        //  .vYSkew       : amount to skew-Y each tick
        //  .endYSkew     : skew-Y value at endTime (mitigates rounding errors)
        //  .endFunction  : function to call at endTime
        //  .startFunction: function to call at startTime
        //  .tickFunction : function to call at each tick
        //  .showAtBegin  : true to show at animation begin, false to hide at animation begin, null to do nothing
        //  .showAtEnd    : true to show at animation end, false to hide at animation end, null to do nothing

        var timeNow = Date.now(),
            objectsToRemove = 0,
            animatingObject = null,
            i,
            keepAnimating,
            isAnimating;

        if (this.isQuitPending) {
            return;
        }
        for (i = 0; i < this.activeCardQueue.length; i ++) {
            animatingObject = this.activeCardQueue[i];
//            MemoryMatch.debugLog("Animating Actor " + i + "; " + animatingObject.actor.name);
            if (timeNow >= animatingObject.startTime) {
                isAnimating = false;
                if ( ! animatingObject.started) {
                    animatingObject.started = true;
                    isAnimating = true;
                    if (animatingObject.showAtBegin != null) {
                        animatingObject.actor.visible = animatingObject.showAtBegin;
                    }
                    if (animatingObject.startFunction != null) {
                        animatingObject.startFunction(animatingObject);
                    }
                }

                // update x,y velocity and position
                if (animatingObject.vX != null && animatingObject.vX != 0) {
                    isAnimating = true;
                    animatingObject.actor.x += animatingObject.vX;
                    if (animatingObject.endX != null && animatingObject.vX != null && animatingObject.vX != 0) {
                        if (animatingObject.vX > 0 && animatingObject.actor.x >= animatingObject.endX) {
                            animatingObject.actor.x = animatingObject.endX;
                            animatingObject.vX = null;
                            animatingObject.endX = null;
                        } else if (animatingObject.vX < 0 && animatingObject.actor.x <= animatingObject.endX) {
                            animatingObject.actor.x = animatingObject.endX;
                            animatingObject.vX = null;
                            animatingObject.endX = null;
                        }
                    }
                }
                if (animatingObject.vY != null && animatingObject.vY != 0) {
                    isAnimating = true;
                    animatingObject.actor.y += animatingObject.vY;
                    if (animatingObject.endY != null && animatingObject.vY != null && animatingObject.vY != 0) {
                        if (animatingObject.vY > 0 && animatingObject.actor.y >= animatingObject.endY) {
                            animatingObject.actor.y = animatingObject.endY;
                            animatingObject.vY = null;
                            animatingObject.endY = null;
                        } else if (animatingObject.vY < 0 && animatingObject.actor.y <= animatingObject.endY) {
                            animatingObject.actor.y = animatingObject.endY;
                            animatingObject.vY = null;
                            animatingObject.endY = null;
                        }
                    }
                }

                // update x,y scale
                if (animatingObject.vXScale != undefined && animatingObject.vXScale != 0) {
                    isAnimating = true;
                    animatingObject.actor.scaleX += animatingObject.vXScale;
                    if (animatingObject.endXScale != undefined) {
                        if (animatingObject.vXScale > 0 && animatingObject.actor.scaleX >= animatingObject.endXScale) {
                            animatingObject.actor.scaleX = animatingObject.endXScale;
                            animatingObject.vXScale = null;
                            animatingObject.endXScale = null;
                        } else if (animatingObject.vXScale < 0 && animatingObject.actor.scaleX <= animatingObject.endXScale) {
                            animatingObject.actor.scaleX = animatingObject.endXScale;
                            animatingObject.vXScale = null;
                            animatingObject.endXScale = null;
                        }
                    }
                }
                if (animatingObject.vYScale != undefined && animatingObject.vYScale != 0) {
                    isAnimating = true;
                    animatingObject.actor.scaleY += animatingObject.vYScale;
                    if (animatingObject.endYScale != undefined) {
                        if (animatingObject.vYScale > 0 && animatingObject.actor.scaleY >= animatingObject.endYScale) {
                            animatingObject.actor.scaleY = animatingObject.endYScale;
                            animatingObject.vYScale = null;
                            animatingObject.endYScale = null;
                        } else if (animatingObject.vYScale < 0 && animatingObject.actor.scaleY <= animatingObject.endYScale) {
                            animatingObject.actor.scaleY = animatingObject.endYScale;
                            animatingObject.vYScale = null;
                            animatingObject.endYScale = null;
                        }
                    }
                }

                // update x,y skew
                if (animatingObject.vYSkew != null && animatingObject.vYSkew != 0) {
                    isAnimating = true;
                    animatingObject.actor.skewY += animatingObject.vYSkew;
                    if (animatingObject.endYSkew != null && animatingObject.vYSkew != null && animatingObject.vYSkew != 0) {
                        if (animatingObject.vYSkew > 0 && animatingObject.actor.skewY >= animatingObject.endYSkew) {
                            animatingObject.actor.skewY = animatingObject.endYSkew;
                            animatingObject.vYSkew = null;
                            animatingObject.endYSkew = null;
                        } else if (animatingObject.vYSkew < 0 && animatingObject.actor.skewY <= animatingObject.endYSkew) {
                            animatingObject.actor.skewY = animatingObject.endYSkew;
                            animatingObject.vYSkew = null;
                            animatingObject.endYSkew = null;
                        }
                    }
                }

                // update rotation
                if (animatingObject.vRotation != null && animatingObject.vRotation != 0) {
                    isAnimating = true;
                    animatingObject.actor.rotation += animatingObject.vRotation;
                    if (animatingObject.endRotation != null && animatingObject.vRotation != null && animatingObject.vRotation != 0) {
                        if (animatingObject.vRotation > 0 && animatingObject.actor.rotation >= animatingObject.endRotation) {
                            animatingObject.actor.rotation = animatingObject.endRotation;
                            animatingObject.vRotation = null;
                            animatingObject.endAlpha = null;
                        } else if (animatingObject.vRotation < 0 && animatingObject.actor.rotation <= animatingObject.endRotation) {
                            animatingObject.actor.rotation = animatingObject.endRotation;
                            animatingObject.vRotation = null;
                            animatingObject.endRotation = null;
                        }
                    }
                }

                // update alpha
                if (animatingObject.vAlpha != null && animatingObject.vAlpha != 0) {
                    isAnimating = true;
                    animatingObject.actor.alpha += animatingObject.vAlpha;
                    if (animatingObject.endAlpha != null && animatingObject.vAlpha != null && animatingObject.vAlpha != 0) {
                        if (animatingObject.vAlpha > 0 && animatingObject.actor.alpha >= animatingObject.endAlpha) {
                            animatingObject.actor.alpha = animatingObject.endAlpha;
                            animatingObject.vAlpha = null;
                            animatingObject.endAlpha = null;
                        } else if (animatingObject.vAlpha < 0 && animatingObject.actor.alpha <= animatingObject.endAlpha) {
                            animatingObject.actor.alpha = animatingObject.endAlpha;
                            animatingObject.vAlpha = null;
                            animatingObject.endAlpha = null;
                        }
                    }
                }

                // call tick function
                if (animatingObject.tickFunction != null) {
                    isAnimating = true;
                    keepAnimating = animatingObject.tickFunction(animatingObject);
                    if ( ! keepAnimating) {
                        animatingObject.markedForRemoval = true;
                    }
                }

                // if the endTime has expired, or there is nothing going on with this object, then remove it from the queue
                if ((animatingObject.endTime > 0 && animatingObject.endTime <= timeNow) || ( ! isAnimating && animatingObject.endTime == 0)) {
                    animatingObject.markedForRemoval = true;
                }
                if (animatingObject.markedForRemoval) {
                    objectsToRemove ++;
                    if (animatingObject.showAtEnd != null) {
                        animatingObject.actor.visible = animatingObject.showAtEnd;
                    }
                    if (animatingObject.endFunction != null) {
                        animatingObject.endFunction(animatingObject.actor);
                    }
                }
            }
        }
        if (objectsToRemove > 0) {
            // go through list backwards and remove objects from activeCardQueue
            for (i = this.activeCardQueue.length - 1; i >= 0; i --) {
                animatingObject = this.activeCardQueue[i];
                if (animatingObject.markedForRemoval) {
                    this.activeCardQueue.splice(i, 1);
                }
            }
        }
        if (isAnimating) {
            MemoryMatch.stageUpdated = true;
        }
    },

    updateParticles: function (event, deltaTime) {
        // loop through all of the active particles

        var i,
            particle,
            numberOfParticles = this.allParticles.length,
            isAnimating = false;

        for (i = numberOfParticles - 1; i >= 0; i --) {
            particle = this.allParticles[i];

            // apply gravity and friction
            if (particle.applyGravity) {
                particle.vY += 0.5;
            } else {
                particle.vY *= particle.friction;
            }
            particle.vX *= particle.friction;
            isAnimating = true;

            // update position, scale, and alpha:
            particle.x += particle.vX;
            particle.y += particle.vY;
            particle.alpha += particle.vA;
            particle.scaleX += particle.vScale;
            particle.scaleY += particle.vScale;
            particle.rotation += particle.vRotation;

            // remove sparkles that are no longer visible or are stalled:
            if (particle.alpha <= 0 || particle.y >= this.maxHeight && particle.vY < 1) {
                this.allParticles.splice(i, 1);
                this.stage.removeChild(particle);
            }

            //bounce sparkles off the bottom
            if (particle.bounce) {
                if (particle.y > this.maxHeight) {
                    particle.vY *= -(Math.random() * 0.4 + 0.4);
                    particle.y -= particle.y % this.maxHeight;
                }
                if (particle.x >= this.maxWidth || particle.x <= 0) {
                    particle.vX *= -1;
                }
            } else {
                if (particle.y < 0 || particle.y > this.maxHeight || particle.x >= this.maxWidth || particle.x <= 0) {
                    particle.vA = 0;
                    particle.alpha = 0;
                }
            }
        }
        if (isAnimating) {
            MemoryMatch.stageUpdated = true;
        }
    },

    onEnterFrame: function (event, deltaTime) {
        if (this.activeCardQueue.length > 0) {
            this.updateAnimations(deltaTime);
        }
        if (this.allParticles.length > 0) {
            this.updateParticles(event, deltaTime);
        }
    },

    startSparklerParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.5;
            particle.vScale = 0.05;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = true;
            particle.friction = 0.95;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 40;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startSplatterParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.8;
            particle.vScale = 0;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = false;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 40;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startSplatterStars: function (numberOfStars, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfStars; i ++) {
            // clone the original star, so we don't need to set shared properties:
            particle = this.spriteTemplateStars.clone();
            particle.framerate = 0;

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.8;
            particle.vScale = 0;
            particle.vRotation = Math.random() * 30 - 15;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = false;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 80;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }
            particle.gotoAndStop('particleStar');
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startBurstParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in a burst
        var angleIncrement = (360 / numberOfParticles) * (Math.PI / 180),
            angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.9;
            particle.vScale = 0.02;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = true;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle += angleIncrement;
            v = (0.8 + (Math.random() * 0.2)) * 20;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -0.01; // -Math.random() * 0.01 - 0.005;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    clearAll: function () {
        this.clearAllAnimations();
        this.clearAllParticles();
    },

    clearAllAnimations: function () {
        var i,
            sprite,
            numberOfActiveAnimations = this.activeCardQueue.length;

        for (i = numberOfActiveAnimations - 1; i > 0; i --) {
            sprite = this.activeCardQueue[i].actor;
            this.stage.removeChild(sprite);
        }
        this.activeCardQueue = [];
    },

    clearAllParticles: function () {
        var i,
            particle,
            numberOfActiveParticles = this.allParticles.length;

        for (i = numberOfActiveParticles - 1; i > 0; i --) {
            particle = this.allParticles[i];

            // reset gravity and friction
            particle.vY = 0;
            particle.vX = 0;
            particle.vScale = 0;
            particle.y = -10;
            particle.alpha = 0;
            this.stage.removeChild(particle);
        }
        this.allParticles = [];
    }
};
/**
 * AwardsPopup.js
 *
 * Show the Awards popup showing all earned achievements and other stats.
 *
 */

MemoryMatch.AwardsPopup = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    contentDisplayObject: null,
    closeButtonInstance: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    animate: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    stateCompleteCallback: null,
    startYAchievements: 0,
    scrollMask: null,
    scrollOffset: null,
    scrollLimitMin: 0,
    scrollLimitMax: 0,
    scrollButtonSprite: null,
    scrollButtonOffset: null,
    scrollButtonMin: 0,
    scrollButtonMax: 0,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, callback) {
        this.parentDisplayObject = displayObject;
        this.stateCompleteCallback = callback;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.setupBackground();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.06;
        this.contentDisplayObject = new createjs.Container();
        this.setupMask();
        this.setupTitleText();
        this.startYAchievements = Math.floor(this.backgroundHeight * 0.12);
        this.startYAchievements += this.setupAward(0.5, this.startYAchievements);
        this.setupInfoText();
        this.setupAchievements();
        this.setupButtons();
        this.setupScrollBar();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.contentDisplayObject.setTransform(this.backgroundWidth * -0.028, this.backgroundHeight * 0.05);
        this.groupDisplayObject.addChild(this.contentDisplayObject);
        this.scrollLimitMin = this.contentDisplayObject.y;
        if (autoStart === null) {
            autoStart = false;
        }
        if (animate === null) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        var duration,
            animator;

        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            // begin animation, then wait for user event to end this state and alert callback
            duration = 0.3; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        }
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        // begin animation, then once close is complete send notification
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(closeEventType);
        }
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("close");
        }
    },

    onClickContinue: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onScrollMouseDownHandler: function (event) {
        this.scrollOffset = {x:this.contentDisplayObject.x, y:this.contentDisplayObject.y - event.stageY};
    },

    onScrollPressMoveHandler: function (event) {
        var newY = event.stageY + this.scrollOffset.y;

        if (newY > this.scrollLimitMin) {
            newY = this.scrollLimitMin;
        } else if (newY < this.scrollLimitMax) {
            newY = this.scrollLimitMax;
        }
        this.contentDisplayObject.y = newY;
        this.scrollButtonSprite.y = this.scrollButtonMin + (((newY - this.scrollLimitMin) / (this.scrollLimitMax - this.scrollLimitMin)) * (this.scrollButtonMax - this.scrollButtonMin));
    },

    onScrollHandleDown: function (event) {
        this.scrollButtonOffset = {x:this.scrollButtonSprite.x, y:this.scrollButtonSprite.y - event.stageY};
    },

    onScrollHandlePressMove: function (event) {
        var newY = event.stageY + this.scrollButtonOffset.y,
            percentScroll;

        if (newY < this.scrollButtonMin) {
            newY = this.scrollButtonMin;
        } else if (newY > this.scrollButtonMax) {
            newY = this.scrollButtonMax;
        }
        this.scrollButtonSprite.y = newY;
        percentScroll = (newY - this.scrollButtonMin) / (this.scrollButtonMax - this.scrollButtonMin);
        this.contentDisplayObject.y = this.scrollLimitMin + ((this.scrollLimitMax - this.scrollLimitMin) * percentScroll);
    },

    setupBackground: function () {
        // This method will scale the background image to fit the current stage if it is too big.
        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupMask: function () {
        var maskShape = this.groupDisplayObject.addChild(new createjs.Shape()),
            startY = this.marginTop * 3,
            height = this.backgroundHeight - (4 * this.marginTop);

        maskShape.graphics.beginFill("#521852").drawRoundRect(this.marginLeft, startY, this.backgroundWidth - (2.5 * this.marginLeft), height, 8);
        maskShape.alpha = 0.3333;
        maskShape.visible = true;
        maskShape.on("mousedown", this.onScrollMouseDownHandler.bind(this));
        maskShape.on("pressmove", this.onScrollPressMoveHandler.bind(this));
        this.scrollMask = maskShape;
        this.contentDisplayObject.mask = maskShape;
        this.scrollLimitMax = height - startY;
    },

    setupScrollBar: function () {
        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet1Frames,
            scrollBarHandle = 'awardsHandle',
            scrollBarBackground = 'awardsSlider',
            scrollBarSprite,
            scrollButtonSprite,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            barSpriteSize,
            handleSpriteSize,
            x,
            y;

        x = this.marginLeft + this.backgroundWidth - (2.3 * this.marginLeft);
        y = this.marginTop * 3;
        scrollBarSprite = new createjs.Sprite(spriteData, scrollBarBackground);
        barSpriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, scrollBarBackground);
        scrollBarSprite.setTransform(x, y);
        this.groupDisplayObject.addChild(scrollBarSprite);

        scrollButtonSprite = new createjs.Sprite(spriteData, scrollBarHandle);
        handleSpriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, scrollBarHandle);
        scrollButtonSprite.setTransform(x - ((handleSpriteSize.width - barSpriteSize.width) * 0.5), y);
        scrollButtonSprite.cursor = 'pointer';
        scrollButtonSprite.on("mousedown", this.onScrollHandleDown.bind(this));
        scrollButtonSprite.on("pressmove", this.onScrollHandlePressMove.bind(this));
        this.groupDisplayObject.addChild(scrollButtonSprite);
        this.scrollButtonSprite = scrollButtonSprite;
        this.scrollButtonMin = y;
        this.scrollButtonMax = y + barSpriteSize.height - handleSpriteSize.height;
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text("Your Awards & Stats", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop * 0.8;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupInfoText: function () {

        // Display various player statistics

        var titleTextField,
            playerStats = MemoryMatch.UserData.getUserDataObject(),
            leftX = this.backgroundWidth * 0.12,
            rightX = this.backgroundWidth * 0.49,
            Y,
            timePlayed,
            fieldWidth = this.backgroundWidth * 0.2,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontColor = MemoryMatch.GameSetup.guiFontColor,
            lineHeight = 54 * MemoryMatch.stageScaleFactor,
            numberOfGamesPlayed = playerStats['numberOfGamesPlayed'] | 0,
            totalMatchCount = playerStats['totalMatchCount'] | 0,
            totalCombos = playerStats['totalCombos'] | 0,
            totalTimePlayed = playerStats['totalTimePlayed'] | 0,
            luckyGuessCount = playerStats['luckyGuessCount'] | 0,
            bestScore = playerStats['bestScore'] | 0;

        if (totalTimePlayed == 0) {
            timePlayed = '-';
        } else if (totalTimePlayed >= 60*60*1000) {
            timePlayed = MemoryMatch.formatTimeAsString(totalTimePlayed, true, true);
        } else {
            timePlayed = MemoryMatch.formatTimeAsString(totalTimePlayed, true, false);
        }

        // first column
        Y = this.startYAchievements;
        titleTextField = new createjs.Text("Games:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(numberOfGamesPlayed.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Matches:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(totalMatchCount.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Best Score:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(bestScore), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        // Second column
        leftX = this.backgroundWidth * 0.55;
        rightX = this.backgroundWidth * 0.88;
        Y = this.startYAchievements;
        titleTextField = new createjs.Text("Combos:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(totalCombos.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Time:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(timePlayed, fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Lucky Guesses:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(luckyGuessCount.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        this.startYAchievements = Y + (lineHeight * 1.5);
    },

    setupAward: function (scaleFactor, startY) {
        var awardDisplayObject = new createjs.Container(),
            spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        imageSprite.setTransform(spriteSize.width * 0.5, spriteSize.height * 0.5, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        awardDisplayObject.addChild(imageSprite);
        awardDisplayObject.setBounds(0, 0, spriteSize.width, spriteSize.height);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position = {x: 0, y: 0};
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor), 1, 1);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            awardDisplayObject.addChild(imageSprite);
        }
        this.contentDisplayObject.addChild(awardDisplayObject);
        awardDisplayObject.setTransform((this.backgroundWidth - (spriteSize.width * scaleFactor)) * 0.5, startY, scaleFactor, scaleFactor, 0, 0, 0, 0, 0);
        return startY + (spriteSize.height * scaleFactor * 0.5);
    },

    setupAchievements: function () {
        var allAchievements = MemoryMatch.GameSetup.achievements,
            achievementInfo = null,
            achievementItem = null,
            earned = false,
            i,
            width = this.backgroundWidth * 0.41,
            height = width * 0.33,
            margin = width * 0.01,
            Y = this.startYAchievements + (height * 0.5),
            X = (this.backgroundWidth - width) * 0.51,
            x2Column = X + margin;

        for (i = 0; i < allAchievements.length; i ++ ) {
            achievementInfo = allAchievements[i];
            earned = MemoryMatch.didUserEarnAchievement(achievementInfo.id);
            achievementItem = new MemoryMatch.AchievementItem(this.contentDisplayObject, {achievementId: achievementInfo.id, x: x2Column, y: Y, width: width, height: height, autoClose: false, icon: 'metal', earned: earned, callback: null});
            if (i % 2 == 0) {
                x2Column = X + achievementItem.getBounds().width + margin + margin;
            } else {
                Y += achievementItem.getBounds().height + margin;
                x2Column = X + margin;
            }
        }
        // determine how far past the viewable bottom we are to scroll to
        this.scrollLimitMax = this.scrollLimitMax - achievementItem.y;
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            buttonSize;

        // Close button always shows in its own special place
        gameButton = MemoryMatch.GUIButton({name: "close", tag: 1, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.closeButtonInstance = gameButton;
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        this.scrollButtonSprite.removeAllEventListeners();
        this.scrollButtonSprite = null;
        this.closeButtonInstance.removeAllEventListeners();
        this.closeButtonInstance = null;
        this.scrollMask.removeAllEventListeners();
        this.scrollMask = null;
        this.groupDisplayObject.removeChild(this.contentDisplayObject);
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.contentDisplayObject = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * ChallengeIntroduction.js
 *
 * Show the Challenge Introduction popup. This popup introduces a challenge level.
 *
 */

MemoryMatch.ChallengeIntroduction = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, stateCompleteCallbackFunction) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleAndMessageText();
        this.setupAward();
        this.setupButtons();
        this.groupDisplayObject.setTransform((this.parentDisplayObject.canvas.width * 0.5) - (this.backgroundWidth * 0.5), (this.parentDisplayObject.canvas.height * 0.5) - (this.backgroundHeight * 0.5), 1, 1);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
        MemoryMatch.stopBackgroundMusic();
        MemoryMatch.playInterstitialMusic("soundChallenge", true);
        if (this.stateCompleteCallback !== null) {
            // stateCompleteCallback();
        }
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        MemoryMatch.stopInterstitialMusic();
        // begin animation, then once close is complete send notification
        if (MemoryMatch.ChallengeIntroduction.stateCompleteCallback !== null) {
            MemoryMatch.ChallengeIntroduction.stateCompleteCallback(closeEventType);
        }
        MemoryMatch.ChallengeIntroduction.killScreen();
    },

    onClickHome: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.ChallengeIntroduction.isEnabled) {
            MemoryMatch.ChallengeIntroduction.closePopup("home");
        }
    },

    onClickContinue: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.ChallengeIntroduction.isEnabled) {
            MemoryMatch.ChallengeIntroduction.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleAndMessageText: function () {
        var titleTextField;
        var gameData = MemoryMatch.getGameData(true),
            yOffset;

        titleTextField = new createjs.Text("Challenge Game", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset = titleTextField.y + titleTextField.getMeasuredHeight();

//        titleTextField = new createjs.Text(gameData.levelName, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
//        titleTextField.textAlign = "center";
//        titleTextField.x = this.backgroundWidth * 0.5;
//        titleTextField.y = yOffset;
//        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
//        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
//        this.groupDisplayObject.addChild(titleTextField);
//        yOffset += titleTextField.getMeasuredHeight();

        titleTextField = new createjs.Text(gameData.levelIntro, MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonMargin = 0,
            buttonTagCounter = 0,
            totalWidth = (2 * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },


    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.54};
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.5;
        position.y -= spriteSize.height * 0.5;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor));
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].removeAllEventListeners();
        }
        this.buttonInstances = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * CreditsPopup.js
 *
 * Show game credits.
 *
 */

MemoryMatch.CreditsPopup = {
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    closeButton: true,
    stateCompleteCallback: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,

    setup: function (displayObject, stateCompleteCallback) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.stateCompleteCallback = stateCompleteCallback;
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        this.setupCopyrightText();
        this.showCredits();
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // No animation for Credits
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        // begin animation and send notification we're done here
        this.isEnabled = false;
        if (this.stateCompleteCallback !== null) {
            this.stateCompleteCallback("close");
        }
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            this.closePopup("close");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text("Credits", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    showCredits: function () {
        var titleTextField,
            text1 = 'This game was made by JumpyDot using the EaselJS HTML5 framework.',
            text2 = 'Dan Hart:  Game Design & Product Management\n\nJohn Foster:     Programming & Audio\n\nJulia Deter-Keren: Game Design & Art Direction\n\nRobert Prescott:     Quality Assurance';

        titleTextField = new createjs.Text(text1, MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.2;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);

        titleTextField = new createjs.Text(text2, MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.backgroundHeight * 0.3;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);

        // Show the JumpyDot logo
        var spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet2Frames);
        var iconSprite = new createjs.Sprite(spriteData, "JumpyDotLogo");
        iconSprite.setTransform(this.backgroundWidth * 0.15, this.backgroundHeight * 0.70);
        iconSprite.framerate = 1;
        this.groupDisplayObject.addChild(iconSprite);

        // Show the HTML5 icon
        iconSprite = new createjs.Sprite(spriteData, "html5-logo");
        iconSprite.setTransform(this.backgroundWidth * 0.80, this.backgroundHeight * 0.73);
        iconSprite.framerate = 1;
        this.groupDisplayObject.addChild(iconSprite);
    },

    setupCopyrightText: function () {
        var info = 'Copyright 2014 JumpyDot. All rights reserved.',
            infoTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiInfoColor);

        infoTextField.textAlign = "center";
        infoTextField.x = this.backgroundWidth * 0.5;
        infoTextField.y = this.backgroundHeight * 0.88;
        infoTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(infoTextField);
    },

    setupButtons: function () {
        var spriteFrame,
            spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames),
            buttonScale = 1.0,
            gameButton,
            newButtonInstance,
            buttonSize;

        // Close button always shows in its own special place
        gameButton = MemoryMatch.GUIButton({name: "close", tag: 1, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameComplete.js
 *
 * Show the Game Complete popup. We show this once the player has completed all 4 challenges.
 *
 */

MemoryMatch.GameComplete = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    isEnabled: false,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, stateCompleteCallbackFunction) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleAndMessageText();
        this.setupAward();
        this.setupButtons();
        this.groupDisplayObject.setTransform((this.parentDisplayObject.canvas.width * 0.5) - (this.backgroundWidth * 0.5), (this.parentDisplayObject.canvas.height * 0.5) - (this.backgroundHeight * 0.5), 1, 1);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
        MemoryMatch.stopBackgroundMusic();
        MemoryMatch.playInterstitialMusic("soundWin", false);
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        // begin animation, then once close is complete send notification
        if (MemoryMatch.GameComplete.stateCompleteCallback !== null) {
            MemoryMatch.GameComplete.stateCompleteCallback(closeEventType);
        }
        MemoryMatch.stopInterstitialMusic();
        MemoryMatch.GameComplete.killScreen();
    },

    onClickHome: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.GameComplete.isEnabled) {
            MemoryMatch.GameComplete.closePopup("home");
        }
    },

    onClickShare: function (event) {
        var shareMessage = '';
        if (MemoryMatch.GameComplete.isEnabled) {
            shareMessage = 'I just completed ' + MemoryMatch.GameSetup.gameTitle + ' with a score of ' + MemoryMatch.totalScore + '. can you beat me?';
            MemoryMatch.showSharePopup(shareMessage);
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleAndMessageText: function () {
        var titleTextField,
            yOffset,
            title,
            subtitle,
            info;

        title = MemoryMatch.GameSetup.winState.title;
        subtitle = MemoryMatch.GameSetup.winState.subtitle;
        info = MemoryMatch.GameSetup.winState.info;

        titleTextField = new createjs.Text(title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset = titleTextField.y + titleTextField.getMeasuredHeight();

        titleTextField = new createjs.Text(subtitle, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset += titleTextField.getMeasuredHeight() + (42 * MemoryMatch.stageScaleFactor);

        titleTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(38) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            buttonMargin = 42 * MemoryMatch.stageScaleFactor,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonTagCounter = 0,
            xOffset = (this.backgroundWidth - (buttonWidth + buttonMargin + buttonWidth)) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "share", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickShare.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverShareIcon", iconOver: "gameOverShareDownIcon", iconDown: "gameOverShareDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.54};
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.5;
        position.y -= spriteSize.height * 0.5;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor));
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].removeAllEventListeners();
        }
        this.buttonInstances = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameGUI.js
 *
 * Show the HUD display. This abstracts the game GUI that is displayed and manages any
 * transactions to keep the GUI management and display separate from any game logic.
 *
 * Layout:
 * Score ######### Level ##/##  <* * *> Matches: ## Time: ##:## [O]
 */

MemoryMatch.GameGUI = {
    groupDisplayObject: null,
    parentDisplayObject: null,
    width: 0,
    height: 0,
    hudHeight: 0,
    spriteData: null,
    headerSprite: null,
    levelNumber: 1,
    levelField: null,
    levelIcon: null,
    scoreField: null,
    matchCountLabel: null,
    matchCountField: null,
    gameTimerField: null,
    messageField: null,
    timerCountdownGroup: null,
    timerCountdownTimer: null,
    comboMultiplierSprite: null,
    matchCountFieldFlash: false,
    matchCountFieldFlashCount: 0,
    matchCountFlashTimer: null,
    optionsButton: null,
    optionsButtonHelper: null,
    gameOptionsButton: null,
    gameOptionsButtonHelper: null,
    isAnimating: false,
    flashThreshold: 2,
    comboMultiplier: 1,
    timerCountdownStarted: false,
    lastUpdateTime: 0,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    showingGameLevel: 0,

    build: function (stage) {
        // layout the display objects assuming parentDisplayObject is valid
        this.parentDisplayObject = stage;
        if (this.parentDisplayObject != null) {
            this.width = MemoryMatch.stageWidth;
            this.height = MemoryMatch.stageHeight;
            this.groupDisplayObject = new createjs.Container();
            this.showingGameLevel = MemoryMatch.gameLevel;
            if (this.spriteData == null) {
                this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            }
            this.setColorFilters();
            this.setupHeader();
            this.setupOptionsButton();
            this.setupGameOptionsButton();
            this.setupScoreTextField();
            this.setupLevelTextField();
            this.setupMatchCountTextField();
            this.setupGameTimerTextField();
            this.setupMessageTextField();
            this.parentDisplayObject.addChild(this.groupDisplayObject);
            this.groupDisplayObject.setTransform(0, this.hudHeight * -1, 1, 1);
        }
    },

    destroy: function () {
        // Kill all events, display objects and remove from stage
        if (this.matchCountFlashTimer != null) {
            window.clearTimeout(this.matchCountFlashTimer);
            this.matchCountFlashTimer = null;
        }
        if (this.timerCountdownTimer != null) {
            window.clearTimeout(this.timerCountdownTimer);
            this.timerCountdownTimer = null;
        }
        this.parentDisplayObject.removeChild(this.optionsButton);
        if (this.timerCountdownGroup != null) {
            this.parentDisplayObject.removeChild(this.timerCountdownGroup);
            this.timerCountdownGroup = null;
        }
        this.spriteData = null;
        this.headerSprite = null;
        this.levelField = null;
        this.levelIcon = null;
        this.scoreField = null;
        this.matchCountLabel = null;
        this.matchCountField = null;
        this.gameTimerField = null;
        this.messageField = null;
        this.optionsButton = null;
        this.optionsButtonHelper = null;
        this.gameOptionsButton = null;
        this.gameOptionsButtonHelper = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.groupDisplayObject = null;
        this.parentDisplayObject = null;
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        this.isAnimating = false;
    },

    pause: function (event) {
        // show the paused state
        this.hideTimerCountdown();
    },

    resume: function (event) {
        // undo the paused state and bring the GUI back to normal
    },

    show: function (showFlag) {
        // show or hide the HUD. This triggers the animation so it will take some time before it is in a ready state.
        var finalY,
            distance;

        if (this.groupDisplayObject == null) {
            return;
        }
        if (showFlag) {
            if (this.showingGameLevel != MemoryMatch.gameLevel) {
                this.setColorFilters();
                this.showingGameLevel = MemoryMatch.gameLevel
            }
            finalY = 0;
            distance = 0 - this.groupDisplayObject.y;
            this.optionsButton.visible = false;
        } else {
            finalY = this.hudHeight * -1;
            distance = finalY - this.groupDisplayObject.y;
            this.matchCountFieldFlash = false;
            this.comboMultiplierSprite.visible = false;
            this.hideTimerCountdown();
            this.optionsButton.visible = true;
        }
        if (finalY != this.groupDisplayObject.y && ! this.isAnimating) {
            this.messageField.visible = false; // hide message field until animation completes
            this.isAnimating = true;
            var guiAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, 0, false, null, this.showAnimationComplete.bind(this));
            guiAnimator.vY = distance / (0.2 * MemoryMatch.fps);
            guiAnimator.endY = finalY;
        }
    },

    showAnimationComplete: function (g) {
        var isShowing = this.groupDisplayObject.y >= 0;
        this.messageField.visible = isShowing; // only show message field if GUI is showing
        this.comboMultiplierSprite.visible = isShowing;
        this.isAnimating = false;
    },

    setMessage: function (message) {
        this.messageField.text = message;
    },

    getHeight: function () {
        return this.hudHeight;
    },

    updateLevelDisplay: function (level, gameNumber) {
        // convert level # to icon image
        var displayGameNumber;
        if (level < 1) {
            level = 1;
        } else if (level > MemoryMatch.GameSetup.levels.length) {
            level = MemoryMatch.GameSetup.levels.length;
        }
        if (MemoryMatch.isChallengeGame) {
            displayGameNumber = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].gameCount + 1 + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
        } else {
            displayGameNumber = gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
        }
        this.levelNumber = level;
        this.levelIcon.gotoAndStop(MemoryMatch.GameSetup.levels[level - 1].iconHUD);
        this.levelField.text = displayGameNumber.toString();
    },

    updateScoreDisplay: function (newScoreValue) {
        if (newScoreValue == null || newScoreValue == '') {
            newScoreValue = 0;
        }
        if (newScoreValue > 0) {
            this.scoreField.text = MemoryMatch.formatNumberWithGroups(newScoreValue);
        } else {
            this.scoreField.text = "0";
        }
    },

    updateMatchCountDisplay: function (newValue) {
        var valueChanged = this.matchCountField.text != Number(newValue).toString();
        this.matchCountField.text = Number(newValue).toString();
        if ( ! MemoryMatch.isChallengeGame && newValue <= this.flashThreshold) {
            this.matchCountField.color = MemoryMatch.GameSetup.guiAlertFontColor;
            if (valueChanged) {
                if (newValue > 0) {
                    MemoryMatch.triggerSoundFx("soundMovesLast");
                } else {
                    MemoryMatch.triggerSoundFx("soundMovesLow");
                }
            }
            if ( ! this.matchCountFieldFlash) {
                this.flashMatchCountDisplay(true, -1);
            }
        } else {
            this.matchCountField.color = MemoryMatch.GameSetup.guiFontColor;
            this.matchCountField.alpha = 1;
            this.matchCountFieldFlash = false;
        }
    },

    flashMatchCountDisplay: function (flashFlag, flashCount) {
        if (this.matchCountFieldFlash === flashFlag) {
            return;
        }
        this.matchCountFieldFlash = flashFlag;
        this.matchCountFieldFlashCount = flashCount;
        if (flashFlag) {
            this.matchCountFlashTimer = window.setTimeout(this.flashMatchCountDisplayUpdate.bind(this), 500);
        } else {
            this.matchCountField.alpha = 1;
            if (this.matchCountFlashTimer != null) {
                window.clearTimeout(this.matchCountFlashTimer);
                this.matchCountFlashTimer = null;
            }
        }
    },

    flashMatchCountDisplayUpdate: function (event) {
        var stillFlashing = true;
        var newAlpha = 1;

        if (this.matchCountField == null) {
            return;
        }
        if (this.matchCountFieldFlash) {
            if (this.matchCountField.alpha < 1) {
                newAlpha = 1;
            } else {
                newAlpha = 0.4;
            }
            if (this.matchCountFieldFlashCount > 0) {
                this.matchCountFieldFlashCount --;
                if (this.matchCountFieldFlashCount == 0) {
                    newAlpha = 1;
                    stillFlashing = false;
                }
            }
            this.matchCountField.alpha = newAlpha;
            if (stillFlashing) {
                this.matchCountFlashTimer = window.setTimeout(this.flashMatchCountDisplayUpdate.bind(this), 500);
            } else {
                this.matchCountFlashTimer = null;
            }
        }
    },

    setFlashCountThreshold: function (newThreshold) {
        if (newThreshold < 0) {
            newThreshold = 0;
        }
        this.flashThreshold = newThreshold;
    },

    setMatchCountLabel: function (newLabel) {
        if (newLabel == null) {
            newLabel = 'Misses';
        }
        this.matchCountLabel.text = newLabel;
    },

    updateGameTimerDisplay: function (newValue) {
        var timeToShow;

        if (this.gameTimerField == null) {
            return;
        }
        if (newValue == null) {
            timeToShow = '';
        } else if (newValue == 0) {
            timeToShow = '0:00';
        } else {
            timeToShow = MemoryMatch.formatTimeAsString(newValue, true, false);
        }
        this.gameTimerField.text = timeToShow;
    },

    updateComboMultiplier: function (newValue) {
        var displayString = '';
        var startAnimation = false;

        if (this.comboMultiplierSprite != null) {
            if (newValue == null || newValue < 2) {
                this.comboMultiplier = 1;
            } else {
                if (newValue > this.comboMultiplier) {
                    this.comboMultiplier = newValue;
                    startAnimation = true;
                }
            }
            if (this.comboMultiplier > 1) {
                displayString = this.comboMultiplier.toString() + 'x';
            }
            this.comboMultiplierSprite.text = displayString;
            if (startAnimation) {
                this.startComboSpriteAnimation();
            }
        }
    },

    showOptionsButton: function (showFlag) {
        this.optionsButton.visible = showFlag;
    },

    showLevelField: function (showFlag) {
        this.levelField.visible = showFlag;
    },

    showMatchCountField: function (showFlag) {
        this.matchCountLabel.visible = showFlag;
        this.matchCountField.visible = showFlag;
    },

    showTimer: function (showFlag) {
        this.gameTimerField.visible = showFlag;
    },

    showTimerCountdown: function (message, startSeconds) {

        // display a count down timer with title message and seconds to count down

        var containerGroup,
            containerWidth,
            containerHeight,
            titleTextField,
            titleTextFieldSize,
            backgroundShape,
            timerTextField,
            timerTextFieldSize,
            timerTextFieldAnimate;

        if (this.timerCountdownStarted) {
            return;
        }
        if (message == null) {
            message = '';
        }
        if (startSeconds < 1) {
            startSeconds = 1;
        } else if (startSeconds > 99) {
            startSeconds = 99;
        }
        if (this.timerCountdownGroup == null) {
            titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(32) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
            titleTextField.textAlign = 'center';
            titleTextField.name = 'title';

            timerTextField = new createjs.Text(startSeconds.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
            timerTextField.textAlign = 'center';
            timerTextField.name = 'timer';

            titleTextFieldSize = titleTextField.getBounds();
            timerTextFieldSize = timerTextField.getBounds();
            containerWidth = Math.max(titleTextFieldSize.width, timerTextFieldSize.width) * 1.2;
            containerHeight = titleTextFieldSize.height + timerTextFieldSize.height * 1.1;
            titleTextField.x = containerWidth * 0.5;
            timerTextField.x = containerWidth * 0.5;
            titleTextField.y = containerHeight * 0.1;
            timerTextField.y = titleTextField.y + titleTextFieldSize.height;
            timerTextFieldAnimate = timerTextField.clone();
            timerTextFieldAnimate.name = 'timerAnimate';

            backgroundShape = new createjs.Shape();
            backgroundShape.graphics.beginFill("#000000").drawRoundRect(0, 0, containerWidth, containerHeight, 8);
            backgroundShape.alpha = 0.2;
            backgroundShape.name = 'background';

            containerGroup = new createjs.Container();
            containerGroup.addChild(backgroundShape);
            containerGroup.addChild(titleTextField);
            containerGroup.addChild(timerTextField);
            containerGroup.addChild(timerTextFieldAnimate);
            containerGroup.setTransform(MemoryMatch.stageWidth * 0.8, MemoryMatch.stageWidth * 0.014);
            this.groupDisplayObject.addChild(containerGroup);
            this.timerCountdownGroup = containerGroup;
        } else {
            containerGroup = this.timerCountdownGroup;
            containerGroup.visible = true;
            titleTextField = this.timerCountdownGroup.getChildByName('title');
            if (titleTextField != null) {
                titleTextField.text = message;
            }
            timerTextField = this.timerCountdownGroup.getChildByName('timer');
            if (timerTextField != null) {
                timerTextField.text = startSeconds.toString();
            }
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                timerTextFieldAnimate.text = startSeconds.toString();
            }
        }
        this.lastUpdateTime = 0;
    },

    hideTimerCountdown: function () {
        if (this.timerCountdownGroup != null) {
            this.timerCountdownGroup.visible = false;
            this.timerCountdownStarted = false;
            this.lastUpdateTime = 0;
            this.showTimer(true);
        }
    },

    startTimerCountdown: function () {
        if ( ! this.timerCountdownStarted) {
            this.timerCountdownStarted = true;
            this.showTimer(false);
            this.updateTimerCountdown();
        }
    },

    updateTimerCountdown: function () {
        var timerTextFieldAnimate,
            animator;

        if (this.timerCountdownGroup != null && this.timerCountdownGroup.visible) {
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(timerTextFieldAnimate, 0, 900, false, null, null);
                animator.showAtBegin = true;
                animator.vAlpha = -0.0167;
                animator.vXScale = 0.0093;
                animator.endXScale = 1.5;
                animator.vYScale = 0.0093;
                animator.endYScale = 1.5;
                this.timerCountdownTimer = window.setTimeout(this.onTimerCountdownTick.bind(this), 1000);
                this.lastUpdateTime = Date.now();
            }
        }
    },

    onTimerCountdownTick: function () {
        var timerTextFieldAnimate,
            timerTextField,
            updateTimeDelta,
            timeValue,
            lastUpdate;

        if (this.timerCountdownGroup != null) {
            updateTimeDelta = Date.now() - this.lastUpdateTime;
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                timerTextFieldAnimate.alpha = 1.0;
                timerTextFieldAnimate.scaleX = 1.0;
                timerTextFieldAnimate.scaleY = 1.0;
                timeValue = parseInt(timerTextFieldAnimate.text);
                if (timeValue > 0) {
                    timeValue --;
                    lastUpdate = false;
                } else {
                    lastUpdate = true;
                }
                timerTextFieldAnimate.text = timeValue.toString();
                timerTextField = this.timerCountdownGroup.getChildByName('timer');
                if (timerTextField != null) {
                    timerTextField.text = timeValue.toString();
                }
                if (timeValue >= 0 && ! lastUpdate) {
                    this.updateTimerCountdown();
                } else {
                    this.timerCountdownStarted = false;
                    this.timerCountdownTimer = null;
                }
            }
        }
    },

    setupLevelTextField: function () {

        // add the icon on top of the button frame

        var iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[this.levelNumber - 1].iconHUD,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon),
            levelField;

        iconSprite.setTransform(this.width * 0.01, (this.hudHeight - spriteSize.height) * 0.5, iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";

        levelField = new createjs.Text("", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        levelField.textAlign = "left";
        levelField.textBaseline = "middle";
        levelField.setTransform(this.width * 0.09, this.hudHeight * 0.5);
        levelField.maxWidth = 120 * MemoryMatch.stageScaleFactor; // space for 3 chars

        this.groupDisplayObject.addChild(iconSprite);
        this.levelIcon = iconSprite;
        this.groupDisplayObject.addChild(levelField);
        this.levelField = levelField;
    },

    setupScoreTextField: function () {
        var scoreField = new createjs.Text("0", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        scoreField.textAlign = "center";
        scoreField.textBaseline = "middle";
        scoreField.setTransform(this.width * 0.25, this.hudHeight * 0.5);
        scoreField.maxWidth = this.width * 0.0974;
        this.groupDisplayObject.addChild(scoreField);
        this.scoreField = scoreField;
    },

    setupMatchCountTextField: function () {
        var matchCountLabel,
            matchCountField,
            matchCountWidth,
            matchCountHeight,
            backgroundShape;

        matchCountWidth = this.width * 0.18;
        matchCountHeight = this.hudHeight * 0.68;
        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRect(0, 0, matchCountWidth, matchCountHeight);
        backgroundShape.alpha = 0.2;
        backgroundShape.setTransform((this.width - matchCountWidth) * 0.5, this.hudHeight * 0.14);
        this.groupDisplayObject.addChild(backgroundShape);

        matchCountLabel = new createjs.Text("Misses:", MemoryMatch.getScaledFontSize(60) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountLabel.textAlign = "right";
        matchCountLabel.textBaseline = "middle";
        matchCountLabel.setTransform(this.width * 0.52, this.hudHeight * 0.5);
        matchCountLabel.maxWidth = this.width * 0.1;
        this.matchCountLabel = matchCountLabel;
        this.groupDisplayObject.addChild(matchCountLabel);

        matchCountField = new createjs.Text("0", MemoryMatch.getScaledFontSize(84) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountField.textAlign = "left";
        matchCountField.textBaseline = "middle";
        matchCountField.setTransform(this.width * 0.54, this.hudHeight * 0.44);
        matchCountField.maxWidth = this.width * 0.03;
        this.matchCountField = matchCountField;
        this.groupDisplayObject.addChild(matchCountField);
    },

    setupGameTimerTextField: function () {
        var maxFieldWidth = 10 * 22 * MemoryMatch.stageScaleFactor,
            gameTimerField = new createjs.Text("", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);

        gameTimerField.textAlign = "left";
        gameTimerField.textBaseline = "middle";
        gameTimerField.setTransform(this.width * 0.8, this.hudHeight * 0.5)
        gameTimerField.maxWidth = maxFieldWidth;
        this.groupDisplayObject.addChild(gameTimerField);
        this.gameTimerField = gameTimerField;
    },

    setupMessageTextField: function () {
        var bounds,
            comboSprite,
            messageField = new createjs.Text("", MemoryMatch.getScaledFontSize(24) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);

        messageField.textAlign = "left";
        messageField.x = 30 * MemoryMatch.stageScaleFactor;
        messageField.y = this.height - (40 * MemoryMatch.stageScaleFactor);
        messageField.maxWidth = this.width - (20  * MemoryMatch.stageScaleFactor);
        messageField.visible = false;
        this.groupDisplayObject.addChild(messageField);
        this.messageField = messageField;

        comboSprite = new createjs.Text("1x", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColorBonus);
        comboSprite.textAlign = "center";
        comboSprite.x = MemoryMatch.stageWidth * 0.9;
        comboSprite.y = MemoryMatch.stageHeight * 0.96;
        comboSprite.maxWidth = this.width - (20  * MemoryMatch.stageScaleFactor);
        comboSprite.visible = false;
        bounds = comboSprite.getBounds();
        comboSprite.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
        comboSprite.regY = bounds.height * 0.5;
        this.groupDisplayObject.addChild(comboSprite);
        this.comboMultiplierSprite = comboSprite;
    },

    setupHeader: function () {
        // we want the header centered in the current stage regardless of the stage width
        var spriteFrame = "topHud",
            guiHeaderSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);

        this.hudHeight = spriteSize.height;
        guiHeaderSprite.framerate = 1;
        guiHeaderSprite.gotoAndStop("topHud");
        guiHeaderSprite.setTransform((this.width - spriteSize.width) * 0.5, 0, 1, 1);
        if (this.primaryColorFilter != null) {
            guiHeaderSprite.filters = [this.primaryColorFilter];
        }
        guiHeaderSprite.cache(0, 0, spriteSize.width, spriteSize.height);
        this.groupDisplayObject.addChild(guiHeaderSprite);
        this.headerSprite = guiHeaderSprite;
    },

    setupOptionsButton: function () {
        var spriteFrame = "mapOptionsButtonUp",
            optionsButton = new createjs.Sprite(new createjs.SpriteSheet(MemoryMatch.GameSetup.mapSpritesheetFrames), spriteFrame),
            optionsButtonMargin = 20 * MemoryMatch.stageScaleFactor, // a little extra margin for the hit-area of the button
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.mapSpritesheetFrames, spriteFrame);

        optionsButton.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(-1 * optionsButtonMargin, 0, buttonSize.width + optionsButtonMargin, buttonSize.height + optionsButtonMargin));
        optionsButton.setTransform(this.width * 0.946, this.height * 0.04);
        optionsButton.framerate = 1;
        this.optionsButtonHelper = new createjs.ButtonHelper(optionsButton, "mapOptionsButtonUp", "mapOptionsButtonOver", "mapOptionsButtonDown", false);
        optionsButton.addEventListener("click", this.onOptions);
        this.parentDisplayObject.addChild(optionsButton);
        optionsButton.visible = true;
        this.optionsButton = optionsButton;
    },

    setupGameOptionsButton: function () {
        var spriteFrame = "optionsUp",
            optionsButton = new createjs.Sprite(this.spriteData, spriteFrame),
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);

        optionsButton.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(0, 0, buttonSize.width, buttonSize.height));
        optionsButton.setTransform(this.width * 0.93, (this.hudHeight - buttonSize) * 0.5);
        optionsButton.framerate = 1;
        this.gameOptionsButtonHelper = new createjs.ButtonHelper(optionsButton, "optionsUp", "optionsOver", "optionsDown", false);
        optionsButton.addEventListener("click", this.onGameOptions);
        this.groupDisplayObject.addChild(optionsButton);
        optionsButton.visible = true;
        this.gameOptionsButton = optionsButton;
    },

    onPauseGame: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.beginNewGame(1);
    },

    onOptions: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.GameGUI.optionsButton.gotoAndStop("optionsDown");

        // Show the Options popup
        if ( ! MemoryMatch.GameOptions.isShowing()) {
            MemoryMatch.pauseGameInProgress();
            MemoryMatch.GameOptions.setup(MemoryMatch.stage, MemoryMatch.GameGUI.onOptionsClosed, false);
            MemoryMatch.GameOptions.buildScreen(true, true);
        } else {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onHome: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("home");
        } else {
            MemoryMatch.GameResults.close();
            MemoryMatch.GameGUI.show(false);
            MemoryMatch.showMenuScreen();
        }
    },

    onGameOptions: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.GameGUI.optionsButton.gotoAndStop("optionsDown");

        // Show the Game Paused popup
        if ( ! MemoryMatch.GameOptions.isShowing()) {
            MemoryMatch.pauseGameInProgress();
            MemoryMatch.GameOptions.setup(MemoryMatch.stage, MemoryMatch.GameGUI.onOptionsClosed, true);
            MemoryMatch.GameOptions.buildScreen(true, true);
        } else {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onOptionsClosed: function (eventType) {
        switch (eventType) {
            case "home": // quit any current game and show main menu
                MemoryMatch.onQuitGame();
                break;
            case "restart": // restart the current game
                MemoryMatch.replayCurrentGame();
                break;
            case "continue":
            case "close":    // unpause the game
            default:
                if (MemoryMatch.gameState != MemoryMatch.GAMESTATE.MENU) {
                    MemoryMatch.resumePausedGame();
                }
                break;
        }
    },

    startComboSpriteAnimation: function () {
        var animator;

        if (this.comboMultiplierSprite != null) {
            // grow & rotate
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboMultiplierSprite, 0, 0, false, null, this.comboSpriteAnimationPhaseTwo.bind(this));
            animator.showAtBegin = true;
            animator.vXScale = 0.08;
            animator.endXScale = 1.2;
            animator.vYScale = 0.08;
            animator.endYScale = 1.2;
            animator.vRotation = -1.2;
            animator.endRotation = -12;
        }
    },

    comboSpriteAnimationPhaseTwo: function () {
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboMultiplierSprite, 0, 0, false, null, this.killComboSpriteAnimation.bind(this));
        animator.showAtBegin = true;
        animator.vXScale = -0.08;
        animator.endXScale = 1.0;
        animator.vYScale = -0.08;
        animator.endYScale = 1.0;
        animator.vRotation = 1.2;
        animator.endRotation = 0;
    },

    killComboSpriteAnimation: function () {
        if (this.comboMultiplierSprite != null) {
        }
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
        if (this.headerSprite != null) {
            this.headerSprite.filters = [this.primaryColorFilter];
            this.headerSprite.updateCache();
        }
    }
};

/**
 * GameOptions.js
 *
 * Show the options popup. This popup has 2 contexts: current active game, and no game active.
 * If a game is active then show:
 *   Audio button
 *   Help button
 *   Home button
 *   Restart button
 *   Credits button
 *   Close button
 *
 * If no game is active then show:
 *   Audio button
 *   Credits button
 *   View Stats button
 *   Clear Stats button
 *   Close button
 *
 */

MemoryMatch.GameOptions = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    audioOnButtonInstance: null,
    audioOffButtonInstance: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    centerX: 0,
    marginX: 0,
    lineHeight: 0,
    isGameOptions: false,
    isEnabled: false,
    closeEventType: null,
    animate: true,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,

    setup: function (displayObject, stateCompleteCallbackFunction, isGameOptions) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.isGameOptions = isGameOptions;
        this.isEnabled = false;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.centerX = this.backgroundWidth * 0.5;
        this.marginX = 12 * MemoryMatch.stageScaleFactor;
        this.setupTitleText();
        this.setupButtons();
        this.setupInfoText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        if (autoStart === null) {
            autoStart = false;
        }
        if (animate === null) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        var duration,
            animator;

        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            // begin animation, then wait for user event to end this state and alert callback
            duration = 0.3; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        }
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1,
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        if (MemoryMatch.GameOptions.stateCompleteCallback !== null) {
            MemoryMatch.GameOptions.stateCompleteCallback(this.closeEventType);
        }
        MemoryMatch.GameOptions.killScreen();
    },

    closePopup: function (closeEventType) {
        if (this.isShowing()) {
            this.isEnabled = false;
            this.closeEventType = closeEventType;
            // begin animation, then once close is complete send notification
            this.closeStartAnimation();
        }
    },

    closePopupFromPopup: function (closeEventType) {
        // Close popup without animation
        if (this.isShowing()) {
            this.isEnabled = false;
            this.closeEventType = closeEventType;
            this.closeComplete();
        }
    },

    onClickClose: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onClickHome: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("home");
        }
    },

    onClickRestart: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("restart");
        }
    },

    onClickContinue: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("continue");
        }
    },

    onClickCredits: function (event) {
        if (this.isEnabled) {
            MemoryMatch.unlockAllLevelsCounter ++;
            MemoryMatch.CreditsPopup.setup(MemoryMatch.stage, this.closePopupFromPopup.bind(this));
            MemoryMatch.CreditsPopup.buildScreen(true);
        }
    },

    onClickAudio: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            var muteFlag = ! createjs.Sound.getMute();
            createjs.Sound.setMute(muteFlag);
            MemoryMatch.GameOptions.audioOnButtonInstance.visible = ! muteFlag;
            MemoryMatch.GameOptions.audioOnButtonInstance.setEnabled( ! muteFlag);
            MemoryMatch.GameOptions.audioOffButtonInstance.visible = muteFlag;
            MemoryMatch.GameOptions.audioOffButtonInstance.setEnabled(muteFlag);
            MemoryMatch.audioMute = muteFlag;
            MemoryMatch.updateUserDataObject(null);
        }
    },

    onClickHelp: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            if (MemoryMatch.GameOptions.isGameOptions) {
                MemoryMatch.LevelIntroduction.setup(MemoryMatch.stage, MemoryMatch.GameOptions.onHelpCallback.bind(MemoryMatch.GameOptions), MemoryMatch.gameId, MemoryMatch.gameLevel, MemoryMatch.gameNumber);
                MemoryMatch.LevelIntroduction.buildScreen(true, false);
            } else {
                this.showHelp();
                this.closePopupFromPopup(null);
            }
        }
    },

    onClickFullScreen: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.goFullScreen();
        }
    },

    onClickShare: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.showSharePopup(MemoryMatch.GameSetup.gameSubTitle);
        }
    },

    onClickViewStats: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.unlockAllLevelsCounter ++;
            MemoryMatch.AwardsPopup.setup(MemoryMatch.stage, MemoryMatch.GameOptions.onMessagePopupCallback.bind(MemoryMatch.GameOptions));
            MemoryMatch.AwardsPopup.buildScreen(true, false);
        }
    },

    onClickClearStats: function (event) {
        var objectToDisplay;
        if (MemoryMatch.GameOptions.isEnabled) {
            if (MemoryMatch.unlockAllLevelsCounter > 2) {
                MemoryMatch.unlockAllLevels();
                objectToDisplay = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: "UNLOCKED", message: 'You have unlocked all levels.', sound: 'soundCorrect'});
            } else {
                MemoryMatch.resetUserData();
                objectToDisplay = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: "CLEARED", message: 'You have reset all levels.', sound: 'soundCorrect'});
            }
            MemoryMatch.unlockAllLevelsCounter = 0;
            if (MemoryMatch.MainMenu != null) {
                MemoryMatch.MainMenu.refreshButtons();
            }
            objectToDisplay = null;
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onMessagePopupCallback: function (closeEventType) {
        // closeEventType indicates the button used to close the popup
        this.closePopupFromPopup(closeEventType);
    },

    onHelpCallback: function (closeEventType, level, gameNumber) {
        this.closePopupFromPopup(closeEventType);
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {
        var title,
            titleTextField;

        if (this.isGameOptions) {
            title = "Game Paused";
        } else {
            title = "Options";
        }
        titleTextField = new createjs.Text(title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupInfoText: function () {
        var info,
            infoTextField;

        info = MemoryMatch.GameSetup.gameTitle + " version " + MemoryMatch.GameVersion + " on " + MemoryMatch.platform + " locale " + MemoryMatch.locale + (MemoryMatch.isTouchDevice ? " / Touch" : " / Mouse");
        infoTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiInfoColor);
        infoTextField.textAlign = "left";
        infoTextField.x = this.marginLeft;
        infoTextField.y = this.backgroundHeight * 0.92;
        infoTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(infoTextField);
    },

    setupButtons: function () {
        var buttonsGroup = new createjs.Container(),
            spriteFrame,
            buttonScale = 1.0,
            gameButton,
            buttonTagCounter = 0, // 8 * MemoryMatch.stageScaleFactor
            buttonSize,
            buttonMargin = 42 * MemoryMatch.stageScaleFactor,
            groupWidth,
            groupHeight,
            muted,
            fullScreenDisabled = ! MemoryMatch.isFullScreenAvailable(),
            xOffset,
            yOffset,
            buttonGap,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        // Figure out how to size the whole group of buttons.
        // This logic assumes all buttons are the same height.
        // We need a wide button to figure out how wide the button group will be.
        spriteFrame = "optionsLargeButtonBase";
        buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);
        groupWidth = buttonSize.width;
        groupHeight = buttonSize.height * 3;
        xOffset = 0;
        yOffset = 0;

        // Audio button always shows but we need to set the correct state
        buttonTagCounter ++;
        muted = createjs.Sound.getMute();
        gameButton = MemoryMatch.GUIButton({name: "audioOn", tag: buttonTagCounter, disabled: false, callback: this.onClickAudio.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallSoundOnIcon", iconOver: "optionsSmallSoundOnDownIcon", iconDown: "optionsSmallSoundOnDownIcon"});
        gameButton.setTransform(xOffset, yOffset, 1, 1);
        gameButton.visible = ! muted;
        gameButton.setEnabled( ! muted);
        buttonsGroup.addChild(gameButton);
        this.audioOnButtonInstance = gameButton;
        this.buttonInstances.push(gameButton);

        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "audioOff", tag: buttonTagCounter, disabled: false, callback: this.onClickAudio.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallSoundOffIcon", iconOver: "optionsSmallSoundOffDownIcon", iconDown: "optionsSmallSoundOffDownIcon"});
        gameButton.setTransform(xOffset, yOffset, 1, 1);
        gameButton.visible = muted;
        gameButton.setEnabled(muted);
        buttonsGroup.addChild(gameButton);
        this.audioOffButtonInstance = gameButton;
        this.buttonInstances.push(gameButton);

        if (this.isGameOptions) {
            // Show Map button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "home", tag: buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallMenuIcon", iconOver: "optionsSmallMenuDownIcon", iconDown: "optionsSmallMenuDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Credits button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "credits", tag: buttonTagCounter, disabled: false, callback: this.onClickCredits.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallCreditIcon", iconOver: "optionsSmallCreditDownIcon", iconDown: "optionsSmallCreditDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Help button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "help", tag: buttonTagCounter, disabled: false, callback: this.onClickHelp.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallHelpIcon", iconOver: "optionsSmallHelpDownIcon", iconDown: "optionsSmallHelpDownIcon"});
            buttonSize = gameButton.getSize();
            xOffset = groupWidth - buttonSize.width;
            yOffset = 0;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Restart (Replay) button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "restart", tag: buttonTagCounter, disabled: false, callback: this.onClickRestart.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallReplayIcon", iconOver: "optionsSmallReplayDownIcon", iconDown: "optionsSmallReplayDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show fullscreen button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "fullscreen", tag: buttonTagCounter, disabled: fullScreenDisabled, callback: this.onClickFullScreen.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallFullScreenIcon", iconOver: "optionsSmallFullScreenDownIcon", iconDown: "optionsSmallFullScreenDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        } else {
            // Show View Stats button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "viewstats", tag: buttonTagCounter, disabled: false, callback: this.onClickViewStats.bind(this), baseUp: "optionsLargeButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, text: "View Stats", iconUp: "optionsLargeAwardsIcon", iconOver: "optionsLargeAwardsDownIcon", iconDown: "optionsLargeAwardsDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Clear Stats button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "clearstats", tag: buttonTagCounter, disabled: false, callback: this.onClickClearStats.bind(this), baseUp: "optionsLargeButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, text: "Clear Stats", iconUp: "optionsLargeClearIcon", iconOver: "optionsLargeClearDownIcon", iconDown: "optionsLargeClearDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Help button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "help", tag: buttonTagCounter, disabled: false, callback: this.onClickHelp.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallHelpIcon", iconOver: "optionsSmallHelpDownIcon", iconDown: "optionsSmallHelpDownIcon"});
            buttonSize = gameButton.getSize();
            xOffset = groupWidth - buttonSize.width;
            yOffset = 0;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // adjust width of group for a 3rd column of buttons. Assumes 3rd column buttons are same width/height as the help button we just placed.
            buttonGap = xOffset - buttonSize.width;
            groupWidth += buttonGap + buttonSize.width;
            xOffset += buttonSize.width + buttonGap;
            yOffset = 0;

            // Show small Full screen button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "fullscreen", tag: buttonTagCounter, disabled: fullScreenDisabled, callback: this.onClickFullScreen.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallFullScreenIcon", iconOver: "optionsSmallFullScreenDownIcon", iconDown: "optionsSmallFullScreenDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Share button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "share", tag: buttonTagCounter, disabled: false, callback: this.onClickShare.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverShareIcon", iconOver: "gameOverShareDownIcon", iconDown: "gameOverShareDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Credits button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "credits", tag: buttonTagCounter, disabled: false, callback: this.onClickCredits.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallCreditIcon", iconOver: "optionsSmallCreditDownIcon", iconDown: "optionsSmallCreditDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
        // center the group in the popup
        buttonsGroup.setTransform((this.backgroundWidth - groupWidth) * 0.5, (this.backgroundHeight - groupHeight) * 0.5, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(buttonsGroup);
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    showHelp: function () {
        // Position a DOM element and close. DOM element is responsible to close itself.
        var pageElement = document.getElementById('helpArea');
        pageElement.style.display = 'block';
    },


    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.audioOnButtonInstance = null;
        this.audioOffButtonInstance = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameResults.js
 *
 * Show the results screen, either for a game or for the end of a level.
 * Waits for the user to indicate they are ready to move on then stateCompleteCallback is called.
 *
 */

MemoryMatch.GameResults = {
    stateCompleteCallback: null,
    levelData: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    spriteData: null,
    gemSprite: null,
    gemSpriteFinalPosition: null,
    matchBonusText: null,
    comboBonusText: null,
    currentScoreTextField: null,
    bestScoreTextField: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    totalGameTime: 0,
    timeBonus: 0,
    movesRemainingBonus: 0,
    comboBonus: 0,
    achievementBonus: 0,
    totalMatches: 0,
    totalMisses: 0,
    totalCombos: 0,
    totalMoves: 0,
    unusedMoves: 0,
    accuracy: 0,
    playerScore: 0,
    playerBestScore: 0,
    gameStarsEarned: 0,
    isChallenge: false,
    isEnabled: false,
    lineHeight: 0,
    priorGameData: null,
    gameNumber: 0,
    streakCount: 0,
    starHalfWidth: 0,
    holdThirdStar: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    refreshTimerId: null,


    setup: function (displayObject, nextLevelData, stateCompleteCallbackFunction) {
        var winOrLose,
            displayGameNumber,
            eventDataValue;

        if (this.levelData !== null) {
            return;
        }
        // use the level data to do any level-specific results
        this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
        this.levelData = nextLevelData;
        this.gameNumber = MemoryMatch.isChallengeGame ? 99 : MemoryMatch.gameNumber;
        this.streakCount = 0;
        this.priorGameData = MemoryMatch.getPriorScoreDataForGameNumber(this.gameNumber, null);
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.playerScore = MemoryMatch.gameScore;
        this.totalCombos = MemoryMatch.numberOfCombos;
        this.unusedMoves = MemoryMatch.moveCountDown;
        this.totalMoves = MemoryMatch.levelTolerance - MemoryMatch.moveCountDown;
        this.totalMatches = MemoryMatch.matchCount;
        this.totalMisses = MemoryMatch.missCount;
        this.totalGameTime = MemoryMatch.gameEndTime - MemoryMatch.gameStartTime;
        this.timeBonus = MemoryMatch.calculateTimeBonus();
        this.movesRemainingBonus = MemoryMatch.calculateUnusedMovesBonus();
        this.comboBonus = MemoryMatch.calculateComboBonus();
        this.achievementBonus = MemoryMatch.calculateAchievementBonus();
        this.totalGameTime = MemoryMatch.formatTimeAsString(this.totalGameTime, false, false);
        this.accuracy = MemoryMatch.calculateLevelAccuracy();
        this.gameStarsEarned = MemoryMatch.starsEarnedInCurrentGame();
        this.buttonInstances = [];
        this.playerBestScore = MemoryMatch.priorBestGameScore;
        if (MemoryMatch.levelComplete) {
            winOrLose = "win";
        } else {
            winOrLose = "lose";
        }
        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.playerBeatChallenge && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.SIMON) {
                this.streakCount = MemoryMatch.gameNumber;
            } else {
                this.streakCount = MemoryMatch.gameNumber - 1;
            }
            displayGameNumber = MemoryMatch.gameLevel * 100;
            eventDataValue = this.streakCount;
        } else {
            displayGameNumber = MemoryMatch.gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
            eventDataValue = this.totalMisses;
        }
        this.isEnabled = false;
        enginesisSession.gameTrackingRecord('level', winOrLose, 'Level ' + displayGameNumber.toString(), eventDataValue, null);
    },

    buildScreen: function (autoStart) {
        var hiFiveWord;

        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.06;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText(this.groupDisplayObject);
        if (MemoryMatch.isChallengeGame) {
            this.setupAward(this.groupDisplayObject);

            hiFiveWord = MemoryMatch.hiFiveEarnedInCurrentGame();
            if (hiFiveWord != null && hiFiveWord.length > 0) {
                MemoryMatch.showMessageBalloon(null, hiFiveWord + '!', 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.2);
            }
        } else {
            this.setupStars(this.groupDisplayObject);
        }
        this.setupTipText(this.groupDisplayObject);
        this.setupLevelText(this.groupDisplayObject);
        this.setupButtons(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        this.groupDisplayObject.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        var playThisMusic,
            duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        if (MemoryMatch.levelComplete) {
            playThisMusic = "soundWin";
        } else {
            playThisMusic = "soundLose";
        }
        MemoryMatch.playInterstitialMusic(playThisMusic, false);
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        if (MemoryMatch.isChallengeGame) {
            this.isEnabled = true;
            this.flashNextButton();
        }
        if (this.stateCompleteCallback !== null) {
            // stateCompleteCallback();
        }
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        MemoryMatch.stopInterstitialMusic();
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        if (this.stateCompleteCallback !== null) {
            this.stateCompleteCallback(this.closeEventType);
        }
        this.killScreen();
    },

    close: function () {
        MemoryMatch.GameResults.isEnabled = false;
        if (MemoryMatch.GameResults.isShowing()) {
            MemoryMatch.GameResults.closeStartAnimation();
        }
    },

    onClickNext: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "next";
            MemoryMatch.GameResults.close();
        }
    },

    onClickReplay: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "replay";
            MemoryMatch.GameResults.close();
        }
    },

    onClickHome: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "home";
            MemoryMatch.GameResults.close();
        }
    },

    refreshCache: function () {
        this.groupDisplayObject.updateCache();
    },

    flashNextButton: function () {
        if (this.buttonInstances.length > 2) {
            this.buttonInstances[2].setFlashing(true);
            this.startRefreshInterval();
        }
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupStars: function (groupDisplayObject) {
        var i,
            starFrame = "gameOverStarFill",
            starWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][2],
            starHeight = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][3],
            slotFrame = "gameOverStarEmpty",
            slotWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[slotFrame][0]][2],
            slotHeight = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[slotFrame][0]][3],
            starSprite,
            starSpriteCloned,
            slotSprite,
            slotSpriteCloned,
            starGap = 36 * MemoryMatch.stageScaleFactor,
            topMargin = Math.floor(this.backgroundHeight * 0.12),
            starsTotalWidth = (3 * (slotWidth + starGap)) - starGap,
            startX = Math.floor((this.backgroundWidth - starsTotalWidth) * 0.5),
            animator,
            starAnimationDelay = 800;

        if (this.gameStarsEarned === 3) { // we hold back the 3rd star for extra affect
            this.holdThirdStar = true;
        } else {
            this.holdThirdStar = null;
        }
        for (i = 0; i < MemoryMatch.GameSetup.numberOfStars; i ++) {
            if (i === 0) {
                starSprite = new createjs.Sprite(this.spriteData, starFrame);
                slotSprite = new createjs.Sprite(this.spriteData, slotFrame);
                starSprite.framerate = 1;
                slotSprite.framerate = 1;
                starSprite.visible = false;
                slotSprite.visible = true;
                starSpriteCloned = starSprite;
                slotSpriteCloned = slotSprite;
            } else {
                starSpriteCloned = starSprite.clone();
                slotSpriteCloned = slotSprite.clone();
            }
            slotSpriteCloned.setTransform(startX, topMargin);
            groupDisplayObject.addChild(slotSpriteCloned);
            if (i < this.gameStarsEarned) {
                starSpriteCloned.setTransform(startX + (slotWidth - starWidth) - 1, topMargin + (slotHeight - starHeight) - 1);
                starSpriteCloned.visible = false;
                starSpriteCloned.starNumber = i + 1;
                groupDisplayObject.addChild(starSpriteCloned);
                if (i === 2 && this.holdThirdStar) {
                    this.holdThirdStar = starSpriteCloned;
                } else {
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(starSpriteCloned, starAnimationDelay + (500 * i), 0, false, null, this.showStar.bind(this));
                    animator.showAtBegin = true;
                }
            }
            startX += slotWidth + starGap;
        }
    },

    showStar: function (starSprite) {
        var numberOfParticles,
            hiFiveWord,
            starFrame = "gameOverStarFill",
            starHalfWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][2] * 0.5,
            globalStarPoint = this.groupDisplayObject.localToGlobal(starSprite.x, starSprite.y);

        if (starSprite.starNumber < 3) {
            numberOfParticles = Math.random() * 100 + 30;
        } else {
            numberOfParticles = Math.random() * 120 + 50;
            hiFiveWord = MemoryMatch.hiFiveEarnedInCurrentGame();
            if (hiFiveWord != null && hiFiveWord.length > 0) {
                MemoryMatch.showMessageBalloon(null, hiFiveWord + '!', 0, starSprite.x, starSprite.y);
            }
        }
        MemoryMatch.AnimationHandler.startSplatterParticles(numberOfParticles, globalStarPoint.x + starHalfWidth, globalStarPoint.y + starHalfWidth);
        this.groupDisplayObject.updateCache();
        MemoryMatch.triggerSoundFx("soundBump");
        if (MemoryMatch.isChallengeGame) {
            this.isEnabled = true;
            this.flashNextButton();
        }
    },

    showThirdStar: function (delay) {
        var animator;

        if (this.holdThirdStar !== null) {
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.holdThirdStar, delay, 0, false, null, this.showStar.bind(this));
            animator.showAtBegin = true;
            this.holdThirdStar = null;
            MemoryMatch.triggerSoundFx("soundBonus", {delay: delay});
        }
    },

    setupAward: function (groupDisplayObject) {

        // Show Award instead of stars

        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.22};
        imageSprite.setTransform(position.x, position.y, 0.5, 0.5, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.25;
        position.y -= spriteSize.height * 0.25;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * 0.5 * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * 0.5 * MemoryMatch.stageScaleFactor), 0.5, 0.5);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
            if (MemoryMatch.levelComplete && imageSprite.visible && landNumber == MemoryMatch.gameLevel) {
                spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, gemName);
                this.gemSprite = imageSprite.clone();
                this.gemSprite.width = spriteSize.width;
                this.gemSprite.height = spriteSize.height;
                this.gemSpriteFinalPosition = {x: imageSprite.x + spriteSize.width * 0.5, y: imageSprite.y + spriteSize.height * 0.5};
                this.animateGemToAward();
            }
        }
    },

    setupTitleText: function (groupDisplayObject) {

        // Show the icon representing the level and the popup title

        var titleTextField,
            levelSummary,
            iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].iconPopup,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon);

        iconSprite.setTransform(this.marginLeft - (spriteSize.width * 0.25), this.marginTop - (spriteSize.height * 0.25), iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";
        groupDisplayObject.addChild(iconSprite);

        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.levelComplete) {
                levelSummary = "Challenge Complete!";
                if (MemoryMatch.gameLevel < MemoryMatch.GameSetup.levels.length) {
                    levelSummary += " Play On!";
                }
            } else {
                levelSummary = "Challenge Failed! Try Again?";
            }
        } else if (MemoryMatch.levelComplete) {
            levelSummary = "Level " + (MemoryMatch.gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel)).toString() + " Complete! Play On!";
        } else {
            levelSummary = "Out of Moves! Try Again?";
        }
        titleTextField = new createjs.Text(levelSummary, MemoryMatch.getScaledFontSize(58) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        groupDisplayObject.addChild(titleTextField);
    },

    setupTipText: function (groupDisplayObject) {
        var tipTextField,
            tipText = this.getRandomTip(MemoryMatch.levelComplete);

        tipTextField = new createjs.Text(tipText, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        tipTextField.textAlign = "center";
        tipTextField.x = this.backgroundWidth * 0.5;
        tipTextField.y = this.backgroundHeight * 0.32;
        tipTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        tipTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        tipTextField.lineHeight = tipTextField.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(tipTextField);
    },

    addTextBackgroundSprite: function (groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX) {
        var textBackgroundSprite = textBackgroundSpriteSource.clone(),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'gameOverInfoBoxSmall');
        textBackgroundSprite.x = rightX - spriteSize.width;
        textBackgroundSprite.y = levelTextField.y - (spriteSize.height * 0.5);
        groupDisplayObject.addChild(textBackgroundSprite);
    },

    setupLevelText: function (groupDisplayObject) {
        // Room for 4 lines of text at 28 px line height
        var leftX = this.backgroundWidth * 0.12,
            rightX = this.backgroundWidth * 0.44,
            fieldWidth = this.backgroundWidth * 0.2,
            levelTextField,
            Y,
            animator,
            accuracy,
            starAnimationDelay = 1000,
            fieldOffset = 0,
            fontSize = MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBestScore,
            fontColor = MemoryMatch.GameSetup.guiFontColor,
            fontColorBonus = MemoryMatch.GameSetup.guiFontColorBonus,
            fontSizeDifference,
            textBackgroundSpriteSource;

        textBackgroundSpriteSource = new createjs.Sprite(this.spriteData, 'gameOverInfoBoxSmall');
        textBackgroundSpriteSource.alpha = 0.1;
        this.lineHeight = 96 * MemoryMatch.stageScaleFactor;
        if ( ! MemoryMatch.isChallengeGame) {
            Y = Math.floor(this.backgroundHeight * 0.5);

            // 1: Misses
            levelTextField = new createjs.Text("Misses:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(this.totalMisses.toString(), fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextMisses.bind(this));
            animator.showAtBegin = true;
            if (this.movesRemainingBonus > 0) {
                this.matchBonusText = new createjs.Text("+ " + this.movesRemainingBonus.toString(), fontSizeBold, fontColorBonus);
                this.matchBonusText.textAlign = "left";
                this.matchBonusText.x = rightX;
                this.matchBonusText.y = Y;
                this.matchBonusText.maxWidth = fieldWidth;
                this.matchBonusText.visible = false;
                groupDisplayObject.addChild(this.matchBonusText);
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.matchBonusText, starAnimationDelay + (750 * fieldOffset), 0, false, null, null);
                animator.showAtBegin = true;
                animator.vAlpha = -0.05;
                animator.vY = -1.5;
                animator.vXscale = 0.1;
                animator.vYscale = 0.1;
                animator.tickFunction = this.animateBonusTick.bind(this);
            }
            fieldOffset ++;

            // 2: Accuracy
            Y += this.lineHeight;
            accuracy = this.accuracy > 0 ? this.accuracy.toString() + "%" : '--';
            levelTextField = new createjs.Text("Accuracy:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(accuracy, fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateText.bind(this));
            animator.showAtBegin = true;
            fieldOffset ++;

            if (MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.CHAINS) {
                // Combo bonus
                Y += this.lineHeight;
                levelTextField = new createjs.Text("Combos:", fontSize, fontColor);
                levelTextField.textAlign = "left";
                levelTextField.textBaseline = "middle";
                levelTextField.x = leftX;
                levelTextField.y = Y;
                levelTextField.maxWidth = fieldWidth;
                this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
                groupDisplayObject.addChild(levelTextField);

                levelTextField = new createjs.Text(this.totalCombos.toString(), fontSizeBold, fontColor);
                levelTextField.textAlign = "right";
                levelTextField.textBaseline = "middle";
                levelTextField.x = rightX;
                levelTextField.y = Y;
                levelTextField.maxWidth = fieldWidth;
                levelTextField.visible = false;
                groupDisplayObject.addChild(levelTextField);
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextComboBonus.bind(this));
                animator.showAtBegin = true;
                this.matchBonusText = null;
                if (this.comboBonus > 0) {
                    this.comboBonusText = new createjs.Text("+ " + this.comboBonus.toString(), fontSizeBold, fontColorBonus);
                    this.comboBonusText.textAlign = "left";
                    this.comboBonusText.x = rightX;
                    this.comboBonusText.y = Y;
                    this.comboBonusText.maxWidth = fieldWidth;
                    this.comboBonusText.visible = false;
                    groupDisplayObject.addChild(this.comboBonusText);
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboBonusText, starAnimationDelay + (500 * fieldOffset), 0, false, null, null);
                    animator.showAtBegin = true;
                    animator.vAlpha = -0.05;
                    animator.vY = -1.5;
                    animator.vXscale = 0.1;
                    animator.vYscale = 0.1;
                    animator.tickFunction = this.animateBonusTick.bind(this);
                }
                fieldOffset ++;
            }

            // Second Column
            leftX = this.backgroundWidth * 0.56;
            rightX = this.backgroundWidth * 0.88;
            Y = Math.floor(this.backgroundHeight * 0.5);

            // Time Bonus
            levelTextField = new createjs.Text("Time Bonus:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.timeBonus), fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextTimeBonus.bind(this));
            animator.showAtBegin = true;

            Y += this.lineHeight;
        } else {
            // Centered
            Y = Math.floor(this.backgroundHeight * 0.52);
            leftX = this.backgroundWidth * 0.38;
            rightX = this.backgroundWidth * 0.68;

            // 1: Streak
            levelTextField = new createjs.Text("Streak:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(this.streakCount.toString(), this.streakCount < 5 ? fontSizeBold : fontSizeBoldBig, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            groupDisplayObject.addChild(levelTextField);

            Y += this.lineHeight;
        }

        // Score
        if (this.playerScore >= this.playerBestScore) {
            fontSizeBestScore = fontSizeBoldBig;
        } else {
            fontSizeBestScore = fontSizeBold;
        }
        levelTextField = new createjs.Text("Score:", fontSize, fontColor);
        levelTextField.textAlign = "left";
        levelTextField.textBaseline = "middle";
        levelTextField.x = leftX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
        groupDisplayObject.addChild(levelTextField);

        levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.playerScore), fontSizeBestScore, fontColor);
        levelTextField.textAlign = "right";
        levelTextField.textBaseline = "middle";
        levelTextField.x = rightX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        levelTextField.name = 'playerscore';
        groupDisplayObject.addChild(levelTextField);
        this.currentScoreTextField = levelTextField;

        // Best Score
        Y += this.lineHeight;
        if (this.playerScore >= this.playerBestScore) {
            fontSizeBestScore = fontSizeBold;
            fontSizeDifference = 0;
            if (this.playerBestScore == 0) {
                this.playerBestScore = this.playerScore;
            }
        } else {
            fontSizeBestScore = fontSizeBoldBig;
            fontSizeDifference = 10 * MemoryMatch.stageScaleFactor;
        }
        levelTextField = new createjs.Text("Best:", fontSize, fontColor);
        levelTextField.textAlign = "left";
        levelTextField.textBaseline = "middle";
        levelTextField.x = leftX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
        groupDisplayObject.addChild(levelTextField);

        levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.playerBestScore), fontSizeBestScore, fontColor);
        levelTextField.textAlign = "right";
        levelTextField.textBaseline = "middle";
        levelTextField.x = rightX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        levelTextField.name = 'bestscore';
        groupDisplayObject.addChild(levelTextField);
        this.bestScoreTextField = levelTextField;
        if (MemoryMatch.isChallengeGame) {
            window.setTimeout(this.showBestScoreBurstIfBeatBestScore.bind(this), 500);
        }
    },

    animateText: function (textSprite) {
        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.updateCache();
            return true;
        } else {
            return false;
        }
    },

    animateTextMisses: function (textSprite) {
        this.playerScore += this.movesRemainingBonus;
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
        }
        this.groupDisplayObject.updateCache();
    },

    animateTextComboBonus: function (textSprite) {
        this.playerScore += this.comboBonus;
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
        }
        this.groupDisplayObject.updateCache();
    },

    animateTextTimeBonus: function (textSprite) {

        // This is the final animation update, bump the score/best score if player beats best score.

        var scoreFont,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName;

        this.playerScore += this.timeBonus;
        if (this.playerScore >= this.playerBestScore) {
            scoreFont = fontSizeBoldBig;
        } else {
            scoreFont = fontSizeBold;
        }
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
            this.currentScoreTextField.font = scoreFont;
        }
        this.showBestScoreBurstIfBeatBestScore();
        this.showThirdStar(250);
        this.isEnabled = true;
        this.flashNextButton();
        this.groupDisplayObject.updateCache();
    },

    animateBonusTick: function (textSprite) {
        this.groupDisplayObject.updateCache();
        return textSprite.actor.alpha > 0;
    },

    showBestScoreBurstIfBeatBestScore: function () {
        // display particle effect if player beat her best score
        var globalTextPoint,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName;

        if (this.bestScoreTextField !== null) {
            if (this.playerScore >= this.playerBestScore && this.playerScore != 0) {
                this.playerBestScore = this.playerScore;
                this.bestScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerBestScore);
                if (MemoryMatch.levelComplete) {
                    globalTextPoint = this.groupDisplayObject.localToGlobal(this.bestScoreTextField.x, this.bestScoreTextField.y);
                    MemoryMatch.AnimationHandler.startSplatterParticles(Math.random() * 100 + 30, globalTextPoint.x, globalTextPoint.y);
                }
                this.bestScoreTextField.font = fontSizeBoldBig;
                this.groupDisplayObject.updateCache();
            }
        }
    },

    setupButtons: function (groupDisplayObject) {
        // 2 or 3 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            numberOfButtons = MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN ? 3 : 2,
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[spriteFrame][0]][2] * buttonScale,
            gameButton,
            buttonTagCounter = 0,
            buttonMargin = 0, // 8 * MemoryMatch.stageScaleFactor;
            totalWidth = (numberOfButtons * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.77,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        gameButton.refreshParent = this;
        groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "replay", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickReplay.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverReplayIcon", iconOver: "gameOverReplayDownIcon", iconDown: "gameOverReplayDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        gameButton.refreshParent = this;
        groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            xOffset += buttonWidth + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickNext.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
            gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
            gameButton.refreshParent = this;
            groupDisplayObject.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    getRandomTip: function (forTheWin) {
        var tipIndex = MemoryMatch.gameLevel - 1,
            tipsArray = MemoryMatch.GameSetup.tips[tipIndex],
            tipsArrayLength = tipsArray.length,
            tipStartIndex = MemoryMatch.getRandomNumberBetween(0, tipsArrayLength - 1),
            tipIndex = tipStartIndex,
            tip,
            matched = false;

        while ( ! matched) {
            if ((forTheWin && tipsArray[tipIndex].category == 'win') || (! forTheWin && tipsArray[tipIndex].category != 'win')) {
                matched = true;
            } else {
                tipIndex ++;
                if (tipIndex == tipStartIndex) {
                    matched = true; // we scanned the entire array and didn't find a match, just use whatever we got
                } else if (tipIndex == tipsArrayLength) {
                    tipIndex = 0;
                }
            }
        }
        tip = tipsArray[tipIndex].text;
        return tip;
    },

    startRefreshInterval: function () {
        this.refreshTimerId = window.setTimeout(this.refreshInterval.bind(this), 500);
    },

    refreshInterval: function () {
        this.refreshCache();
        this.startRefreshInterval();
    },

    animateGemToAward: function () {
        // gem animation:
        // 1. gem sprite starts centered in popup very large scale
        // 2. gem scales to size and position moves to award
        // 3. done, cleanup

        var animator,
            startAlpha = 0.4,
            startScale = 14,
            endScale = 0.75,
            duration = 0.8,
            steps;

        if (this.gemSprite != null) {
            this.gemSprite.setTransform(this.backgroundWidth * 0.5, this.backgroundHeight * 0.5, startScale, startScale, 0, 0, 0, this.gemSprite.width * 0.5, this.gemSprite.height * 0.5);
            this.gemSprite.alpha = startAlpha;
            this.groupDisplayObject.addChild(this.gemSprite);
            steps = MemoryMatch.fps * duration;
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.gemSprite, 300, 0, false, null, this.gemAnimationComplete.bind(this));
            animator.vX = (this.gemSpriteFinalPosition.x - this.gemSprite.x) / steps;
            animator.endX = this.gemSpriteFinalPosition.x;
            animator.vY = (this.gemSpriteFinalPosition.y - this.gemSprite.y) / steps;
            animator.endY = this.gemSpriteFinalPosition.y;
            animator.vAlpha = (1 - startAlpha) / steps;
            animator.endAlpha = 1;
            animator.vXScale = -1 * (startScale - endScale) / steps;
            animator.endXScale = 0.75;
            animator.vYScale = animator.vXScale;
            animator.endYScale = animator.endXScale;
            animator.tickFunction = this.gemAnimationUpdate.bind(this);
        }
    },

    gemAnimationUpdate: function (animator) {
        var stillAnimating = false,
            endScale = 0.75;

        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.updateCache();
            if (animator.actor.alpha != 1 || animator.actor.scaleX != endScale) {
                stillAnimating = true;
            }
        }
        return stillAnimating;
    },

    gemAnimationComplete: function (actor) {
        var globalCardPoint = this.groupDisplayObject.localToGlobal(this.gemSprite.x, this.gemSprite.y);
        MemoryMatch.AnimationHandler.startSplatterStars(Math.random() * 120 + 100, globalCardPoint.x, globalCardPoint.y);
        MemoryMatch.triggerSoundFx("soundBump");
        this.groupDisplayObject.removeChild(this.gemSprite);
        this.gemSprite = null;
        this.gemSpriteFinalPosition = null;
        this.groupDisplayObject.updateCache();
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        if (this.refreshTimerId != null) {
            window.clearTimeout(this.refreshTimerId);
            this.refreshTimerId = null;
        }
        this.spriteData = null;
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.backgroundSoundInstance != null) {
            this.backgroundSoundInstance.stop();
            this.backgroundSoundInstance = null;
        }
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.currentScoreTextField = null;
        this.bestScoreTextField = null;
        this.matchBonusText = null;
        this.comboBonusText = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GUIButton.js
 *
 * GUI buttons are buttons built from composite parts with specific functionality:
 *   Display a button back, an Icon (optional), text (optional)
 *   Supports display and behavior for active and disabled states
 *   Support for standard event states: rollover, rollout, up, down, pressed
 *   Call a function when clicked
 *   Supports a blinking state
 *   This is an auto-creating object you should just call teh constructor of these and release it when you are done.
 *
 *   To create one of these, call GUIButton(parameters) where parameters is an object with the following properties:
 *      baseUp: sprite frame reference of the button back when enabled/up
 *      baseDisabled: sprite frame reference of the button back when disabled
 *      baseOver: sprite frame reference of the button back when mouse over
 *      baseDown: sprite frame reference of the button back when pressed
 *      text: the text to show on the button. If there is an icon, text is left justified to the icon. If no icon, text is centered
 *      addTextShadow: true will add a shadow to the text
 *      icon Up/Over/Down: if there is no text, icon is centered. If there is text icon is left justified
 *      callback: function to call when click event generated. parameter is the button name.
 *      name: unique name of this button
 *      tag: unique tag number of this button
 *      disabled: show button is the disabled state, otherwise the button is enabled
 *
 */

MemoryMatch.GUIButton = function (parameters) {
    var guiButton = new createjs.Container();

    guiButton.callback = null;
    guiButton.buttonSprite = null;
    guiButton.iconSprite = null;
    guiButton.text = null;
    guiButton.addTextShadow = false;
    guiButton.name = "button";
    guiButton.tag = 0;
    guiButton.buttonScale = 1;
    guiButton.disabled = false;
    guiButton.forceDisabledDisplay = false;
    guiButton._isPressed = false;
    guiButton._isOver = false;
    guiButton._isFlashing = false;
    guiButton.spriteFrames = null;
    guiButton.spriteData = null;
    guiButton.shadowSource = null;
    guiButton.buttonFaceActive = null;
    guiButton.buttonFaceOver = null;
    guiButton.buttonFaceDown = null;
    guiButton.buttonFaceDisabled = null;
    guiButton.buttonBaseActive = null;
    guiButton.buttonBaseOver = null;
    guiButton.buttonBaseDown = null;
    guiButton.buttonBaseDisabled = null;
    guiButton.buttonBaseColor = null;
    guiButton.buttonBaseRollOverColor = null;
    guiButton.spriteSheet = guiButton.spriteData;
    guiButton.buttonColorFilter = null;
    guiButton.buttonRollOverColorFilter = null;
    guiButton.refreshParent = null;
    guiButton.flashingTimerId = null;
    guiButton.flashingCounter = null;
    guiButton.flashingInterval = 500;

    guiButton.setParameters = function (parameters) {
        if (parameters != null) {
            if (parameters.text != null) {
                guiButton.text = parameters.text;
            }
            if (parameters.name != null) {
                guiButton.name = parameters.name;
            }
            if (parameters.tag != null) {
                guiButton.tag = parseInt(parameters.tag);
            }
            if (parameters.callback != null) {
                guiButton.callback = parameters.callback;
            }
            if (parameters.disabled != null) {
                guiButton.disabled = parameters.disabled;
            }
            if (parameters.baseUp != null) {
                guiButton.buttonBaseActive = parameters.baseUp;
            }
            if (parameters.baseOver != null) {
                guiButton.buttonBaseOver = parameters.baseOver;
            }
            if (parameters.baseDown != null) {
                guiButton.buttonBaseDown = parameters.baseDown;
            }
            if (parameters.baseDisabled != null) {
                guiButton.buttonBaseDisabled = parameters.baseDisabled;
            }
            if (parameters.buttonBaseColor != null) {
                guiButton.buttonBaseColor = parameters.buttonBaseColor;
            }
            if (parameters.buttonBaseRollOverColor != null) {
                guiButton.buttonBaseRollOverColor = parameters.buttonBaseRollOverColor;
            }
            if (parameters.icon != null) {
                guiButton.buttonFaceActive = parameters.icon;
            }
            if (parameters.iconUp != null) {
                guiButton.buttonFaceActive = parameters.iconUp;
            }
            if (parameters.iconDown != null) {
                guiButton.buttonFaceDown = parameters.iconDown;
            }
            if (parameters.iconOver != null) {
                guiButton.buttonFaceOver = parameters.iconOver;
            }
            if (parameters.iconDisabled != null) {
                guiButton.buttonFaceDisabled = parameters.iconDisabled;
            }
            if (parameters.addTextShadow != null) {
                guiButton.addTextShadow = parameters.addTextShadow;
            }
            if (parameters.spriteFrames != null) {
                guiButton.spriteFrames = parameters.spriteFrames;
            } else {
                guiButton.spriteFrames = MemoryMatch.GameSetup.guiSpritesheet1Frames;
            }
            // set defaults for things not provided
            if (guiButton.buttonBaseOver == null) {
                guiButton.buttonBaseOver = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonBaseDown == null) {
                guiButton.buttonBaseDown = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonBaseDisabled == null) {
                guiButton.buttonBaseDisabled = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonFaceOver == null) {
                guiButton.buttonFaceOver = guiButton.buttonFaceActive;
            }
            if (guiButton.buttonFaceDown == null) {
                guiButton.buttonFaceDown = guiButton.buttonFaceActive;
            }
            if (guiButton.buttonFaceDisabled == null) {
                guiButton.forceDisabledDisplay = true;
                guiButton.buttonFaceDisabled = guiButton.buttonFaceActive;
            }
            if (this.name == null) {
                this.name = 'button' + this.tag.toString();
            }
            guiButton.spriteData = new createjs.SpriteSheet(guiButton.spriteFrames);
        }
    }

    guiButton.createButton = function () {
        var spriteFrame,
            buttonSize,
            buttonColor;

        if (this.disabled) {
            spriteFrame = this.buttonBaseDisabled;
        } else {
            spriteFrame = this.buttonBaseActive;
        }
        if (this.buttonSprite == null) {
            this.buttonSprite = new createjs.Sprite(this.spriteData, spriteFrame);
            this.buttonSprite.name = "button";
            this.buttonSprite.framerate = 1;
            this.addChild(this.buttonSprite);
        }
        buttonSize = MemoryMatch.getSpriteFrameSize(this.spriteFrames, spriteFrame);
        this.width = buttonSize.width * this.buttonScale;
        this.height = buttonSize.height * this.buttonScale;
        this.buttonSprite.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(0, 0, this.width, this.height));
        this.flashingCounter = 0;
        this.setTransform(0, 0, this.buttonScale, this.buttonScale);
        this.createButtonIcon();
        this.createButtonText();
        if (this.buttonBaseColor != null) {
            buttonColor = MemoryMatch.htmlColorStringToColorArray(this.buttonBaseColor);
            this.buttonColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonColor[0], buttonColor[1], buttonColor[2], 0);
            this.buttonSprite.filters = [this.buttonColorFilter];
            this.buttonSprite.cache(0, 0, buttonSize.width, buttonSize.height);
            if (this.buttonBaseRollOverColor != null) {
                buttonColor = MemoryMatch.htmlColorStringToColorArray(this.buttonBaseRollOverColor);
                this.buttonRollOverColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonColor[0], buttonColor[1], buttonColor[2], 0);
            }
        }
        if ( ! this.disabled) {
            this.setEnabled(true);
            this.handleEvent({type: "rollout"});
        } else {
            this.showEnabled(false);
        }
    };

    guiButton.createButtonText = function () {

        // this logic assumes the icon was dealt with first, so we can position text based on the icon position

        var buttonText = new createjs.Text(this.text, MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor),
            lineHeight = buttonText.getMeasuredLineHeight();

        if (this.iconSprite == null) {
            buttonText.textAlign = "center";
            buttonText.x = this.width * 0.5;
            buttonText.maxWidth = this.width;
        } else {
            buttonText.textAlign = "left";
            buttonText.x = this.iconSprite.x + this.iconSprite.width;
            buttonText.maxWidth = this.width - this.iconSprite.width;
        }
        buttonText.y = (this.height - lineHeight) * 0.5;
        buttonText.visible = true;
        buttonText.name = "buttonText";
        if (this.addTextShadow) {
            if (this.shadowSource == null) {
                this.shadowSource = new createjs.Shadow("#000000", 2, 2, 10);
            }
        }
        buttonText.shadow = this.shadowSource;
        this.addChild(buttonText);
    };

    guiButton.setButtonText = function (newText) {
        var buttonText = this.getChildByName("buttonText");

        this.text = newText;
        if ( buttonText == null) {
            this.createButtonText();
        } else {
            buttonText.text = this.text;
        }
    };

    guiButton.setText = function (text) {
        this.setButtonText(text);
    };

    guiButton.createButtonIcon = function () {
        var icon,
            spriteSize,
            x,
            y;

        if (this.iconSprite == null && this.buttonFaceActive != null) {
            icon = new createjs.Sprite(this.spriteData, this.buttonFaceActive);
            spriteSize = MemoryMatch.getSpriteFrameSize(this.spriteFrames, this.buttonFaceActive);
            icon.framerate = 1;
            icon.name = "buttonIcon";
            y = (this.height - spriteSize.height) * 0.5;
            if (this.text == null) {
                x = (this.width - spriteSize.width) * 0.5
            } else {
                x = 0;
            }
            icon.setTransform(x, y, 1, 1);
            icon.width = spriteSize.width;
            icon.height = spriteSize.height;
            this.addChild(icon);
            this.iconSprite = icon;
        }
    };

    guiButton.setIcon = function (spriteFrame) {
        if (this.iconSprite != null) {
            this.iconSprite.gotoAndStop(spriteFrame);
        }
    };

    guiButton.getSize = function () {
        return {width: this.width, height: this.height};
    };

    guiButton.handleEvent = function (event) {
        var spriteFrameBase,
            spriteFrameIcon,
            eventType = event.type,
            clicked = false;

        switch (eventType) {
            case "click":
                break;
            case "mousedown":
                this._isPressed = true;
                spriteFrameBase = this.buttonBaseDown;
                spriteFrameIcon = this.buttonFaceDown;
                if (this.buttonBaseRollOverColor != null) {
                    this.buttonSprite.filters = [this.buttonRollOverColorFilter];
                    this.buttonSprite.updateCache();
                }
                break;
            case "rollover":
                if (this._isPressed) {
                    spriteFrameBase = this.buttonBaseDown;
                    spriteFrameIcon = this.buttonFaceDown;
                } else {
                    spriteFrameBase = this.buttonBaseOver;
                    spriteFrameIcon = this.buttonFaceOver;
                }
                break;
            case "pressup":
                this._isPressed = false;
                if (this._isOver) {
                    spriteFrameBase = this.buttonBaseOver;
                    spriteFrameIcon = this.buttonFaceOver;
                } else {
                    spriteFrameBase = this.buttonBaseActive;
                    spriteFrameIcon = this.buttonFaceActive;
                }
                if (this.buttonBaseRollOverColor != null && this.buttonBaseColor != null) {
                    this.buttonSprite.filters = [this.buttonColorFilter];
                    this.buttonSprite.updateCache();
                }
                clicked = true;
                break;
            case "rollout":
            default:
                if (this._isPressed) {
                    spriteFrameBase = this.buttonBaseDown;
                    spriteFrameIcon = this.buttonFaceDown;
                } else {
                    spriteFrameBase = this.buttonBaseActive;
                    spriteFrameIcon = this.buttonFaceActive;
                }
                break;
        }
        if (this.buttonSprite != null && spriteFrameBase != null) {
            this.buttonSprite.gotoAndStop(spriteFrameBase);
        }
        if (this.iconSprite != null && spriteFrameIcon != null) {
            this.iconSprite.gotoAndStop(spriteFrameIcon);
        }
        if (this.refreshParent != null && this.refreshParent.refreshCache != null) {
            this.refreshParent.refreshCache();
        }
    };

    guiButton.onClicked = function (event) {
        if (event != null && event.target != null) {
            var that = event.target.parent;
            if (that.callback != null) {
                MemoryMatch.triggerSoundFx("soundTap");
                that.callback(that.name); // fire the callback function and let them know who was clicked
            }
        }
    };

    guiButton.show = function (showFlag) {
        this.visible = showFlag;
    };

    guiButton.enable = function () {
        // show button in the enabled state
        if (this.disabled) {
            this.setEnabled(true);
            this.showEnabled(true);
            this.handleEvent({type: "rollout"});
        }
    };

    guiButton.disable = function () {
        // show button in the disabled state
        this.setEnabled(false);
        this.showEnabled(false);
    };

    guiButton.setEnabled = function (enableFlag) {
        if (enableFlag) {
            this.disabled = false;
            this.cursor = "pointer";
            this.addEventListener("click", this.onClicked);
            this.addEventListener("rollover", this);
            this.addEventListener("rollout", this);
            this.addEventListener("mousedown", this);
            this.addEventListener("pressup", this);
        } else {
            this.disabled = true;
            this.cursor = null;
            this.removeEventListener("click", this.onClicked);
            this.removeEventListener("rollover", this);
            this.removeEventListener("rollout", this);
            this.removeEventListener("mousedown", this);
            this.removeEventListener("pressup", this);
        }
    };

    guiButton.showEnabled = function (enableFlag) {
        var alpha = 1,
            buttonBase,
            buttonFace,
            buttonText = this.getChildByName("buttonText");

        if (enableFlag) {
            buttonBase = this.buttonBaseActive;
            buttonFace = this.buttonFaceActive;
            if (this.forceDisabledDisplay) {
                buttonText = this.getChildByName("buttonText");
            }
        } else {
            if (this.forceDisabledDisplay) {
                alpha = 0.4;
                buttonText = this.getChildByName("buttonText");
            }
            buttonBase = this.buttonBaseDisabled;
            buttonFace = this.buttonFaceDisabled;
        }
        if (this.buttonSprite != null) {
            this.buttonSprite.gotoAndStop(buttonBase);
            this.buttonSprite.alpha = alpha;
        }
        if (this.iconSprite != null) {
            this.iconSprite.gotoAndStop(buttonFace);
            this.iconSprite.alpha = alpha;
        }
        if (buttonText != null) {
            buttonText.alpha = alpha;
        }
    };

    guiButton.setFlashing = function (flashingFlag) {
        this._isFlashing = flashingFlag;
        if (this._isFlashing && this.flashingTimerId == null) {
            this.flashingCounter = 1;
            this.updateFlashing();
        } else if ( ! this._isFlashing) {
            this.flashingCounter = 0;
            if (this.flashingTimerId != null) {
                window.clearTimeout(this.flashingTimerId);
                this.flashingTimerId = null;
            }
        }
    };

    guiButton.updateFlashing = function () {
        var buttonText = this.getChildByName("buttonText"),
            alpha;

        if (this._isFlashing) {
            this.flashingCounter ++;
            alpha = this.flashingCounter % 2 == 0 ? 0.3 : 1.0;
            this.flashingTimerId = window.setTimeout(this.updateFlashing.bind(this), this.flashingInterval);
        } else {
            alpha = 1;
        }
        if (this.iconSprite != null) {
            this.iconSprite.alpha = alpha;
        }
        if (buttonText != null) {
            buttonText.alpha = alpha;
        }
    };

    guiButton.toString = function () {
        return "[GUIButton] name=" + this.name + "; tag=" + this.tag.toString() + "; enabled=" + (this.disabled ? "NO" : "YES");
    };

    guiButton.kill = function () {
        if (this.flashingTimerId != null) {
            window.clearTimeout(this.flashingTimerId);
            this.flashingTimerId = null;
        }
        this.buttonColorFilter = null;
        this.buttonRollOverColorFilter = null;
        this.removeAllEventListeners();
        this.removeAllChildren();
        this.shadowSource = null;
        this.callback = null;
        this.spriteData = null;
        this.iconSprite = null;
        this.text = null;
    };

    guiButton.setParameters(parameters);
    guiButton.createButton();
    return guiButton;
};

/**
 * InfoPopup.js
 *
 * Show a generic popup that can be used for informational or error messages.
 * Construct one of these with a parameters object using this format:
 * {width: 300, height: 90, title: 'Title', message: 'Message', icon: 'iconCards', sound: 'soundAsset', borderColor:'#FFFFFF', backgroundColor: '#FFFFFF', callback: function}
 *
 */
// namespace to MemoryMatch
MemoryMatch = MemoryMatch || {};

(function() {

    'use strict';

    var InfoPopup = function(displayObject, autoStart, parameters) {
        this.setParameters(displayObject, parameters);
        this.buildScreen(autoStart);
    };
    var p = InfoPopup.prototype;

    p.stateCompleteCallback = null;
    p.parentDisplayObject = null;
    p.groupDisplayObject = null;
    p.x = 0;
    p.y = 0;
    p.width = -1;
    p.height = -1;
    p.marginTop = 0;
    p.marginLeft = 0;
    p.centerX = 0;
    p.marginX = 0;
    p.lineHeight = 0;
    p.title = null;
    p.message = null;
    p.icon = null;
    p.sound = null;
    p.displayDuration = 2.5;
    p.fadeTime = 1;
    p.borderColor = MemoryMatch.GameSetup.achievementBorderColor; // '#d640d6';
    p.backgroundColor = MemoryMatch.GameSetup.achievementBackgroundColor; // '#521852';

    p.setParameters = function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        if (parameters !== null) {
            if (parameters.x != null) {
                this.x = parameters.x;
            } else if (this.x < 1) {
                this.x = this.parentDisplayObject.canvas.width * 0.5;
            }
            if (parameters.y != null) {
                this.y = parameters.y;
            } else if (this.y < 1) {
                this.y = this.parentDisplayObject.canvas.height * 0.5;
            }
            if (parameters.width != null) {
                this.width = parameters.width;
            } else if (this.width < 1) {
                this.width = 900;
            }
            this.width *= MemoryMatch.stageScaleFactor;
            if (parameters.height != null) {
                this.height = parameters.height;
            } else if (this.height < 1) {
                this.height = 270;
            }
            this.height *= MemoryMatch.stageScaleFactor;
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.icon != null) {
                this.icon = parameters.icon;
            } else if (this.icon == null) {
                this.icon = null;
            }
            if (parameters.backgroundColor != null) {
                this.backgroundColor = parameters.backgroundColor;
            }
            if (parameters.borderColor != null) {
                this.borderColor = parameters.borderColor;
            }
            if (parameters.sound != null) {
                this.sound = parameters.sound;
            }
            if (parameters.duration != null) {
                this.displayDuration = parameters.duration;
            }
            if (parameters.callback !== null) {
                this.stateCompleteCallback = parameters.callback;
            }
        }
    };

    p.drawBackground = function () {
        var shape = new createjs.Shape();
        shape.x = 0;
        shape.y = 0;
        var graphics = shape.graphics;
        graphics.beginFill(this.backgroundColor);
        graphics.beginStroke(this.borderColor);
        graphics.setStrokeStyle(3);
        graphics.drawRoundRect(0, 0, this.width, this.height, 12);
        this.groupDisplayObject.addChild(shape);
        return shape;
    };

    p.buildScreen = function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.marginTop = 8 * MemoryMatch.stageScaleFactor;
        this.marginLeft = 8 * MemoryMatch.stageScaleFactor;
        this.drawBackground();
        this.setupIcon();
        this.setupTitleText();
        this.setupMessageText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.x, this.y, 1, 1, 0, 0, 0, this.width * 0.5, this.height * 0.5);
        this.groupDisplayObject.visible = true;
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    };

    p.start = function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.closeStartAnimation();
        if (this.sound != null) {
            MemoryMatch.triggerSoundFx(this.sound, {delay: 0});
        }
    };

    p.closeStartAnimation = function () {
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, this.displayDuration * 1000, this.fadeTime * 1000, true, null, this.closeComplete.bind(this));
        animator.showAtBegin = true;
        animator.vAlpha = -1 / (this.fadeTime * MemoryMatch.fps);
        animator.endAlpha = 0;
    };

    p.closeComplete = function () {
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback("close");
        }
        this.killObject();
    };

    p.setupIcon = function () {
        // add the icon on top of the button frame
        if (this.icon != null) {
            var spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            var iconSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, this.icon);
            var iconSprite = new createjs.Sprite(spriteData, this.icon);
            iconSprite.setTransform(this.width * 0.02, (this.height - iconSize.height) * 0.5, 1, 1);
            iconSprite.framerate = 1;
            iconSprite.name = "icon";
            this.groupDisplayObject.addChild(iconSprite);
        }
    };

    p.setupTitleText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.width * 0.5;
        titleTextField.y = this.height * 0.1;
        titleTextField.lineWidth = this.width * 0.8;
        titleTextField.maxWidth = this.width * 0.8;
        titleTextField.name = "title";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupMessageText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(42) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.width * 0.5;
        titleTextField.y = this.height * 0.4;
        titleTextField.lineWidth = this.width * 0.8;
        titleTextField.maxWidth = this.width * 0.8;
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.name = "message";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.isShowing = function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    };

    p.killObject = function () {
        // remove all display objects and object references:
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    };

    MemoryMatch.InfoPopup = InfoPopup;

}());

/**
 * LevelButton.js
 *
 * Level buttons are display object containers that support some unique functionality:
 *   Display the game number
 *   Show number of stars earned
 *   Show best score
 *   Show different states for locked, unlocked, played
 *   Show different states for Challenge levels
 *   ...and act like a button!
 */

MemoryMatch.LevelButton = function (parameters) {
    var levelButton = new createjs.Container();

    levelButton.callback = null;
    levelButton.width = 0;
    levelButton.height = 0;
    levelButton.gameNumber = 0;
    levelButton.landNumber = 0;
    levelButton.starsEarned = 0;
    levelButton.maxStars = 3;
    levelButton.showStarsForChallenge = false;
    levelButton.bestScore = 0;
    levelButton.wasPlayed = false;
    levelButton.isLocked = true;
    levelButton.isChallengeGame = false;
    levelButton.userBeatChallenge = false;
    levelButton.buttonScale = 1.0;
    levelButton.addShadow = false;
    levelButton.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.mapSpritesheetFrames);
    levelButton.shadowSource = null;
    levelButton.nextYPosition = 0;
    levelButton.primaryColor = 'ffffff';
    levelButton.secondaryColor = '000000';
    levelButton.liteColor = 'C0C0C0';
    levelButton.buttonPrimaryColorFilter = null;
    levelButton.buttonSecondaryColorFilter = null;
    levelButton.changeEventNotification = null;


    levelButton.setParameters = function (parameters) {
        if (parameters != null) {
            if (parameters.gameNumber != null) {
                levelButton.gameNumber = parameters.gameNumber;
            }
            if (parameters.landNumber != null) {
                levelButton.landNumber = parameters.landNumber;
            }
            if (parameters.starsEarned != null) {
                levelButton.starsEarned = parameters.starsEarned;
            }
            if (parameters.bestScore != null) {
                levelButton.bestScore = parameters.bestScore;
            }
            if (parameters.wasPlayed != null) {
                levelButton.wasPlayed = parameters.wasPlayed;
            }
            if (parameters.isLocked != null) {
                levelButton.isLocked = parameters.isLocked;
            }
            if (parameters.primaryColor != null) {
                levelButton.primaryColor = parameters.primaryColor;
            }
            if (parameters.secondaryColor != null) {
                levelButton.secondaryColor = parameters.secondaryColor;
            }
            if (parameters.liteColor != null) {
                levelButton.liteColor = parameters.liteColor;
            }
            if (parameters.scale != null) {
                levelButton.buttonScale = parameters.scale;
            }
            if (parameters.addShadow != null) {
                levelButton.addShadow = parameters.addShadow;
                levelButton.shadowSource = new createjs.Shadow("#000000", 2, 2, 10);
            }
            if (parameters.isChallengeGame != null) {
                levelButton.isChallengeGame = parameters.isChallengeGame;
                if (levelButton.isChallengeGame) {
                    levelButton.userBeatChallenge = MemoryMatch.didUserBeatChallenge(levelButton.landNumber);
                }
            }
            if (parameters.callback != null) {
                levelButton.callback = parameters.callback;
            }
            if (parameters.changeEventNotification != null) {
                levelButton.changeEventNotification = parameters.changeEventNotification;
            }
        }
    }

    levelButton.createGameNumberText = function () {
        var gameNumber = this.gameNumber.toString(),
            textColor = this.isChallengeGame ? this.primaryColor : MemoryMatch.GameSetup.mapLevelColor,
            fontSize = this.isChallengeGame ? 56 : 44,
            gameNumberText = new createjs.Text(gameNumber, MemoryMatch.getScaledFontSize(fontSize) + " " + MemoryMatch.GameSetup.guiBoldFontName, textColor),
            button = this.getChildByName('button'),
            textHeight = gameNumberText.getMeasuredLineHeight();

        gameNumberText.textAlign = "center";
        gameNumberText.x = this.width * 0.5;
        gameNumberText.maxWidth = this.width;
        gameNumberText.color = textColor;
        gameNumberText.visible = true;
        gameNumberText.name = "gameNumber";
        if (this.isChallengeGame) {
            gameNumberText.visible = ! this.isLocked && ! this.userBeatChallenge;
            gameNumberText.y = button.y + ((button.height - textHeight) * 0.54);
        } else {
            gameNumberText.visible = ! this.isLocked;
            gameNumberText.y = button.y + ((button.height - textHeight) * 0.6666);
        }
        if (this.addShadow && this.shadowSource != null) {
            gameNumberText.shadow = this.shadowSource.clone();
        }
        this.addChild(gameNumberText);
    };

    levelButton.createBestScoreText = function () {
        var bestScoreText = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.bestScore), MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.mapLevelColor);
        bestScoreText.textAlign = "center";
        bestScoreText.x = this.width * 0.5;
        bestScoreText.y = this.nextYPosition;
        bestScoreText.maxWidth = this.width;
        bestScoreText.visible = ! (this.isLocked || ! this.wasPlayed);
        bestScoreText.name = "bestScore";
        if (this.addShadow && this.shadowSource != null) {
            bestScoreText.shadow = levelButton.shadowSource.clone();
        }
        this.addChild(bestScoreText);
        this.height = bestScoreText.y + (bestScoreText.getMeasuredLineHeight() * 2);
    };

    levelButton.createLockIcon = function () {
        var lockIcon,
            spriteFrame = 'levelSelectLock',
            spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][2],
            spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][3],
            button = this.getChildByName('button'),
            regx = spriteWidth * 0.5,
            regy = spriteHeight * 0.5,
            rotation = 15;

        lockIcon = new createjs.Sprite(this.spriteData, spriteFrame);
        lockIcon.setTransform(this.width * 0.5, button.y + (button.height * 0.5), 1, 1, rotation, 0, 0, regx, regy);
        lockIcon.framerate = 0;
        lockIcon.name = 'lock';
        lockIcon.visible = this.isLocked;
        if (this.isChallengeGame) {
            lockIcon.filters = [this.buttonPrimaryColorFilter];
            lockIcon.cache(0, 0, spriteWidth, spriteHeight);
        }
        this.addChild(lockIcon);
    };

    levelButton.createGemIcon = function () {
        var gemIcon,
            spriteFrame = 'mapAwardLand' + this.landNumber.toString(),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.mapSpritesheetFrames, spriteFrame),
            button = this.getChildByName('button'),
            regx = spriteSize.width * 0.5,
            regy = spriteSize.height * 0.5,
            rotation = 0;

        gemIcon = new createjs.Sprite(this.spriteData, spriteFrame);
        gemIcon.setTransform(this.width * 0.5, button.y + (button.height * 0.5), 1, 1, rotation, 0, 0, regx, regy);
        gemIcon.framerate = 0;
        gemIcon.name = 'award';
        gemIcon.visible = ! this.isLocked && this.userBeatChallenge;
        this.addChild(gemIcon);
    };

    levelButton.createStars = function () {
        var i,
            star,
            spriteFrame = "mapStarUnearned",
            spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][2],
            spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][3],
            regx = spriteWidth * 0.5,
            regy = spriteHeight * 2,
            x,
            y = regy,
            rotation,
            showStar;

        for (i = 0; i < this.maxStars; i ++) {
            if (i < this.starsEarned) {
                spriteFrame = 'mapStarEarned';
            } else {
                spriteFrame = 'mapStarUnearned';
            }
            if (i == 0) {
                rotation = -45;
                x = spriteWidth * 1.5;
            } else if (i == 2) {
                rotation = 45;
            } else {
                rotation = 0;
                x += spriteWidth * 0.05;
            }
            star = new createjs.Sprite(this.spriteData, spriteFrame);
            star.setTransform(x, y, 1, 1, rotation, 0, 0, regx, regy);
            star.framerate = 0;
            star.name = 'star' + (i + 1);
            if (this.isChallengeGame) {
                showStar = ! this.isLocked && this.showStarsForChallenge;
            } else {
                showStar = ! this.isLocked;
            }
            star.visible = showStar;
            this.addChild(star);
        }
        this.nextYPosition = spriteHeight * 1.1;
        this.width = (spriteWidth * 3);
    };

    levelButton.showStars = function (showFlag) {
        var i,
            star,
            showStar;

        for (i = 0; i < this.maxStars; i ++) {
            star = this.getChildByName('star' + (i + 1));
            if (star != null) {
                if (i < this.starsEarned) {
                    star.gotoAndStop('mapStarEarned');
                } else {
                    star.gotoAndStop('mapStarUnearned');
                }
                if (this.isChallengeGame) {
                    showStar = ! this.isLocked && this.showStarsForChallenge;
                } else {
                    showStar = ! this.isLocked;
                }
                star.visible = showStar;
            }
        }
        this.changeEvent();
    };

    levelButton.removeStars = function () {
        var i,
            star;

        for (i = 0; i < this.maxStars; i ++) {
            star = this.getChildByName('star' + i);
            if (star != null) {
                this.removeChild(star);
            }
        }
    };

    levelButton.createButton = function () {
        var spriteFrameBase = null, // a reference sprite frame, they should all be the same size
            spriteFrameRing,
            spriteFrameRingOver,
            spriteFrameCircle,
            gameButton,
            buttonRing,
            rollOverFrame,
            spriteWidth,
            spriteHeight,
            hitArea,
            buttonPrimaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColor),
            buttonSecondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColor);

        this.buttonPrimaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonPrimaryColor[0], buttonPrimaryColor[1], buttonPrimaryColor[2], 0);
        this.buttonSecondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonSecondaryColor[0], buttonSecondaryColor[1], buttonSecondaryColor[2], 0);
        levelButton.createStars();
        if (this.isChallengeGame) {
            spriteFrameBase = 'bossBase';
            spriteFrameCircle = 'bossCircle';
            spriteFrameRing = 'bossRing';
            spriteFrameRingOver = 'bossRingOver';
        } else {
            spriteFrameBase = 'levelSelectCircle';
            spriteFrameRing = 'levelSelectRing';
            spriteFrameRingOver = 'levelSelectRingOver';
            spriteFrameCircle = null;
        }
        spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrameBase][0]][2] * this.buttonScale;
        spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrameBase][0]][3] * this.buttonScale;
        if (this.width < spriteWidth) {
            this.width = spriteWidth;
        }
        gameButton = new createjs.Sprite(this.spriteData, spriteFrameBase);
        gameButton.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        gameButton.framerate = 0;
        gameButton.name = 'button';
        gameButton.filters = [this.buttonSecondaryColorFilter];
        gameButton.cache(0, 0, spriteWidth, spriteHeight);
        gameButton.width = spriteWidth;
        gameButton.height = spriteHeight;
        this.addChildAt(gameButton, 0);
        if (spriteFrameCircle != null) {
            buttonRing = new createjs.Sprite(this.spriteData, spriteFrameCircle);
            buttonRing.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
            buttonRing.framerate = 0;
            buttonRing.name = 'circle';
            buttonRing.visible = ! (this.isLocked || ! this.wasPlayed) || this.isChallengeGame;
            this.addChild(buttonRing);
        }
        buttonRing = new createjs.Sprite(this.spriteData, spriteFrameRing);
        buttonRing.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        buttonRing.framerate = 0;
        buttonRing.name = 'ring';
        if (this.isChallengeGame) {
            buttonRing.filters = [this.buttonPrimaryColorFilter];
            buttonRing.cache(0, 0, spriteWidth, spriteHeight);
        }
        buttonRing.visible = ! (this.isLocked || ! this.wasPlayed) || this.isChallengeGame;
        this.addChild(buttonRing);

        rollOverFrame = new createjs.Sprite(this.spriteData, spriteFrameRingOver);
        rollOverFrame.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        rollOverFrame.visible = false;
        rollOverFrame.name = 'rollover';
        if (this.isChallengeGame) {
            rollOverFrame.filters = [this.buttonPrimaryColorFilter];
            rollOverFrame.cache(0, 0, spriteWidth, spriteHeight);
        }
        this.addChild(rollOverFrame);

        this.nextYPosition += spriteHeight;
        levelButton.createLockIcon();
        if (this.isChallengeGame) {
            levelButton.createGemIcon();
        }
        levelButton.createGameNumberText();
        levelButton.createBestScoreText();
        levelButton.cache(0, 0, this.width, this.height);
        hitArea = new createjs.Shape();
        hitArea.graphics.beginFill("#ff0000").drawRect(0, 0, this.width, this.height);
        levelButton.hitArea = hitArea;
        if ( ! this.isLocked) {
            this.setEnabled(true);
        }
    };

    levelButton.refreshButton = function (parameters) {
        this.setParameters(parameters);
        this.coordinateDisplayInformation();
    };

    levelButton.onLevelSelect = function (event) {
        var that;
        if (event != null && event.target != null) {
            that = event.target;
            if (that.callback == null) {
                that = event.target.parent;
            }
            if (that.callback != null) {
                MemoryMatch.triggerSoundFx("soundTap");
                that.callback(that.gameNumber);
            }
        }
    };

    levelButton.onRollover = function (event) {
        var rollOverFrame = this.getChildByName('rollover'),
            gameNumberText = this.getChildByName('gameNumber');

        if (rollOverFrame != null) {
            rollOverFrame.visible = true;
        }
        if (gameNumberText != null) {
            gameNumberText.color = this.liteColor;
        }
        this.changeEvent();
    };

    levelButton.onRollout = function (event) {
        var rollOverFrame = this.getChildByName('rollover'),
            gameNumberText = this.getChildByName('gameNumber');

        if (rollOverFrame != null) {
            rollOverFrame.visible = false;
        }
        if (gameNumberText != null) {
            gameNumberText.color = this.isChallengeGame ? this.primaryColor : MemoryMatch.GameSetup.mapLevelColor;
        }
        this.changeEvent();
    };

    levelButton.onTouchDown = function (event) {
        if (MemoryMatch.isTouchDevice) {
            this.onRollover(event);
        }
    };

    levelButton.onTouchUp = function (event) {
        if (MemoryMatch.isTouchDevice) {
            this.onRollout(event);
        }
    };

    levelButton.show = function (showFlag) {
        this.visible = showFlag;
        this.changeEvent();
    };

    levelButton.setGameNumber = function (gameNumber) {
        var gameNumberField = this.getChildByName("gameNumber");

        this.gameNumber = gameNumber;
        if (gameNumberField != null) {
            gameNumberField.text = this.gameNumber.toString(); // (this.gameNumber + MemoryMatch.getGameLevelNumberOffset(this.landNumber)).toString();
        }
    };

    levelButton.setStarsEarned = function (numberOfStars) {
        this.showStars(false);
        if (numberOfStars < 0) {
            numberOfStars = 0;
        } else if (numberOfStars > this.maxStars) {
            numberOfStars = this.maxStars;
        }
        this.starsEarned = numberOfStars;
        if (numberOfStars >= 0) {
            this.showStars(true);
        }
    };

    levelButton.setBestScore = function (newScore) {
        this.bestScore = newScore;
        this.coordinateDisplayInformation();
    };

    levelButton.setIsLocked = function (isLocked) {
        this.isLocked = isLocked;
        this.coordinateDisplayInformation();
    };

    levelButton.setWasPlayed = function (wasPlayed) {
        this.wasPlayed = wasPlayed;
        this.coordinateDisplayInformation();
    };

    levelButton.coordinateDisplayInformation = function () {

        // Make sure the level button agrees with the state of the game for this user

        var bestScoreField = this.getChildByName("bestScore"),
            gameNumberText = this.getChildByName("gameNumber"),
            buttonRing = this.getChildByName("ring"),
            lockIcon = this.getChildByName("lock"),
            gemIcon,
            showStarsFlag = false;

        if (this.gameNumber == 1 || this.wasPlayed) {
            this.isLocked = false;
        }
        if (this.isChallengeGame) {
            gemIcon = this.getChildByName("award");
            if (gemIcon != null) {
                gemIcon.visible = false;
            }
        }
        if (this.isLocked) {
            this.setEnabled(false);
            lockIcon.visible = true;
            bestScoreField.visible = false;
            gameNumberText.visible = false;
            buttonRing.visible = false;
        } else {
            this.setEnabled(true);
            lockIcon.visible = false;
            if (this.wasPlayed) {
                if (this.isChallengeGame && this.userBeatChallenge) { // challenge game and user passed challenge
                    if (gemIcon != null) {
                        gemIcon.visible = true;
                        gameNumberText.visible = false;
                    }
                } else {
                    gameNumberText.visible = true;
                }
                bestScoreField.visible = true;
                bestScoreField.text = MemoryMatch.formatNumberWithGroups(this.bestScore);
                buttonRing.visible = true;
                if (this.isChallengeGame) {
                    showStarsFlag = ! this.isLocked && this.showStarsForChallenge;
                } else {
                    showStarsFlag = ! this.isLocked;
                }
            } else {
                gameNumberText.visible = true;
                bestScoreField.visible = false;
                buttonRing.visible = false;
            }
        }
        this.showStars(showStarsFlag);
        if (showStarsFlag) {
            this.setStarsEarned(this.starsEarned);
        }
        this.bestScore = this.bestScore;
        this.changeEvent();
    };

    levelButton.setEnabled = function (enableFlag) {
        if (enableFlag) {
            levelButton.cursor = 'pointer';
            this.addEventListener("click", this.onLevelSelect);
            this.addEventListener("rollover", this.onRollover.bind(this));
            this.addEventListener("rollout", this.onRollout.bind(this));
            this.addEventListener("mousedown", this.onTouchDown.bind(this));
            this.addEventListener("pressup", this.onTouchUp.bind(this));
            this.addEventListener("rollout", this.onTouchUp.bind(this));
        } else {
            levelButton.cursor = null;
            this.removeEventListener("click", this.onLevelSelect);
            this.removeEventListener("rollover", this.onRollover.bind(this));
            this.removeEventListener("rollout", this.onRollout.bind(this));
            this.removeEventListener("mousedown", this.onTouchDown.bind(this));
            this.removeEventListener("pressup", this.onTouchUp.bind(this));
            this.removeEventListener("rollout", this.onTouchUp.bind(this));
        }
    }

    levelButton.kill = function () {
        this.setEnabled(false);
        levelButton.shadowSource = null;
        levelButton.callback = null;
        levelButton.spriteData = null;
        this.removeAllChildren();
    };

    levelButton.toString = function() {
        return "[LevelButton] gameNumber: " + levelButton.gameNumber.toString();
    };

    levelButton.changeEvent = function () {
        this.updateCache();
        if (this.changeEventNotification != null) {
            this.changeEventNotification();
        }
    };

    levelButton.setParameters(parameters);
    levelButton.createButton();
    return levelButton;
};

/**
 * LevelIntroduction.js
 *
 * Introduce a new level. Designed to tell the user how to play the level.
 * This object just layouts out the screen, animates the pieces,
 * and waits for the user to indicate they are ready to play.
 *
 */

MemoryMatch.LevelIntroduction = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    boardContainer: null,
    spriteData: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    isEnabled: false,
    animate: true,
    marginTop: 0,
    marginLeft: 0,
    buttonInstances: null,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    gameId: 0,
    level: 0,
    gameNumber: 0,
    captionTextFontSize: 42,
    timerId: null,
    demoTimer: 0,
    demoAnimationState: 1,


    setup: function (displayObject, stateCompleteCallbackFunction, gameId, gameLevel, gameNumber) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.isEnabled = false;
        this.gameId = gameId;
        this.level = gameLevel;
        this.gameNumber = gameNumber;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        this.setupLayoutForGameId(this.gameId);
        this.setupButtons();
        if (autoStart == undefined) {
            autoStart = false;
        }
        if (animate === undefined) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        var duration = 0.3, // seconds of animation
            animator;

        this.demoAnimationState = 1;
        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            this.scheduleDemoAnimation(1000);
        }
//        this.groupDisplayObject.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
        this.scheduleDemoAnimation(1000);
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        if (this.backgroundSoundInstance != null) {
            this.backgroundSoundInstance.stop();
            this.backgroundSoundInstance = null;
        }
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    close: function () {
        this.isEnabled = false;
        if (this.isShowing()) {
            if (this.stateCompleteCallback !== null) {
                this.stateCompleteCallback(this.closeEventType, this.level, this.gameNumber);
            }
            this.closeStartAnimation();
        }
    },

    onClickHome: function (event) {
        if (MemoryMatch.LevelIntroduction.isEnabled) {
            this.closeEventType = 'home';
            this.close();
        }
    },

    onClickContinue: function (event) {
        if (MemoryMatch.LevelIntroduction.isEnabled) {
            this.closeEventType = 'continue';
            this.close();
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {

        // Show the icon representing the level and the popup title and subtitle

        var titleTextField,
            gameData = MemoryMatch.getGameData(false),
            iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].iconPopup,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon),
            nextY;

        iconSprite.setTransform(this.marginLeft - (spriteSize.width * 0.25), this.marginTop - (spriteSize.height * 0.25), iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";
        this.groupDisplayObject.addChild(iconSprite);

        titleTextField = new createjs.Text(gameData.levelName, MemoryMatch.getScaledFontSize(58) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        nextY = titleTextField.y + (titleTextField.getMeasuredLineHeight() * 2);

        titleTextField = new createjs.Text(gameData.levelIntro, MemoryMatch.getScaledFontSize(46) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = nextY;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupLayoutForGameId: function (gameId) {
        var groupDisplayObject = this.groupDisplayObject,
            levelData = MemoryMatch.GameSetup.levels[this.level - 1],
            tipId;

        // convert game id into a tip id
        tipId = levelData.tipId;
        switch (tipId) {
            case 1:
                this.setupLayoutForConcentration(groupDisplayObject);
                break;
            case 2:
                this.setupLayoutForChains(groupDisplayObject);
                break;
            case 3:
                this.setupLayoutForNemesis(groupDisplayObject);
                break;
            case 4:
                this.setupLayoutForHaystack(groupDisplayObject);
                break;
            default:
                break;
        }
    },

    setupLayoutForConcentration: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = 'Match like cards.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.5, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = 'Clear the board before you run out of misses.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup timer display
        this.setupGameTimerTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.86, middleY);

        // setup caption
        caption = 'Play quickly for extra points.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForChains: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = 'Study the board to remember where all the pairs are located.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Study swatch
        this.showTimerCountdown(groupDisplayObject, this.backgroundWidth * 0.5, middleY);

        // setup caption
        caption = 'You have only a few seconds to study the board.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup 2 chains slots
        this.showChainsPath(groupDisplayObject, this.backgroundWidth * 0.75, middleY, 0.5);

        // setup caption
        caption = 'Find the pairs but you have only a few misses!'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForNemesis: function (groupDisplayObject) {
        // 1. setup 4 cards
        // setup caption
        // 2. setup Misses display
        // setup caption
        // 3. setup winebottle
        // setup caption
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = 'Match like cards.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.5, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = 'Clear the board before you run out of misses.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup Nemesis
        MemoryMatch.Nemesis.layoutNemesisDemo(groupDisplayObject, this.backgroundWidth * 0.88, middleY, 0.3333);

        // setup caption
        caption = 'Each time you miss you lose wine. Don\'t lose all your wine!';
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForHaystack: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = 'Remember the locations of the cards.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Study swatch
        this.showTimerCountdown(groupDisplayObject, this.backgroundWidth * 0.5, middleY);

        // setup caption
        caption = 'You have only a few seconds to study the board.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.8, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = 'Locate the target card before you run out of misses.'
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupMatchCountTextField: function (groupDisplayObject, x, y, width, height) {
        var matchCountLabel,
            matchCountField,
            backgroundShape;

        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRect(0, 0, width, height);
        backgroundShape.alpha = 0.2;
        backgroundShape.setTransform(x, y);
        groupDisplayObject.addChild(backgroundShape);

        matchCountLabel = new createjs.Text("Misses", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountLabel.textAlign = "right";
        matchCountLabel.textBaseline = "middle";
        matchCountLabel.setTransform(x + (width * 0.65), y + (height * 0.5));
        matchCountLabel.maxWidth = width * 0.75;
        groupDisplayObject.addChild(matchCountLabel);

        matchCountField = new createjs.Text("2", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiAlertFontColor);
        matchCountField.textAlign = "left";
        matchCountField.textBaseline = "middle";
        matchCountField.setTransform(x + (width * 0.7), y + (height * 0.55));
        matchCountField.maxWidth = width * 0.25;
        matchCountField.name = 'matchCounter';
        groupDisplayObject.addChild(matchCountField);
    },

    setupGameTimerTextField: function (groupDisplayObject, x, y) {
        var maxFieldWidth = 10 * 22 * MemoryMatch.stageScaleFactor,
            fieldHeight,
            gameTimerField = new createjs.Text("0:00", MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);

        gameTimerField.textAlign = "left";
        gameTimerField.textBaseline = "middle";
        fieldHeight = gameTimerField.getMeasuredLineHeight() * 1.3;
        gameTimerField.setTransform(x, y + fieldHeight)
        gameTimerField.maxWidth = maxFieldWidth;
        gameTimerField.name = 'gameTimer';
        groupDisplayObject.addChild(gameTimerField);
    },

    showTimerCountdown: function (groupDisplayObject, x, y) {

        // this is the "Study" timer

        var timerCountdownGroup,
            message,
            containerWidth,
            containerHeight,
            titleTextField,
            titleTextFieldSize,
            backgroundShape,
            timerTextField,
            timerTextFieldSize,
            timerTextFieldAnimate;

        message = 'Study';
        this.demoTimer = 5;
        titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(32) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = 'center';
        titleTextField.name = 'title';

        timerTextField = new createjs.Text(this.demoTimer.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        timerTextField.textAlign = 'center';
        timerTextField.name = 'studyTimer';

        titleTextFieldSize = titleTextField.getBounds();
        timerTextFieldSize = timerTextField.getBounds();
        containerWidth = Math.max(titleTextFieldSize.width, timerTextFieldSize.width) * 1.2;
        containerHeight = titleTextFieldSize.height + timerTextFieldSize.height * 1.1;
        titleTextField.x = containerWidth * 0.5;
        timerTextField.x = containerWidth * 0.5;
        titleTextField.y = containerHeight * 0.1;
        timerTextField.y = titleTextField.y + titleTextFieldSize.height;

        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRoundRect(0, 0, containerWidth, containerHeight, 8);
        backgroundShape.alpha = 0.2;
        backgroundShape.name = 'background';

        timerCountdownGroup = new createjs.Container();
        timerCountdownGroup.addChild(backgroundShape);
        timerCountdownGroup.addChild(titleTextField);
        timerCountdownGroup.addChild(timerTextField);
        timerCountdownGroup.setTransform(x - (containerWidth * 0.5), y);
        timerCountdownGroup.name = 'studyGroup';
        groupDisplayObject.addChild(timerCountdownGroup);
    },

    showChainsPath: function (groupDisplayObject, x, y, scale) {
        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            numberOfTiles = 2,
            chainsGroup = new createjs.Container(),
            secondaryColor,
            tileColorFilter,
            tileFrame = "chainCardSlot1",
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame),
            tileGap = 0,
            tileHeight,
            tileSpriteSource = new createjs.Sprite(spriteData, tileFrame),
            tileNumberSource = new createjs.Text("1", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor),
            i,
            tileSprite,
            tileText,
            totalHeightRequired = numberOfTiles * (tileSize.height + tileGap);

        tileSpriteSource.framerate = 1;
        tileNumberSource.textAlign = 'center';
        tileNumberSource.textBaseline = 'middle';
        tileHeight = tileSize.height; // the first tile is the tallest, use that for reference since all the other tiles are different heights!
        tileGap = tileHeight * 0.25;
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            tileColorFilter = new createjs.ColorFilter(0.5, 0.5, 0.5, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        }
        for (i = 0; i < numberOfTiles; i ++) {
            tileSprite = tileSpriteSource.clone();
            tileText = tileNumberSource.clone();
            switch (i) {
                case 0:
                    tileFrame = "chainCardSlot1";
                    break;
                case 1:
                    tileFrame = "chainCardSlot2";
                    break;
                default:
                    tileFrame = "chainCardSlot3";
                    break;
            }
            tileSprite.gotoAndStop(tileFrame);
            tileSprite.name = "chainstile" + i;
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame);
            tileSprite.setTransform(tileSize.width * -0.5, (tileHeight + tileGap) * i, 1, 1, 0, 0, 0, 0, 0);
            tileSprite.width = tileSize.width;
            tileSprite.height = tileSize.height;
            if (tileColorFilter != null) {
                tileSprite.filters = [tileColorFilter];
                tileSprite.cache(0, 0, tileSprite.width, tileSprite.height);
            }
            tileText.name = "chainstext" + i;
            tileText.text = (i + 1).toString();
            tileText.setTransform(0, tileSprite.y + (tileSize.height * 0.5), 1, 1, 0, 0, 0, 0, 0);
            chainsGroup.addChild(tileSprite);
            chainsGroup.addChild(tileText);
        }
        chainsGroup.setTransform(x, y - (totalHeightRequired * 0.2), scale, scale, 0, 0, 0, 0, 0);
        groupDisplayObject.addChild(chainsGroup);
        chainsGroup.name = 'chainsGroup';
    },

    showChainsMatches: function (groupDisplayObject, matchesToShow) {

        // display a demo match summary

        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            m,
            x = 0,
            y = 0,
            offset,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            cardFrame = "chainCard",
            cardSize = MemoryMatch.getSpriteFrameSize(spriteFrames, cardFrame),
            cardSpriteName,
            cardSprite,
            tileSprite,
            chainsGroup,
            totalMatchCounter = 0,
            cardSpriteSource = new createjs.Sprite(spriteData, cardFrame),
            animator,
            startAnimationDelay = 250,
            animationDelay;

        chainsGroup = groupDisplayObject.getChildByName('chainsGroup');
        if (chainsGroup == null) {
            return;
        }
        tileSprite = chainsGroup.getChildByName("chainstile0");
        if (tileSprite != null) {
            offset = 0;
            x = tileSprite.x + (tileSprite.width - cardSize.width) * 0.5;
            y = tileSprite.y + (tileSprite.height - cardSize.height) * 0.5;
            for (m = 0; m < matchesToShow; m ++) {
                totalMatchCounter ++;
                cardSpriteName = "chaincard" + totalMatchCounter;
                cardSprite = chainsGroup.getChildByName(cardSpriteName);
                if (cardSprite == null) {
                    cardSprite = cardSpriteSource.clone();
                    cardSprite.name = cardSpriteName;
                    chainsGroup.addChild(cardSprite);
                    cardSprite.visible = false;
                    animationDelay = startAnimationDelay + (100 * m);
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(cardSprite, startAnimationDelay + (100 * m), 0, false, null, null);
                    animator.showAtBegin = true;
                } else {
                    cardSprite.visible = true;
                }
                cardSprite.setTransform(x + offset, y - offset);
                offset += 4 * MemoryMatch.stageScaleFactor;
            }
        }
    },

    clearChainsMatches: function (groupDisplayObject, matchesToShow) {
        var cardSprite,
            chainsGroup;

        chainsGroup = groupDisplayObject.getChildByName('chainsGroup');
        if (chainsGroup == null) {
            return;
        }
        while (matchesToShow > 0) {
            cardSprite = chainsGroup.getChildByName("chaincard" + matchesToShow);
            if (cardSprite != null) {
                chainsGroup.removeChild(cardSprite);
            }
            matchesToShow --;
        }
    },


    setupButtons: function () {

        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonMargin = 0,
            buttonTagCounter = 0,
            totalWidth = (2 * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    flashContinueButton: function () {
        if (this.buttonInstances.length > 1) {
            this.buttonInstances[1].setFlashing(true);
        }
    },

    buildDemoBoard: function (groupDisplayObject, x, y) {

        // Layout 4 demo cards in a 2x2 pattern

        var distanceBetweenCards = MemoryMatch.cardMargin * 4.0,
            columns = 2,
            rows = 2,
            boardScale = 0.25,
            allCardsShuffled = [3, 4, 4, 3],
            boardContainer = new createjs.Container(),
            halfWidthNeeded = ((MemoryMatch.cardWidth + distanceBetweenCards) * columns) * 0.5,
            halfHeightNeeded = ((MemoryMatch.cardHeight + distanceBetweenCards) * rows) * 0.5,
            spriteData,
            cardIndex,
            row,
            column,
            card;

        spriteData = new createjs.SpriteSheet({
            "images": [MemoryMatch.imageSheetImage],
            "frames": {"regX": 0, "regY": 0, "width": MemoryMatch.cardWidth, "height": MemoryMatch.cardHeight, "count": 0}
        });

        cardIndex = 0;
        for (row = 0; row < rows; row ++) {
            for (column = 0; column < columns; column ++) {
                card = MemoryMatch.makeCard(cardIndex, allCardsShuffled[cardIndex], spriteData);
                card.isEnabled = false;
                card.setTransform(column * (MemoryMatch.cardWidth + distanceBetweenCards), row * (MemoryMatch.cardHeight + distanceBetweenCards));
                boardContainer.addChild(card);
                card.showCardDemo();
                cardIndex ++;
            }
        }
        boardContainer.setTransform(x, y, boardScale, boardScale, 0, 0, 0, halfWidthNeeded, halfHeightNeeded);
        groupDisplayObject.addChild(boardContainer);
        this.boardContainer = boardContainer;
    },

    scheduleDemoAnimation: function (delay) {
        this.timerId = window.setTimeout(this.demoAnimationStep.bind(this), delay);
    },

    demoAnimationStep: function () {
        switch (this.gameId) {
            case 2:
                this.demoAnimationStepForHaystack();
                break;
            case 4:
                this.demoAnimationStepForConcentration();
                break;
            case 5:
                this.demoAnimationStepForChains();
                break;
            case 7:
                this.demoAnimationStepForNemesis();
                break;
            default:
                break;
        }
        this.scheduleDemoAnimation(1000);
    },

    demoAnimationStepForConcentration: function () {
        var card,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip 1st card
                card = this.boardContainer.getChildAt(0);
                if (card != null) {
                    card.flip();
                }
                break;
            case 2: // flip 2nd card
                card = this.boardContainer.getChildAt(3);
                if (card != null) {
                    card.flip();
                }
                break;
            case 3: // wait
                break;
            case 4: // flash misses
                card = this.boardContainer.getChildAt(0);
                if (card != null) {
                    card.flipBack();
                }
                card = this.boardContainer.getChildAt(3);
                if (card != null) {
                    card.flipBack();
                }
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 5: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 6: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 7: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('gameTimer');
        if (timerTextField != null) {
            this.demoTimer += 1001;
            if (this.demoTimer > 6000) {
                this.demoTimer = 0;
            }
            timerTextField.text = MemoryMatch.formatTimeAsString(this.demoTimer, true, false);
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForChains: function () {
        var card,
            i,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flip();
                    }
                }
                break;
            case 2: // wait
                break;
            case 3: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flipBack();
                    }
                }
                break;
            case 4: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                this.showChainsMatches(this.groupDisplayObject, 3);
                break;
            case 5: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 6: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 7:
                this.clearChainsMatches(this.groupDisplayObject, 3);
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('studyGroup');
        if (timerTextField != null) {
            timerTextField = timerTextField.getChildByName('studyTimer');
            if (timerTextField != null) {
                this.demoTimer -= 1;
                if (this.demoTimer < 0) {
                    this.demoTimer = 5;
                }
                timerTextField.text = this.demoTimer.toString();
            }
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForNemesis: function () {
        var card,
            misses,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip 1st card
                card = this.boardContainer.getChildAt(2);
                if (card != null) {
                    card.flip();
                }
                break;
            case 2: // flip 2nd card
                card = this.boardContainer.getChildAt(1);
                if (card != null) {
                    card.flip();
                }
                break;
            case 3: // wait
                break;
            case 4: // flash misses
                card = this.boardContainer.getChildAt(1);
                if (card != null) {
                    card.flipBack();
                }
                card = this.boardContainer.getChildAt(2);
                if (card != null) {
                    card.flipBack();
                }
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.2;
                }
                break;
            case 5: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 6: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.2;
                }
                break;
            case 7: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 8: // move Nemesis
            case 9:
            case 10:
            case 11:
            case 12:
                misses = this.demoAnimationState - 7;
                MemoryMatch.Nemesis.moveNemesisCharacterDemo(this.groupDisplayObject, misses);
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForHaystack: function () {
        var card,
            i,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flip();
                    }
                }
                break;
            case 2: // wait
                break;
            case 3: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flipBack();
                    }
                }
                break;
            case 4: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 5: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 6: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('studyGroup');
        if (timerTextField != null) {
            timerTextField = timerTextField.getChildByName('studyTimer');
            if (timerTextField != null) {
                this.demoTimer -= 1;
                if (this.demoTimer < 0) {
                    this.demoTimer = 5;
                }
                timerTextField.text = this.demoTimer.toString();
            }
        }
        this.demoAnimationState ++;
    },

    isShowing: function () {
        return this.groupDisplayObject != null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        var i;

        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.spriteData = null;
        this.boardContainer = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * MainMenu.js
 *
 * Show the main menu screen. This object just layouts out the screen, animates the pieces,
 * and waits for the user to make a choice. The callback is used to indicate which choice was
 * made by the user.
 *
 */

MemoryMatch.MainMenu = {
    stateCompleteCallback: null,
    levelData: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    awardSprite: null,
    spriteData: null,
    mapSpriteFrames: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    width: 0,
    height: 0,
    animate: true,
    connectorShape: null,

    setup: function (displayObject, nextLevelData, stateCompleteCallbackFunction) {
        // use the level data to do any level-specific setup
        this.levelData = nextLevelData;
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.backgroundWidth = displayObject.canvas.width;
        this.backgroundHeight = displayObject.canvas.height;
        this.mapSpriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames;
        this.spriteData = new createjs.SpriteSheet(this.mapSpriteFrames);
    },

    buildScreen: function (autoStart) {
        // layout the map
        this.width = this.parentDisplayObject.canvas.width;
        this.height = this.parentDisplayObject.canvas.height;
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setupBackgroundAndGameLogo();
        this.setupLandImages();
        this.setupAward();
        this.setupLevelButtons();
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
        // The entire Map is cached, so any updates will require a call to updateCache()
        this.groupDisplayObject.setTransform(0, 0, 1, 1);
        if (this.animate) {
            this.groupDisplayObject.alpha = 0;
        }
        this.groupDisplayObject.cache(0, 0, this.width, this.height);
    },

    start: function () {

        // begin animation, then wait for user event to end this state and alert callback

        var duration,
            animator;

        if (this.animate) {
            duration = 1; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, 0, false, null, this.onStartFadeInComplete.bind(this));
            animator.endAlpha = 1;
            animator.vAlpha = duration / MemoryMatch.fps;
        }
        if (this.stateCompleteCallback != null) {
            // stateCompleteCallback();
        }
    },

    onStartFadeInComplete: function () {
        if (MemoryMatch.shouldAskUserToBookmarkApp()) {
            var infoPopup = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: MemoryMatch.GameSetup.GUIStrings.bookmarkTitle, message: MemoryMatch.GameSetup.GUIStrings.bookmarkMessage, x: MemoryMatch.stageWidth * 0.5, y: MemoryMatch.stageHeight * 0.09, duration: 5.5, backgroundColor: MemoryMatch.GameSetup.achievementBackgroundColor, borderColor: MemoryMatch.GameSetup.achievementBorderColor});
        }
    },

    onContinue: function (levelNumber) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.MainMenu.stateCompleteCallback != null) {
            MemoryMatch.MainMenu.stateCompleteCallback(levelNumber);
        }
        MemoryMatch.MainMenu.killScreen();
    },

    onClickedAward: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.AwardsPopup.setup(MemoryMatch.stage, null);
        MemoryMatch.AwardsPopup.buildScreen(true, true);
    },

    setupBackgroundAndGameLogo: function () {
        // Show Hero image
        var spriteFrame = 'gameLogo',
            imageSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            position = MemoryMatch.GameSetup.mapLogoPosition,
            spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, spriteFrame);

        if (position == null) {
            position = {x: this.width * 0.5, y: this.height * 0.5};
            imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        } else {
            imageSprite.setTransform(position.x * MemoryMatch.stageScaleFactor, position.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        }
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);
    },

    setupLandImages: function () {
        // Show map parts
        var i,
            mapImage,
            mapPosition,
            imageSprite,
            spriteSize;

        for (i = 0; i < MemoryMatch.GameSetup.levels.length; i ++) {
            mapImage = MemoryMatch.GameSetup.levels[i].mapImage;
            if (mapImage != null && mapImage.length > 0) {
                mapPosition = MemoryMatch.GameSetup.levels[i].mapPosition;
                imageSprite = new createjs.Sprite(this.spriteData, mapImage);
                if (imageSprite != null) {
                    spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, mapImage);
                    imageSprite.setTransform(mapPosition.x * MemoryMatch.stageScaleFactor, mapPosition.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
                    imageSprite.framerate = 0;
                    this.groupDisplayObject.addChild(imageSprite);
                }
            }
        }
        this.showSpecialCrap();
    },

    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            imageSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            awardPosition = MemoryMatch.GameSetup.mapAwardPosition,
            position,
            spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, spriteFrame),
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        if (awardPosition == null) {
            position = {x: ((this.width - spriteSize.width) * 0.5) | 0, y: ((this.height - spriteSize.height) * 0.5) | 0};
        } else {
            position = {x: (awardPosition.x * MemoryMatch.stageScaleFactor) | 0, y: (awardPosition.y * MemoryMatch.stageScaleFactor) | 0};
        }
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, (spriteSize.width * 0.5) | 0, (spriteSize.height * 0.5) | 0);
        imageSprite.framerate = 0;
        imageSprite.cursor = 'pointer';
        imageSprite.addEventListener('click', this.onClickedAward.bind(this));
        this.groupDisplayObject.addChild(imageSprite);
        this.awardSprite = imageSprite;

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= (spriteSize.width * 0.5) | 0;
        position.y -= (spriteSize.height * 0.5) | 0;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(this.spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform((position.x + (gemPosition.x * MemoryMatch.stageScaleFactor)) | 0, (position.y + (gemPosition.y * MemoryMatch.stageScaleFactor)) | 0);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    setupLevelButtons: function (groupDisplayObject) {

        // Each Level button will come from a data array in Setup.js representing the type of object and the
        // center of the rectangle

        var mapLevelPositions = MemoryMatch.GameSetup.mapLevelPositions,
            levelData = MemoryMatch.GameSetup.levels,
            levelMapPosition,
            landIndex,
            landNumber,
            levelIndexLandOffset,
            levelIndex,
            levelNumber,
            levelButton,
            gameNumber,
            starsEarned,
            bestScore,
            wasPlayed,
            isLocked,
            buttonScale,
            primaryColor,
            secondaryColor,
            liteColor,
            gameScoresCollection,
            gameScoreData,
            totalGamesPlayed,
            gamesUnlocked,
            buttonBeforeThisOne;

        if (mapLevelPositions == null || levelData == null) {
            return;
        }
        levelIndexLandOffset = 0;
        totalGamesPlayed = 0;
        for (landIndex = 0; landIndex < levelData.length; landIndex ++) {
            landNumber = landIndex + 1;
            primaryColor = levelData[landIndex].primaryColor;
            secondaryColor = levelData[landIndex].secondaryColor;
            liteColor = levelData[landIndex].liteColor;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(landNumber, "levelScoreCollection");
            gamesUnlocked = gameScoresCollection.length;
            buttonBeforeThisOne = null;
            for (levelIndex = 0; levelIndex < levelData[landIndex].gameCount; levelIndex ++) {
                levelNumber = levelIndex + levelIndexLandOffset + 1;
                gameNumber = levelIndex + 1;
                if (mapLevelPositions[landIndex] != null && mapLevelPositions[landIndex].length > levelIndex) {
                    levelMapPosition = mapLevelPositions[landIndex][levelIndex];
                } else {
                    levelMapPosition = {x: 0, y: 0};
                }
                gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
                if (gameScoreData != null && gameScoreData.playCount > 0) {
                    wasPlayed = true;
                    totalGamesPlayed ++;
                    isLocked = false;
                    bestScore = gameScoreData.bestScore;
                    starsEarned = gameScoreData.starsEarned;
                } else if (gameNumber == gamesUnlocked) {
                    wasPlayed = false;
                    isLocked = false;
                    bestScore = 0;
                    starsEarned = 0;
                } else {
                    wasPlayed = false;
                    isLocked = true;
                    bestScore = 0;
                    starsEarned = 0;
                }
                buttonScale = 1;
                levelButton = MemoryMatch.LevelButton({gameNumber: levelNumber, landNumber: landNumber, starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked, isChallengeGame: false, primaryColor: primaryColor, secondaryColor: secondaryColor, liteColor: liteColor, scale: buttonScale, callback:this.onContinue.bind(this), changeEventNotification:this.changeEvent.bind(this)});
                levelButton.x = levelMapPosition.x * MemoryMatch.stageScaleFactor;
                levelButton.y = levelMapPosition.y * MemoryMatch.stageScaleFactor;
                levelButton.name = this.makeLevelButtonName(landNumber, levelNumber);
                this.groupDisplayObject.addChild(levelButton);
                if (buttonBeforeThisOne != null) {
                    this.connectPath(buttonBeforeThisOne, levelButton);
                }
                buttonBeforeThisOne = levelButton;
            }
            levelNumber ++;
            gameNumber = 99;
            if (mapLevelPositions[landIndex] != null && mapLevelPositions[landIndex].length >= levelIndex) {
                levelMapPosition = mapLevelPositions[landIndex][levelIndex];
            } else {
                levelMapPosition = {x: 0, y: 0};
            }
            gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
            if (gameScoreData != null && gameScoreData.playCount > 0) {
                wasPlayed = true;
                totalGamesPlayed ++;
                isLocked = false;
                bestScore = gameScoreData.bestScore;
                starsEarned = gameScoreData.starsEarned;
            } else if (gameNumber <= gamesUnlocked || gamesUnlocked > levelData[landIndex].gameCount) {
                wasPlayed = false;
                isLocked = false;
                bestScore = 0;
                starsEarned = 0;
            } else {
                wasPlayed = false;
                isLocked = true;
                bestScore = 0;
                starsEarned = 0;
            }
            levelButton = MemoryMatch.LevelButton({gameNumber: levelNumber, landNumber: landNumber, starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked, isChallengeGame: true, primaryColor: primaryColor, secondaryColor: secondaryColor, liteColor: liteColor, scale: buttonScale, callback:this.onContinue.bind(this), changeEventNotification:this.changeEvent.bind(this)});
            levelButton.x = levelMapPosition.x * MemoryMatch.stageScaleFactor;
            levelButton.y = levelMapPosition.y * MemoryMatch.stageScaleFactor;
            levelButton.name = this.makeLevelButtonName(landNumber, levelNumber);
            if (buttonBeforeThisOne != null) {
                this.connectPath(buttonBeforeThisOne, levelButton);
            }
            this.groupDisplayObject.addChild(levelButton);
            levelIndexLandOffset += levelData[landIndex].gameCount + 1;
        }
    },

    refreshButtons: function () {

        // Update the state of all level buttons and the Award

        var levelData = MemoryMatch.GameSetup.levels,
            landIndex,
            landNumber,
            levelIndexLandOffset,
            levelIndex,
            levelNumber,
            levelButton,
            gameNumber,
            starsEarned,
            bestScore,
            wasPlayed,
            isLocked,
            gameScoresCollection,
            gameScoreData,
            totalGamesPlayed,
            gamesUnlocked;

        if (levelData == null || ! this.isShowing()) {
            return;
        }
        levelIndexLandOffset = 0;
        totalGamesPlayed = 0;
        for (landIndex = 0; landIndex < levelData.length; landIndex ++) {
            landNumber = landIndex + 1;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(landNumber, "levelScoreCollection");
            gamesUnlocked = gameScoresCollection.length;
            for (levelIndex = 0; levelIndex < levelData[landIndex].gameCount; levelIndex ++) {
                levelNumber = levelIndex + levelIndexLandOffset + 1;
                gameNumber = levelIndex + 1;
                gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
                if (gameScoreData != null && gameScoreData.playCount > 0) {
                    wasPlayed = true;
                    totalGamesPlayed ++;
                    isLocked = false;
                    bestScore = gameScoreData.bestScore;
                    starsEarned = gameScoreData.starsEarned;
                } else if (gameNumber == gamesUnlocked) {
                    wasPlayed = false;
                    isLocked = false;
                    bestScore = 0;
                    starsEarned = 0;
                } else {
                    wasPlayed = false;
                    isLocked = true;
                    bestScore = 0;
                    starsEarned = 0;
                }
                levelButton = this.groupDisplayObject.getChildByName(this.makeLevelButtonName(landNumber, levelNumber));
                if (levelButton != null) {
                    levelButton.refreshButton({starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked});
                }
            }
            levelNumber ++;
            gameNumber = 99;
            gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
            if (gameScoreData != null && gameScoreData.playCount > 0) {
                wasPlayed = true;
                totalGamesPlayed ++;
                isLocked = false;
                bestScore = gameScoreData.bestScore;
                starsEarned = gameScoreData.starsEarned;
            } else if (gameNumber == gamesUnlocked) {
                wasPlayed = false;
                isLocked = false;
                bestScore = 0;
                starsEarned = 0;
            } else {
                wasPlayed = false;
                isLocked = true;
                bestScore = 0;
                starsEarned = 0;
            }
            levelButton = this.groupDisplayObject.getChildByName(this.makeLevelButtonName(landNumber, levelNumber));
            if (levelButton != null) {
                levelButton.refreshButton({starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked});
            }
            levelIndexLandOffset += levelData[landIndex].gameCount + 1;
        }
        this.showAwardedGems();
        this.groupDisplayObject.updateCache();
    },

    connectPath: function (firstPoint, secondPoint) {
        var lineShape,
            strokeColor;

        if (firstPoint != null && secondPoint != null && firstPoint.x != null && secondPoint.x != null) {
            lineShape = new createjs.Shape();
            strokeColor = MemoryMatch.GameSetup.mapPathColor;
            if (strokeColor == null || strokeColor == '') {
                strokeColor = 'rgba(102,102,102,0.5)';
            }
            lineShape.graphics.beginStroke(strokeColor).setStrokeStyle(12 * MemoryMatch.stageScaleFactor);
            lineShape.graphics.moveTo(firstPoint.x + (firstPoint.width * 0.5), firstPoint.y + (firstPoint.height * 0.5));
            lineShape.graphics.lineTo(secondPoint.x + (secondPoint.width * 0.5), secondPoint.y + (secondPoint.height * 0.5));
            lineShape.graphics.endStroke();
            this.groupDisplayObject.addChildAt(lineShape, this.groupDisplayObject.getChildIndex(firstPoint));
        }
    },

    showSpecialCrap: function () {
        // some levels/maps will require placing special markers and eye candy on the map, do that one-off crap here
        // markerData format is an array of objects {x, y, icon}

        var specialMarkers = MemoryMatch.GameSetup.mapSpecialMarkers,
            markerData,
            markerSprite,
            spriteWidth,
            spriteHeight,
            i;

        if (specialMarkers != null) {
            for (i = 0; i < specialMarkers.length; i ++) {
                markerData = specialMarkers[i];
                if (markerData.icon != null) {
                    markerSprite = new createjs.Sprite(this.spriteData, markerData.icon);
                    spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[markerData.icon][0]][2];
                    spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[markerData.icon][0]][3];
                    markerSprite.setTransform(markerData.x * MemoryMatch.stageScaleFactor, markerData.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteWidth * 0.5, spriteHeight * 0.5);
                    this.groupDisplayObject.addChild(markerSprite);
                }
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject != null && this.groupDisplayObject.visible;
    },

    changeEvent: function () {
        // provide a notification event if a child makes a display change so we can update our cache
        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.updateCache();
        }
    },

    makeLevelButtonName: function (landNumber, levelNumber) {
        return 'land' + landNumber.toString() + ':level' + levelNumber.toString();
    },

    killScreen: function () {
        // remove all display objects and references
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.spriteData = null;
        this.mapSpriteFrames = null;
        this.awardSprite = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.groupDisplayObject = null;
        this.parentDisplayObject = null;
        this.backgroundWidth = 0;
        this.backgroundHeight = 0;
        this.width = 0;
        this.height = 0;
    }
};

/**
 * MessagePopup.js
 *
 * Show a generic popup that can be used for informational or error messages.
 *
 */

MemoryMatch.MessagePopup = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    bgImageScaleX: 1,
    bgImageScaleY: 1,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    domElement: null,
    noscale: false,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setParameters: function (parameters) {
        if (parameters != null) {
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.domElement != null) {
                this.domElement = parameters.domElement;
            }
            if (parameters.closeButton != null) {
                this.closeButton = parameters.closeButton;
            }
            if (parameters.continueButton != null) {
                this.continueButton = parameters.continueButton;
            }
            if (parameters.callback != null) {
                this.stateCompleteCallback = parameters.callback;
            }
            if (parameters.noscale != null) {
                this.noscale = parameters.noscale;
            }
        }
    },

    setup: function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.setParameters(parameters);
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        if (this.domElement == null) {
            this.setupMessageText();
        }
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (this.domElement != null) {
            this.setupDOMElement(); // need to do this after the transformation
        }
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));
        if (animator != null) {
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        }
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(this.closeEventType);
        }
    },

    closeShrink: function () {
        var duration = 0.3; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));
        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        var domElement = this.groupDisplayObject.getChildByName('text'),
            pageElement;

        this.isEnabled = false;
        this.closeEventType = closeEventType;
        if (domElement != null) {
            domElement.visible = false;
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.display = 'none';
            }
        }
        // begin animation, then once close is complete send notification
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("close");
        }
    },

    onClickContinue: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function () {

        // This method will scale the background image to fit the current stage if it is too big.

        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        this.bgImageScaleX = xScale;
        this.bgImageScaleY = yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupDOMElement: function () {
        // Position a DOM element in the center of the popup. Expecting the element to be a div containing what we want to show.
        // Register domElement to its center
        var pageElement = document.getElementById(this.domElement),
            domElement = new createjs.DOMElement(pageElement),
            positionOffset,
            scaleFactorX,
            scaleFactorY,
            x,
            y,
            width,
            height;

        if (domElement != null) {
            domElement.name = 'text';
            width = pageElement.clientWidth;
            height = pageElement.clientHeight;

            // the div was scaled by CSS, we need to determine how much the div was scaled, then center it
            scaleFactorX = MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
            scaleFactorY = MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
            if (MemoryMatch.stageScaleFactor == 0.5) {
                positionOffset = -0.5;
                x = (this.backgroundWidth * positionOffset) | 0;
                y = (this.backgroundHeight * positionOffset) | 0;
            } else if (MemoryMatch.stageScaleFactor > 0.5) {
                positionOffset = -0.415;
                x = (this.backgroundWidth * positionOffset) | 0;
                y = (this.backgroundHeight * positionOffset) | 0;
            } else {
                x = (this.backgroundWidth * -0.52) | 0;
                y = (this.backgroundHeight * -0.48) | 0;
            }
            this.parentDisplayObject.addChild(domElement);
            pageElement.style.display = 'block';
            pageElement.width = this.parentDisplayObject.width;
            pageElement.height = this.parentDisplayObject.height;
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupMessageText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.4;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            buttonTagCounter = 0,
            buttonSize,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        if (this.continueButton) {
            buttonTagCounter ++;
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'gameOverButtonBase');
            gameButton = MemoryMatch.GUIButton({name: "continue", tag: buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
            gameButton.setTransform((this.backgroundWidth - buttonSize.width) * 0.5, this.backgroundHeight * 0.75, buttonScale, buttonScale);
            this.groupDisplayObject.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i,
            pageElement;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        if (this.domElement != null) {
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.visibility = "hidden";
            }
        }
        this.domElement = null;
        this.title = null;
        this.message = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};
/**
 * Nemesis.js
 *
 * Handle all the logic to control the Nemesis Character and tile layout.
 * Use this object in the following interface:
 * 1. layoutNemesisPath will place all Nemesis sprites on the display object
 * 2. moveNemesisCharacter will update the state of the sprites based on number of misses. Typically called when player misses.
 * 3. awakeNemesisCharacter will show an animation when player makes a match or on idle.
 * 4. removeNemesisCharacter when Nemesis games is over and remove sprites from stage
 *
 */

MemoryMatch.Nemesis = {
    nemesisGroupDisplayObject: null,
    parentDisplayObject: null,
    spriteFrameData: null,
    bottleTopFilled: "nemesis1",
    bottleTopEmpty: "nemesis1Empty",
    bottleNeckFilled: "nemesis2",
    bottleNeckEmpty: "nemesis2Empty",
    bottleNeckEmptyEmpty: "nemesis2Empty2",
    bottleSectionFilled: "nemesis3",
    bottleSectionEmpty: "nemesis3Empty",
    bottleSectionEmptyEmpty: "nemesis3Empty2",
    bottleBottomFilled: "nemesis4",
    bottleBottomEmpty: "nemesis4Empty",
    maxNumberOfPieces: 0, // Total bottle size in pieces

    layoutNemesisPath: function (parentDisplayObject) {

        // function to call to initialize and layout the Nemesis tiles and setup the character

        var spriteData,
            missCounter,
            topPieceSize,
            middlePieceSize,
            tileSize,
            nextY,
            i,
            bottleTopSprite,
            bottleNeckSprite,
            bottleMiddleSprite,
            bottleMiddleSpriteCloned,
            bottleBottomSprite,
            numberOfMiddlePieces,
            groupWidth,
            groupCenterX,
            thisGameData,
            gameProgressionData;

        this.parentDisplayObject = parentDisplayObject;
        // find the highest tolerance, make the wine bottle that big
        thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
        if (thisGameData.progression != null && thisGameData.progression.length >= MemoryMatch.gameNumber) {
            this.maxNumberOfPieces = 0;
            gameProgressionData = thisGameData.progression;
            for (i = 0; i < gameProgressionData.length; i ++) {
                if (this.maxNumberOfPieces < gameProgressionData[i].tolerance) {
                    this.maxNumberOfPieces = gameProgressionData[i].tolerance;
                }
            }
        } else {
            this.maxNumberOfPieces = thisGameData.tolerance;
        }
        if (this.maxNumberOfPieces == null || this.maxNumberOfPieces < 3) {
            this.maxNumberOfPieces = 3;
        }
        this.spriteFrameData = MemoryMatch.GameSetup.guiSpritesheet2Frames;
        spriteData = new createjs.SpriteSheet(this.spriteFrameData);

        if (this.nemesisGroupDisplayObject == null) {
            this.nemesisGroupDisplayObject = new createjs.Container();
            parentDisplayObject.addChild(this.nemesisGroupDisplayObject);
        } else {
            this.nemesisGroupDisplayObject.removeAllChildren();
        }
        numberOfMiddlePieces = this.maxNumberOfPieces - 3;
        nextY = 0;
        missCounter = 1;
        bottleTopSprite = new createjs.Sprite(spriteData, this.bottleTopFilled);
        bottleTopSprite.framerate = 1;
        bottleTopSprite.name = 'miss' + missCounter.toString();
        bottleTopSprite.gotoAndStop(this.bottleTopFilled);
        topPieceSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleTopFilled);

        missCounter ++;
        bottleNeckSprite = new createjs.Sprite(spriteData, this.bottleNeckFilled);
        bottleNeckSprite.framerate = 1;
        bottleNeckSprite.name = 'miss' + missCounter.toString();
        bottleNeckSprite.gotoAndStop(this.bottleNeckFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleNeckFilled);
        groupWidth = tileSize.width; // all remaining pieces have the same width
        groupCenterX = (groupWidth * 0.5) | 0;

        bottleTopSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (topPieceSize.width * 0.5) | 0, 0);
        nextY += topPieceSize.height;
        bottleNeckSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, groupCenterX, 0);
        nextY += tileSize.height;
        this.nemesisGroupDisplayObject.addChild(bottleTopSprite);
        this.nemesisGroupDisplayObject.addChild(bottleNeckSprite);

        bottleMiddleSprite = new createjs.Sprite(spriteData, this.bottleSectionFilled);
        bottleMiddleSprite.framerate = 1;
        bottleMiddleSprite.gotoAndStop(this.bottleSectionFilled);
        middlePieceSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleSectionFilled);
        for (i = 0; i < numberOfMiddlePieces; i ++) {
            missCounter ++;
            if (i == 0) {
                bottleMiddleSpriteCloned = bottleMiddleSprite;
            } else {
                bottleMiddleSpriteCloned = bottleMiddleSprite.clone();
            }
            this.nemesisGroupDisplayObject.addChild(bottleMiddleSpriteCloned);
            bottleMiddleSpriteCloned.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (middlePieceSize.width * 0.5) | 0, 0);
            bottleMiddleSpriteCloned.name = 'miss' + missCounter.toString();
            nextY += middlePieceSize.height;
        }

        missCounter ++;
        bottleBottomSprite = new createjs.Sprite(spriteData, this.bottleBottomFilled);
        bottleBottomSprite.framerate = 1;
        bottleBottomSprite.name = 'miss' + missCounter.toString();
        bottleBottomSprite.gotoAndStop(this.bottleBottomFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleBottomFilled);
        bottleBottomSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (tileSize.width * 0.5) | 0, 0);
        nextY += tileSize.height;
        this.nemesisGroupDisplayObject.addChild(bottleBottomSprite);

        this.nemesisGroupDisplayObject.setTransform((MemoryMatch.stageWidth - tileSize.width - (tileSize.width * 0.14)) | 0, ((MemoryMatch.stageHeight - nextY) * 0.5) | 0, 1, 1, 0, 0, 0, 0, 0);
        this.moveNemesisCharacter();
        MemoryMatch.stageUpdated = true;
    },

    layoutNemesisDemo: function (parentDisplayObject, x, y, scale) {

        // function to call to initialize and layout the Nemesis tiles for demo purposes

        var spriteData,
            spriteFrameData,
            groupDisplayObject,
            missCounter,
            topPieceSize,
            middlePieceSize,
            tileSize,
            nextY,
            i,
            maxNumberOfPieces,
            bottleTopSprite,
            bottleNeckSprite,
            bottleMiddleSprite,
            bottleMiddleSpriteCloned,
            bottleBottomSprite,
            numberOfMiddlePieces,
            groupWidth,
            groupCenterX,
            thisGameData,
            gameProgressionData;

        // find the highest tolerance, make the wine bottle that big
        thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
        if (thisGameData.progression != null && thisGameData.progression.length >= MemoryMatch.gameNumber) {
            maxNumberOfPieces = 0;
            gameProgressionData = thisGameData.progression;
            for (i = 0; i < gameProgressionData.length; i ++) {
                if (maxNumberOfPieces < gameProgressionData[i].tolerance) {
                    maxNumberOfPieces = gameProgressionData[i].tolerance;
                }
            }
        } else {
            maxNumberOfPieces = thisGameData.tolerance;
        }
        if (maxNumberOfPieces == null || maxNumberOfPieces < 3) {
            maxNumberOfPieces = 3;
        }
        spriteFrameData = MemoryMatch.GameSetup.guiSpritesheet2Frames;
        spriteData = new createjs.SpriteSheet(spriteFrameData);

        groupDisplayObject = new createjs.Container();
        groupDisplayObject.name = 'nemesisContainer';
        groupDisplayObject.maxNumberOfPieces = maxNumberOfPieces;
        numberOfMiddlePieces = maxNumberOfPieces - 3;
        nextY = 0;
        missCounter = 1;
        bottleTopSprite = new createjs.Sprite(spriteData, this.bottleTopFilled);
        bottleTopSprite.framerate = 1;
        bottleTopSprite.name = 'miss' + missCounter.toString();
        bottleTopSprite.gotoAndStop(this.bottleTopFilled);
        topPieceSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleTopFilled);

        missCounter ++;
        bottleNeckSprite = new createjs.Sprite(spriteData, this.bottleNeckFilled);
        bottleNeckSprite.framerate = 1;
        bottleNeckSprite.name = 'miss' + missCounter.toString();
        bottleNeckSprite.gotoAndStop(this.bottleNeckFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleNeckFilled);
        groupWidth = tileSize.width; // all remaining pieces have the same width
        groupCenterX = (groupWidth * 0.5) | 0;

        bottleTopSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (topPieceSize.width * 0.5) | 0, 0);
        nextY += topPieceSize.height;
        bottleNeckSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, groupCenterX, 0);
        nextY += tileSize.height;
        groupDisplayObject.addChild(bottleTopSprite);
        groupDisplayObject.addChild(bottleNeckSprite);

        bottleMiddleSprite = new createjs.Sprite(spriteData, this.bottleSectionFilled);
        bottleMiddleSprite.framerate = 1;
        bottleMiddleSprite.gotoAndStop(this.bottleSectionFilled);
        middlePieceSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleSectionFilled);
        for (i = 0; i < numberOfMiddlePieces; i ++) {
            missCounter ++;
            if (i == 0) {
                bottleMiddleSpriteCloned = bottleMiddleSprite;
            } else {
                bottleMiddleSpriteCloned = bottleMiddleSprite.clone();
            }
            groupDisplayObject.addChild(bottleMiddleSpriteCloned);
            bottleMiddleSpriteCloned.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (middlePieceSize.width * 0.5) | 0, 0);
            bottleMiddleSpriteCloned.name = 'miss' + missCounter.toString();
            nextY += middlePieceSize.height;
        }
        missCounter ++;
        bottleBottomSprite = new createjs.Sprite(spriteData, this.bottleBottomFilled);
        bottleBottomSprite.framerate = 1;
        bottleBottomSprite.name = 'miss' + missCounter.toString();
        bottleBottomSprite.gotoAndStop(this.bottleBottomFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleBottomFilled);
        bottleBottomSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (tileSize.width * 0.5) | 0, 0);
        nextY += tileSize.height;
        groupDisplayObject.addChild(bottleBottomSprite);

        groupDisplayObject.setTransform((x - tileSize.width - (tileSize.width * 0.14)) | 0, y, scale, scale, 0, 0, 0, 0, nextY * 0.5);
        parentDisplayObject.addChild(groupDisplayObject);
    },

    moveNemesisCharacter: function () {

        // function called when the Nemesis character should advance.
        // Based on number of misses update all the sections.

        var spritePiece,
            emptyPieces = this.maxNumberOfPieces - MemoryMatch.levelTolerance + MemoryMatch.missCount,
            nextFrame,
            i;

        for (i = 1; i <= this.maxNumberOfPieces; i ++) {
            spritePiece = this.nemesisGroupDisplayObject.getChildByName('miss' + i.toString());
            if (spritePiece != null) {
                if (i <= emptyPieces) { // set to empty
                    if (i == 1) { // top
                        nextFrame = this.bottleTopEmpty;
                    } else if (i == 2) { // neck
                        if (emptyPieces > i) {
                            nextFrame = this.bottleNeckEmptyEmpty;
                        } else {
                            nextFrame = this.bottleNeckEmpty;
                        }
                    } else if (i == this.maxNumberOfPieces) { // bottom
                        nextFrame = this.bottleBottomEmpty;
                    } else { // middle
                        if (emptyPieces > i) {
                            nextFrame = this.bottleSectionEmptyEmpty;
                        } else {
                            nextFrame = this.bottleSectionEmpty;
                        }
                    }
                } else {
                    if (i == 1) { // top
                        nextFrame = this.bottleTopFilled;
                    } else if (i == 2) { // neck
                        nextFrame = this.bottleNeckFilled;
                    } else if (i == this.maxNumberOfPieces) { // bottom
                        nextFrame = this.bottleBottomFilled;
                    } else { // middle
                        nextFrame = this.bottleSectionFilled;
                    }
                }
            }
            spritePiece.gotoAndStop(nextFrame);
        }
    },

    moveNemesisCharacterDemo: function (parentDisplayObject, missCount) {

        // function called when the Nemesis character should advance.
        // Based on number of misses update all the sections.

        var spritePiece,
            groupDisplayObject,
            maxNumberOfPieces,
            emptyPieces,
            nextFrame,
            i;

        if (parentDisplayObject == null) {
            return;
        }
        groupDisplayObject = parentDisplayObject.getChildByName('nemesisContainer');
        if (groupDisplayObject != null) {
            maxNumberOfPieces = groupDisplayObject.maxNumberOfPieces;
            emptyPieces = missCount;
            for (i = 1; i <= maxNumberOfPieces; i ++) {
                spritePiece = groupDisplayObject.getChildByName('miss' + i.toString());
                if (spritePiece != null) {
                    if (i <= emptyPieces) { // set to empty
                        if (i == 1) { // top
                            nextFrame = this.bottleTopEmpty;
                        } else if (i == 2) { // neck
                            if (emptyPieces > i) {
                                nextFrame = this.bottleNeckEmptyEmpty;
                            } else {
                                nextFrame = this.bottleNeckEmpty;
                            }
                        } else if (i == maxNumberOfPieces) { // bottom
                            nextFrame = this.bottleBottomEmpty;
                        } else { // middle
                            if (emptyPieces > i) {
                                nextFrame = this.bottleSectionEmptyEmpty;
                            } else {
                                nextFrame = this.bottleSectionEmpty;
                            }
                        }
                    } else {
                        if (i == 1) { // top
                            nextFrame = this.bottleTopFilled;
                        } else if (i == 2) { // neck
                            nextFrame = this.bottleNeckFilled;
                        } else if (i == maxNumberOfPieces) { // bottom
                            nextFrame = this.bottleBottomFilled;
                        } else { // middle
                            nextFrame = this.bottleSectionFilled;
                        }
                    }
                }
                spritePiece.gotoAndStop(nextFrame);
            }
        }
    },

    awakeNemesisCharacter: function () {

        // function to call to update a Nemesis character animation. Only advance animation if character is in the idle state.

    },

    removeNemesisCharacter: function () {

        // function to call to remove the Nemesis from the stage.

        if (this.nemesisGroupDisplayObject != null) {
            this.spriteFrameData = null;
            this.nemesisGroupDisplayObject.removeAllChildren();
            this.parentDisplayObject.removeChild(this.nemesisGroupDisplayObject);
            this.nemesisCharacterSprite = null;
            this.nemesisGroupDisplayObject = null;
            MemoryMatch.stageUpdated = true;
        }
    },

    moveNemesisCharacterComplete: function () {
        if (this.nemesisCharacterSprite != null) {
            this.nemesisCharacterSprite.gotoAndStop("stand");
            MemoryMatch.stageUpdated = true;
        }
    },

    scale: function(scaleFactor) {
        if (scaleFactor >= 0 && scaleFactor <= 1 && this.nemesisGroupDisplayObject != null) {
            this.nemesisGroupDisplayObject.scaleX = scaleFactor;
            this.nemesisGroupDisplayObject.scaleY = scaleFactor;
        }
    }
};

/**
 * SharePopup.js
 *
 * Show a share popup:
 * Allow user to pick a network to share game
 *
 */

MemoryMatch.SharePopup = {
    shareNetworks: [{id: 'facebook', icon: 'facebook-icon'}, {id: 'twitter', icon: 'twitter-icon'}, {id: 'googleplus', icon: 'googleplus-icon'}],
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    domElementEmailForm: null,
    noscale: false,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    shareMessage: null,


    setParameters: function (parameters) {
        if (parameters != null) {
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.domElementEmailForm != null) {
                this.domElementEmailForm = parameters.domElementEmailForm;
            }
            if (parameters.closeButton != null) {
                this.closeButton = parameters.closeButton;
            }
            if (parameters.continueButton != null) {
                this.continueButton = parameters.continueButton;
            }
            if (parameters.callback != null) {
                this.stateCompleteCallback = parameters.callback;
            }
            if (parameters.noscale != null) {
                this.noscale = parameters.noscale;
            }
            if (parameters.shareMessage != null) {
                this.shareMessage = parameters.shareMessage;
            }
        }
    },

    setup: function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.setParameters(parameters);
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        if (this.domElement == null) {
            this.setupMessageText();
        }
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        if (animator != null) {
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        }
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(this.closeEventType);
        }
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        var domElement = this.groupDisplayObject.getChildByName(this.domElementEmailForm);

        this.isEnabled = false;
        this.closeEventType = closeEventType;
        if (domElement != null) {
            domElement.visible = false;
        }
        // begin animation, then once close is complete send notification
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            this.closePopup("close");
        }
    },

    onClickNetworkButton: function (networkId) {
        var parameters;

        if (this.isEnabled) {
            this.isEnabled = false; // do not allow clicking any other button until this completes
            parameters = {
                facebookAppId: MemoryMatch.GameSetup.facebookAppId
            };
            enginesisSession.ShareHelper.initialize(networkId, parameters, this.onNetworkInitializeComplete.bind(this));
        }
    },

    onClickSend: function () {
        var name,
            fromEmail,
            toEmail,
            message,
            parameters,
            isOKToSend;

        isOKToSend = false;
        name = document.getElementById('fromname').value;
        fromEmail = document.getElementById('fromemail').value;
        toEmail = document.getElementById('toemail').value;
        message = document.getElementById('message').value;
        if (fromEmail.length < 4) {
            message = 'Please provide your email address as the sender.';
        } else if (toEmail.length < 4) {
            message = 'Please provide the email address of a recipient.';
        } else if ( ! MemoryMatch.isValidEmail(fromEmail)) {
            message = 'Please provide a valid sender email address.';
        } else if ( ! MemoryMatch.isValidEmail(toEmail)) {
            message = 'Please provide a valid email address of a recipient.';
        } else {
            isOKToSend = true;
        }
        if (isOKToSend) {
            document.getElementById('errorMessage').innerText = '';
            MemoryMatch.UserData.updateUser(-1, name, null, fromEmail, null);
            MemoryMatch.UserData.flush();
            document.getElementById('toemail').value = '';
            parameters = {
                fromName: name,
                fromEmail: fromEmail,
                toEmail: toEmail,
                message: message,
                picture: null,
                link: null
            };
            enginesisSession.ShareHelper.share('email', parameters, this.onNetworkShareComplete.bind(this));
        } else {
            document.getElementById('errorMessage').innerText = message;
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onNetworkInitializeComplete: function (networkId) {
        // the requested network was initialized now try to call it
        var parameters;

        if (networkId != 'email') { // hand off to the network to ask the user to share
            parameters = {
                description: '',
                title: MemoryMatch.GameSetup.gameTitle,
                caption: MemoryMatch.GameSetup.gameSubTitle,
                picture: MemoryMatch.GameSetup.promoImage,
                socialHashTags: MemoryMatch.GameSetup.socialHashTag,
                viaId: MemoryMatch.GameSetup.twitterId,
                link: MemoryMatch.GameSetup.gameLink
            };
            if (this.shareMessage != null) {
                parameters.description = this.shareMessage;
            } else {
                parameters.description = MemoryMatch.GameSetup.gameSubTitle;
            }
            enginesisSession.ShareHelper.share(networkId, parameters, this.onNetworkShareComplete.bind(this));
//            this.closePopup("continue"); // if user cancels we will never know!
        } else { // we need to prompt the user for the share info
            this.showEmailForm();
        }
    },

    onNetworkShareComplete: function (networkId) {
        // the requested share is done
        this.closePopup("continue");
    },

    showBackgroundImage: function () {

        // This method will scale the background image to fit the current stage if it is too big.

        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupDOMElement: function (domElementId) {
        // Position a DOM element in the center of the popup. Expecting the element to be a div containing what we want to show.
        // Register domElement to its center
        var pageElement = document.getElementById(domElementId),
            domElement,
            scaleFactorX,
            scaleFactorY,
            x,
            y,
            width,
            height;

        if (pageElement != null) {
            domElement = new createjs.DOMElement(pageElement)
            if (domElement != null) {
                domElement.name = domElementId;
                width = pageElement.clientWidth;
                height = pageElement.clientHeight;
                // the div is independent of the CSS container to we need to center it and scale it based on where the background is placed
                if (MemoryMatch.stageScaleFactor == 0.5) {
                    scaleFactorX = 1;
                    x = width * -0.12;
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * (-0.5 * scaleFactorX));
                } else if (MemoryMatch.stageScaleFactor < 0.5) {
//                    scaleFactorX = 0.8; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
//                    scaleFactorY = 0.8; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
                    scaleFactorX = 0.8;
                    x = width * 0.05; // Math.floor((MemoryMatch.stageWidth - width) * 0.5);
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * 0.5);
                } else {
//                    scaleFactorX = 1; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
//                    scaleFactorY = 1; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
//                    x = Math.floor((MemoryMatch.stageWidth - width) * 0.5 * scaleFactorX);
//                    y = Math.floor((MemoryMatch.stageHeight - height) * 0.5 * scaleFactorX);
                    scaleFactorX = 1; // this.backgroundWidth / width;
                    x = width * -0.12; // Math.floor((MemoryMatch.stageWidth - width) * (-0.5 * scaleFactorX));
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * (-0.5 * scaleFactorX));
                }
                MemoryMatch.debugLog("X,Y=(" + x + "," + y + "); Scale=" + scaleFactorX + "; Client w/h (" + width + "," + height + "); background (" + this.backgroundWidth + "," + this.backgroundHeight + "); stage(" + MemoryMatch.stageWidth + "," + MemoryMatch.stageHeight + ")");
                this.groupDisplayObject.addChildAt(domElement, 0);
                domElement.setTransform(x, y, scaleFactorX, scaleFactorX, 0, 0, 0, 0, 0);
                pageElement = document.getElementById('send');
                if (pageElement != null) {
                    pageElement.onclick = this.onClickSend.bind(this);
                }
            }
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupMessageText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.2;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.name = 'title';
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            shareButton,
            shareButtonsCount,
            shareButtonsStartX,
            shareButtonsMargin,
            shareButtonsWidth = 0,
            buttonTagCounter = 0,
            buttonSize,
            networkId,
            icon,
            i;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        // Show the share buttons
        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            networkId = this.shareNetworks[i].id;
            icon = this.shareNetworks[i].icon;
            buttonTagCounter ++;
            shareButton = MemoryMatch.GUIButton({name: networkId, tag: buttonTagCounter, disabled: false, callback: this.onClickNetworkButton.bind(this), spriteFrames: MemoryMatch.GameSetup.shareIconsFrames, baseUp: icon, baseOver: icon, baseDown: icon});
            if (shareButtonsWidth == 0) {
                // we are assuming all share buttons are the exact same size, otherwise this logic is incorrect.
                buttonSize = gameButton.getSize();
                shareButtonsMargin = Math.floor(buttonSize.width * 0.3333);
                shareButtonsWidth = ((buttonSize.width + shareButtonsMargin) * shareButtonsCount) - shareButtonsMargin;
                shareButtonsStartX = (this.backgroundWidth - shareButtonsWidth) * 0.5;
            }
            shareButton.setTransform(shareButtonsStartX + ((buttonSize.width + shareButtonsMargin) * i), this.backgroundHeight * 0.4, buttonScale, buttonScale);
            this.groupDisplayObject.addChild(shareButton);
            this.buttonInstances.push(shareButton);
        }
    },

    showEmailForm: function () {
        // the email form is a DOM element we need to show it, hide the buttons
        // Hide the share buttons
        var shareButton,
            shareButtonsCount,
            networkId,
            userInfo,
            i;

        this.isEnabled = true;
        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            networkId = this.shareNetworks[i].id;
            shareButton = this.groupDisplayObject.getChildByName(networkId);
            if (shareButton != null) {
                shareButton.visible = false;
            }
        }
        shareButton = this.groupDisplayObject.getChildByName('title');
        if (shareButton != null) {
            shareButton.visible = false;
        }
        if (this.domElementEmailForm != null) {
            this.setupDOMElement(this.domElementEmailForm);
        }
        userInfo = MemoryMatch.UserData.getById();
        document.getElementById('fromname').value = userInfo.userName;
        document.getElementById('fromemail').value = userInfo.email;
        document.getElementById('toemail').value = '';
        document.getElementById('message').value = 'Come play ' + MemoryMatch.GameSetup.gameTitle + '. I really enjoy this game, you will too!';
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i,
            pageElement;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        if (this.domElement != null) {
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.visibility = "hidden";
            }
        }
        this.domElement = null;
        this.title = null;
        this.message = null;
        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.removeAllChildren();
            this.parentDisplayObject.removeChild(this.groupDisplayObject);
            this.groupDisplayObject = null;
        }
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.parentDisplayObject = null;
    }
};
/**
 * UserData.js
 *
 * This object manages the user data. Data is organized by a user id and it is
 * a structured object for a specific game instance. This helps separate the API
 * interface from the actual data organization.
 *
 * Features:
 *   userDataObject: an object of key/value pairs held on behalf of the userId.
 *      .userId = internal, unique, id of the user
 *      .userName = name assigned to the user
 *      .password = users password to access the data record
 *      .email = users email address
 *      .ageCheck = true indicates use is over 13, false otherwise
 *      .. the app will add additional data items to this object e.g. userDataObject['myItem'] = myValue;
 *   levelDataArray: an array of level data, the index being the level number (- 1, e.g. level 1 is index 0) the data being an object.
 *   userAchievements: an array of earned achievements
 *   userTips: an array of seen/unseen tips, each item is a flag (true=seen, false=unseen) indexed by tipId - 1 (e.g. tip # 1 is index 0)
 */

MemoryMatch.UserData = {
    userDataCollection: null,
    currentUser: null,
    dataUpdatedFlag: false,
    dataLoadedFromStorage: false,
    dataLoadedFromServer: false,

    addUser: function (userId, userName, password, email, ageCheck) {
        var userDataObject;

        if (this.userDataCollection == null) {
            this.userDataCollection = [];
        }
        if (userId == null || userId < 1) {
            userId = this.getNextUserId();
        }
        userDataObject = this.getById(userId);
        if (userDataObject == null) {
            userDataObject = {userId: userId, userName: userName, password: password, email: email, ageCheck: ageCheck, userDataObject: {}, levelDataArray: [], userAchievements: [], userTips: []};
            this.userDataCollection.push(userDataObject);
            this.dataUpdatedFlag = true;
        } else {
            userDataObject.userName = userName;
            userDataObject.password = password;
            userDataObject.email = email;
            userDataObject.ageCheck = ageCheck;
            this.dataUpdatedFlag = true;
        }
        this.sync();
        if (this.currentUser == null) {
            this.currentUser = userDataObject;
        }
        return userDataObject;
    },

    updateUser: function (userId, userName, password, email, ageCheck) {
        var userDataObject;

        if (userId == undefined || userId == null || userId < 1) {
            userId = this.getCurrentUserId();
        }
        userDataObject = this.getById(userId);
        if (userDataObject == null) {
            if (userName == null) {
                userName = '';
            }
            if (password == null) {
                password = '';
            }
            if (email == null) {
                email = '';
            }
            if (ageCheck == null) {
                ageCheck = false;
            }
            userDataObject = this.addUser(userId, userName, password, email, ageCheck);
        } else {
            if (userName != null) {
                userDataObject.userName = userName;
            }
            if (password != null) {
                userDataObject.password = password;
            }
            if (email != null) {
                userDataObject.email = email;
            }
            if (ageCheck != null) {
                userDataObject.ageCheck = ageCheck;
            }
            this.dataUpdatedFlag = true;
        }
        return userDataObject;
    },

    deleteUser: function (userId) {
        var i,
            userExists = false,
            userDataObject;

        if (this.currentUser === userDataObject) {
            this.currentUser = null;
        }
        if (this.userDataCollection !== null && this.userDataCollection.length > 0 && userId !== null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId === userDataObject.userId) {
                    userExists = true;
                    if (this.currentUser == userDataObject) {
                        this.currentUser = null;
                    }
                    break;
                }
            }
            if (userExists) {
                this.userDataCollection.splice(i, 1);
                this.dataUpdatedFlag = true;
            }
        }
        return userExists;
    },

    getById: function (userId) {
        var i,
            userDataObject,
            returnThisData = null;

        if (userId == undefined || userId == null || userId < 1) {
            userId = this.getCurrentUserId();
        }
        if (this.userDataCollection != null && this.userDataCollection.length > 0 && userId != null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId == userDataObject.userId) {
                    returnThisData = userDataObject;
                    break;
                }
            }
        }
        return returnThisData;
    },

    getByName: function (userName) {
        var i,
            userDataObject,
            returnThisData = null;

        if (this.userDataCollection != null && this.userDataCollection.length > 0 && userName != null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userName == userDataObject.userName) {
                    returnThisData = userDataObject;
                    break;
                }
            }
        }
        return returnThisData;
    },

    getNextUserId: function () {
        var i,
            userId = 0,
            userDataObject;

        if (this.userDataCollection != null && this.userDataCollection.length > 0) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId < userDataObject.userId) {
                    userId = userDataObject.userId;
                }
            }
        }
        return ++ userId;
    },

    count: function () {
        return this.userDataCollection.length;
    },

    setCurrentUser: function (userId) {
        this.currentUser = this.getById(userId);
        return this.currentUser;
    },

    getCurrentUserId: function () {
        if (this.currentUser === null) {
            this.setCurrentUser(1);
        }
        return this.currentUser.userId;
    },

    setUserDataObject: function (userDataObject) {
        if (this.currentUser != null) {
            this.currentUser.userDataObject = userDataObject;
            this.dataUpdatedFlag = true;
        }
        return userDataObject;
    },

    getUserDataObject: function () {
        var userDataObject = null;
        if (this.currentUser !== null) {
            userDataObject = this.currentUser.userDataObject;
            if (userDataObject === null) {
                userDataObject = {};
            } else if (userDataObject.userAchievements !== null && ! Array.isArray(userDataObject.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                userDataObject.userAchievements = [];
                userDataObject.userTips = [];
            }
        }
        return userDataObject;
    },

    setUserDataItem: function (itemKey, itemValue) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userDataObject !== null) {
            this.currentUser.userDataObject[itemKey] = itemValue;
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    getUserDataItem: function (itemKey) {
        var itemValue = null;
        if (this.currentUser != null && this.currentUser.userDataObject != null) {
            itemValue = this.currentUser.userDataObject[itemKey];
        }
        return itemValue;
    },

    setLevelDataObject: function (levelNumber, levelDataObject) {
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            this.currentUser.levelDataArray[levelNumber - 1] = levelDataObject;
            this.dataUpdatedFlag = true;
        }
        return levelDataObject;
    },

    getLevelDataObject: function (levelNumber) {
        var levelDataObject = null;
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            levelDataObject = this.currentUser.levelDataArray[levelNumber - 1];
        }
        return levelDataObject;
    },

    setLevelDataItem: function (levelNumber, itemId, itemData) {
        var wasSet = false;
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            if (this.currentUser.levelDataArray[levelNumber - 1] == null) {
                this.currentUser.levelDataArray[levelNumber - 1] = {};
            }
            this.currentUser.levelDataArray[levelNumber - 1][itemId] = itemData;
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    getLevelDataItem: function (levelNumber, itemId) {
        var itemData = null;
        if (this.currentUser !== null && this.currentUser.levelDataArray !== null && levelNumber > 0 && this.currentUser.levelDataArray[levelNumber - 1] !== null) {
            itemData = this.currentUser.levelDataArray[levelNumber - 1][itemId];
        }
        return itemData;
    },

    setUserAchievementArray: function (achievementArray) {
        if (this.currentUser !== null) {
            this.currentUser.userAchievements = achievementArray;
            this.dataUpdatedFlag = true;
        }
        return achievementObject;
    },

    setUserAchievement: function (achievementId) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userAchievements !== null) {
            if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                this.currentUser.userAchievements = [];
            }
            this.currentUser.userAchievements.push(achievementId);
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    isUserAchievementSet: function (achievementId) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userAchievements !== null) {
            if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                this.currentUser.userAchievements = [];
            }
            wasSet = this.currentUser.userAchievements.indexOf(achievementId) !== -1;
        }
        return wasSet;
    },

    getUserAchievements: function () {
        if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
            // Deal with legacy setting this to an object instead of an array
            this.currentUser.userAchievements = [];
        }
        return this.currentUser.userAchievements;
    },

    clearAllUserAchievements: function () {
        this.currentUser.userAchievements = [];
        return this.currentUser.userAchievements;
    },

    setUserTipSeen: function (tipId) {
        var wasSet = false,
            tipIndex = tipId - 1,
            i,
            userTipsArray;

        if (tipIndex < 0) {
            tipIndex = 0;
        }
        if (this.currentUser !== null && this.currentUser.userTips !== null) {
            if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
                this.currentUser.userTips = [];
            }
            userTipsArray = this.currentUser.userTips;
            userTipsArray[tipIndex] = true;
            // Here we make sure there are no gaps in the array
            for (i = 0; i < userTipsArray.length; i ++) {
                if (userTipsArray[i] === undefined) {
                    userTipsArray[i] = false;
                }
            }
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    isUserTipSeen: function (tipId) {
        var wasSeen = false,
            tipIndex = tipId - 1;

        if (this.currentUser !== null && this.currentUser.userTips !== null) {
            if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
                this.currentUser.userTips = [];
            }
            wasSeen = this.currentUser.userTips[tipIndex];
            if (wasSeen === undefined) {
                wasSeen = false;
            }
        }
        return wasSeen;
    },

    getUserTips: function () {
        if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
            this.currentUser.userTips = [];
        }
        return this.currentUser.userTips;
    },

    clearAllUserTips: function () {
        this.currentUser.userTips = [];
        return this.currentUser.userTips;
    },

    sync: function () {
        // synchronize the data with the local storage and the server if connected
        var gameSaveJson;

        if (MemoryMatch.hasHTML5LocalStorage()) {
            gameSaveJson = JSON.stringify(this.userDataCollection);
            window.localStorage[MemoryMatch.getGameKey('userData')] = gameSaveJson;
            this.dataUpdatedFlag = false;
        }
    },

    load: function () {
        // load the data from local storage or the server if connected
        var gameSaveJson,
            wasLoaded = false;

        if (MemoryMatch.hasHTML5LocalStorage()) {
            gameSaveJson = window.localStorage[MemoryMatch.getGameKey('userData')];
            if (gameSaveJson != null && gameSaveJson != "null") {
                this.userDataCollection = JSON.parse(gameSaveJson);
                this.dataUpdatedFlag = false;
                wasLoaded = true;
            }
        }
        return wasLoaded;
    },

    flush: function () {
        // this.debug();
        this.dataUpdatedFlag = true;
        this.sync();
    },

    debug: function () {
        MemoryMatch.debugLog(JSON.stringify(this.userDataCollection));
    }
};
