/**
 * AchievementItem.js
 *
 * Build a display object representing an achievement.
 * An achievement item displays an icon, title, description, and points value
 * Construct one of these with a parameters object using this format:
 * {achievementId: 1, width: 300, height: 90, title: 'Title', message: 'Message', icon: 'iconCards', sound: 'soundAsset', borderColor:'#FFFFFF', backgroundColor: '#FFFFFF', callback: function}
 *
 */
// namespace to MemoryMatch
MemoryMatch = MemoryMatch || {};

(function() {

    'use strict';

    var AchievementItem = function(displayObject, parameters) {
        this.setParameters(displayObject, parameters);
        this.buildItem();
    };
    var p = AchievementItem.prototype;

    p.parentDisplayObject = null;
    p.groupDisplayObject = null;
    p.achievementId = null;
    p.x = 0;
    p.y = 0;
    p.width = -1;
    p.height = -1;
    p.marginTop = 0;
    p.marginLeft = 0;
    p.centerX = 0;
    p.marginX = 0;
    p.lineHeight = 0;
    p.title = null;
    p.message = null;
    p.value = null;
    p.icon = null;
    p.sound = null;
    p.borderColor = MemoryMatch.GameSetup.achievementBorderColor;
    p.backgroundColor = MemoryMatch.GameSetup.achievementBackgroundColor;
    p.fontColorEarned = MemoryMatch.GameSetup.achievementFontColorEarned;
    p.fontColorUnearned = MemoryMatch.GameSetup.achievementFontColorUnearned;
    p.autoClose = false;
    p.earned = true;

    p.setParameters = function (displayObject, parameters) {
        var achievementInfo;

        this.parentDisplayObject = displayObject;
        if (parameters !== null) {
            if (parameters.achievementId !== null) {
                this.achievementId = parameters.achievementId;
                achievementInfo = this.getAchievementInfo(this.achievementId);
                if (achievementInfo != null) {
                    this.title = achievementInfo.name;
                    this.message = achievementInfo.description;
                    this.icon = achievementInfo.icon;
                    this.value = achievementInfo.value;
                }
            }
            if (parameters.width != null) {
                this.width = parameters.width;
            } else if (this.width < 1) {
                this.width = (920 * MemoryMatch.stageScaleFactor) | 0;
            }
            if (parameters.height != null) {
                this.height = parameters.height;
            } else if (this.height < 1) {
                this.height = (290 * MemoryMatch.stageScaleFactor) | 0;
            }
            if (parameters.x != null) {
                this.x = parameters.x;
            } else if (this.x < 1) {
                this.x = (this.width * 0.5) | 0;
            }
            if (parameters.y != null) {
                this.y = parameters.y;
            } else if (this.y < 1) {
                this.y = this.parentDisplayObject.canvas.height - this.height;
            }
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title === null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message === null) {
                this.message = "";
            }
            if (parameters.value != null) {
                this.value = parameters.value;
            }
            if (parameters.icon != null) {
                this.icon = parameters.icon;
            } else if (this.icon === null) {
                this.icon = null;
            }
            if (parameters.backgroundColor != null) {
                this.backgroundColor = parameters.backgroundColor;
            }
            if (parameters.borderColor != null) {
                this.borderColor = parameters.borderColor;
            }
            if (parameters.sound != null) {
                this.sound = parameters.sound;
            }
            if (parameters.autoClose != null) {
                this.autoClose = parameters.autoClose;
            }
            if (parameters.earned != null) {
                this.earned = parameters.earned;
            }
        }
    };

    p.getAchievementInfo = function (achievementId) {
        return MemoryMatch.getAchievementInfo(achievementId);
    };

    p.getBounds = function () {
        return this.groupDisplayObject.getBounds();
    }

    p.buildItem = function () {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.marginTop = (8 * MemoryMatch.stageScaleFactor) | 0;
        this.marginLeft = (8 * MemoryMatch.stageScaleFactor) | 0;
        this.drawBackground();
        this.setupIcon();
        this.setupTitleText();
        this.setupDescriptionText();
        this.setupValueText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.x, this.y, 1, 1, 0, 0, 0, (this.width * 0.5) | 0, (this.height * 0.5) | 0);
        this.groupDisplayObject.visible = true;
        if (this.autoClose) {
//            this.closeStartAnimation();
            window.setTimeout(this.closeStartAnimation.bind(this), 500);
        }
    };

    p.drawBackground = function () {
        var shape = new createjs.Shape();
        shape.x = 0;
        shape.y = 0;
        var graphics = shape.graphics;
        graphics.beginFill(this.backgroundColor);
        graphics.beginStroke(this.borderColor);
        graphics.setStrokeStyle(1);
        graphics.drawRoundRect(0, 0, this.width, this.height, 12);
        this.groupDisplayObject.addChild(shape);
        this.groupDisplayObject.setBounds(0, 0, this.width, this.height);
        return shape;
    };

    p.setupIcon = function () {
        // add the icon on top of the button frame, left-middle justified
        var colorFilter,
            spriteData,
            iconSize,
            iconSprite,
            iconScale = 1;

        if (this.icon != null) {
            spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            iconSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, this.icon);
            iconSprite = new createjs.Sprite(spriteData, this.icon);
            iconSprite.setTransform((this.width * 0.005) | 0, (this.height * 0.5) | 0, iconScale, iconScale, 0, 0, 0, 0, (iconSize.height * 0.5) | 0);
            iconSprite.framerate = 1;
            iconSprite.name = "icon";
            if ( ! this.earned) {
                colorFilter = new createjs.ColorFilter(0.3, 0.3, 0.3, 1);
                iconSprite.filters = [colorFilter];
                iconSprite.cache(0, 0, iconSize.width, iconSize.height);
            }
            this.groupDisplayObject.addChild(iconSprite);
        }
    };

    p.setupTitleText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(42) + " " + MemoryMatch.GameSetup.guiBoldFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
        titleTextField.textAlign = "center";
        titleTextField.x = (this.width * 0.5) | 0;
        titleTextField.y = (this.height * 0.1) | 0;
        titleTextField.lineWidth = (this.width * 0.8) | 0;
        titleTextField.maxWidth = (this.width * 0.8) | 0;
        titleTextField.name = "title";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupDescriptionText = function () {
        var titleTextField;
        var message;

        if (this.earned) {
            message = this.message;
        } else {
            message = '???';
        }
        titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(40) + " " + MemoryMatch.GameSetup.guiMediumFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
        titleTextField.textAlign = "left";
        titleTextField.x = (this.width * 0.28) | 0;
        titleTextField.y = (this.height * 0.36) | 0;
        titleTextField.lineWidth = (this.width * 0.72) | 0;
        titleTextField.maxWidth = (this.width * 0.72) | 0;
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.2;
        titleTextField.name = "description";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupValueText = function () {
        var valueTextField;
        if (this.value != null) {
            valueTextField = new createjs.Text(this.value.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiMediumFontName, (this.earned ? this.fontColorEarned : this.fontColorUnearned));
            valueTextField.textAlign = "right";
            valueTextField.x = (this.width * 0.96) | 0;
            valueTextField.y = (this.height * 0.6) | 0;
            valueTextField.lineWidth = (this.width * 0.8) | 0;
            valueTextField.maxWidth = (this.width * 0.8) | 0;
            valueTextField.name = "value";
            this.groupDisplayObject.addChild(valueTextField);
        }
    };

    p.isShowing = function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    };

    p.playSound = function () {
        if (this.sound != null) {
            MemoryMatch.triggerSoundFx(this.sound, {delay: 0});
        }
    };

    p.closeStartAnimation = function () {
        var duration = 2.5; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 250, duration * 1000, true, null, this.closeComplete.bind(this));
        animator.showAtBegin = true;
        animator.vAlpha = -1 / (duration * MemoryMatch.fps);
        animator.endAlpha = 0;
    };

    p.closeComplete = function () {
        this.killObject();
    };

    p.killObject = function () {
        // remove all display objects and object references:
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    };

    MemoryMatch.AchievementItem = AchievementItem;

}());

/**
 * Created by jf on 12/3/13.
 *
 * This is a rudimentary Animation system.
 * Call init to supply information where the sprites will be used.
 * Then call one of the start* functions to emit a specific set of particle behavior.
 * Then call onEnterFrame in the game loop to update the particle sprites.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.AnimationHandler = {
    canvas: null,
    stage: null,
    imgSeq: null,
    spriteTemplateParticles: null,
    spriteTemplateStars: null,
    activeCardQueue: null,
    allParticles: null,
    isQuitPending: false,
    maxWidth: 0,
    maxHeight: 0,


    init: function (_canvas, _stage) {
        var spriteDataParticles = {
            images: [MemoryMatch.assetLoader.getResult("particles")],
            frames: MemoryMatch.GameSetup.particleFrames
            },
            spriteSize;

        this.canvas = _canvas;
        this.stage = _stage;
        this.imgSeq = new Image();
        // set up an animation instance, which we will clone when we need to
        this.spriteTemplateParticles = new createjs.Sprite(new createjs.SpriteSheet(spriteDataParticles));
        this.spriteTemplateStars = new createjs.Sprite(new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames), 'particleStar');
        spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'particleStar');
        this.spriteTemplateStars.regX = spriteSize.width * 0.5;
        this.spriteTemplateStars.regY = spriteSize.height * 0.5;
        this.allParticles = [];
        this.activeCardQueue = [];
        this.maxHeight = this.canvas.height;
        this.maxWidth = this.canvas.width;
    },

    quitPending: function (quitFlag) {
        this.isQuitPending = quitFlag;
    },

    destroy: function () {
        // call this if you are finished and want to dealloc the references
        this.clearAllParticles();
        this.clearAllAnimations();
        this.activeCardQueue = null;
        this.allParticles = null;
        this.spriteTemplateParticles = null;
        this.spriteTemplateStars = null;
        this.canvas = null;
        this.stage = null;
        this.imgSeq = null;
    },

    queueSize: function () {
        return (this.activeCardQueue === null ? 0 : this.activeCardQueue.length) + (this.allParticles === null ? 0 : this.allParticles.length);
    },

    addToAnimationQueue: function (actor, delay, duration, removeFromStage, startFunction, endFunction) {
        // actor: display object to animate
        // delay: ms from now to begin animating
        // duration: ms from begin to end animation
        // removeFromStage: true to kill this object when animation is complete
        // startFunction is called on first tick animation begins (after delay)
        // endFunction is called on last tick when animation ends
        var animationObject = null;

        if (actor == null) {
            return; // Nothing to animate!
        }
        if (delay == null) {
            delay = 0;
        }
        if (removeFromStage == null) {
            removeFromStage = false;
        }
        animationObject = {};
        animationObject.actor = actor;
        animationObject.addTime = Date.now();
        animationObject.startTime = animationObject.addTime + delay;
        animationObject.started = false;
        animationObject.markedForRemoval = false;
        if (duration != null) {
            if (duration == 0) {
                animationObject.endTime = 0;
            } else {
                animationObject.endTime = animationObject.startTime + duration;
            }
        } else {
            animationObject.endTime = 0;
        }
        animationObject.removeFromStage = removeFromStage;
        animationObject.startFunction = startFunction;
        animationObject.endFunction = endFunction;
        this.activeCardQueue.push(animationObject);
        return animationObject;
    },

    updateAnimations: function (deltaTime) {
        // Each object on the queue is expected to be a DisplayObject, Sprite, or Container.
        // Animations Parameters:
        //  .actor        : the display object that is the target of the animation
        //  .addTime      : time stamp this animation was added to the queue
        //  .startTime    : time stamp this animation will begin its animation
        //  .removeFromStage : true object will be removed at endTime, false it will remain in display list
        // Optional parameters, when provided they are processed:
        //  .endTime      : time stamp when this object should be removed from animation queue
        //  .vX           : move object with this X velocity
        //  .endX         : X value at endTime (mitigates rounding errors). If vX is not provided will be used to calc vX.
        //  .vY           : move object with this Y velocity
        //  .endY         : Y value at endTime (mitigates rounding errors). If vY is not provided will be used to calc vY.
        //  .vAlpha       : alpha "velocity" amount of alpha to subtract (- to add) over startTime to endTime
        //  .endAlpha     : alpha value at endTime (mitigates rounding errors)
        //  .vRotation    : rotation "velocity" amount of rotation over startTime to endTime
        //  .endRotation  : rotation value at endTime (mitigates rounding errors)
        //  .vXScale      : amount to scale-X each tick
        //  .endXScale    : scale-X value at endTime (mitigates rounding errors)
        //  .vYScale      : amount to scale-Y each tick
        //  .endYScale    : scale-Y value at endTime (mitigates rounding errors)
        //  .vXSkew       : amount to skew-X each tick
        //  .endXSkew     : skew-X value at endTime (mitigates rounding errors)
        //  .vYSkew       : amount to skew-Y each tick
        //  .endYSkew     : skew-Y value at endTime (mitigates rounding errors)
        //  .endFunction  : function to call at endTime
        //  .startFunction: function to call at startTime
        //  .tickFunction : function to call at each tick
        //  .showAtBegin  : true to show at animation begin, false to hide at animation begin, null to do nothing
        //  .showAtEnd    : true to show at animation end, false to hide at animation end, null to do nothing

        var timeNow = Date.now(),
            objectsToRemove = 0,
            animatingObject = null,
            i,
            keepAnimating,
            isAnimating;

        if (this.isQuitPending) {
            return;
        }
        for (i = 0; i < this.activeCardQueue.length; i ++) {
            animatingObject = this.activeCardQueue[i];
//            MemoryMatch.debugLog("Animating Actor " + i + "; " + animatingObject.actor.name);
            if (timeNow >= animatingObject.startTime) {
                isAnimating = false;
                if ( ! animatingObject.started) {
                    animatingObject.started = true;
                    isAnimating = true;
                    if (animatingObject.showAtBegin != null) {
                        animatingObject.actor.visible = animatingObject.showAtBegin;
                    }
                    if (animatingObject.startFunction != null) {
                        animatingObject.startFunction(animatingObject);
                    }
                }

                // update x,y velocity and position
                if (animatingObject.vX != null && animatingObject.vX != 0) {
                    isAnimating = true;
                    animatingObject.actor.x += animatingObject.vX;
                    if (animatingObject.endX != null && animatingObject.vX != null && animatingObject.vX != 0) {
                        if (animatingObject.vX > 0 && animatingObject.actor.x >= animatingObject.endX) {
                            animatingObject.actor.x = animatingObject.endX;
                            animatingObject.vX = null;
                            animatingObject.endX = null;
                        } else if (animatingObject.vX < 0 && animatingObject.actor.x <= animatingObject.endX) {
                            animatingObject.actor.x = animatingObject.endX;
                            animatingObject.vX = null;
                            animatingObject.endX = null;
                        }
                    }
                }
                if (animatingObject.vY != null && animatingObject.vY != 0) {
                    isAnimating = true;
                    animatingObject.actor.y += animatingObject.vY;
                    if (animatingObject.endY != null && animatingObject.vY != null && animatingObject.vY != 0) {
                        if (animatingObject.vY > 0 && animatingObject.actor.y >= animatingObject.endY) {
                            animatingObject.actor.y = animatingObject.endY;
                            animatingObject.vY = null;
                            animatingObject.endY = null;
                        } else if (animatingObject.vY < 0 && animatingObject.actor.y <= animatingObject.endY) {
                            animatingObject.actor.y = animatingObject.endY;
                            animatingObject.vY = null;
                            animatingObject.endY = null;
                        }
                    }
                }

                // update x,y scale
                if (animatingObject.vXScale != undefined && animatingObject.vXScale != 0) {
                    isAnimating = true;
                    animatingObject.actor.scaleX += animatingObject.vXScale;
                    if (animatingObject.endXScale != undefined) {
                        if (animatingObject.vXScale > 0 && animatingObject.actor.scaleX >= animatingObject.endXScale) {
                            animatingObject.actor.scaleX = animatingObject.endXScale;
                            animatingObject.vXScale = null;
                            animatingObject.endXScale = null;
                        } else if (animatingObject.vXScale < 0 && animatingObject.actor.scaleX <= animatingObject.endXScale) {
                            animatingObject.actor.scaleX = animatingObject.endXScale;
                            animatingObject.vXScale = null;
                            animatingObject.endXScale = null;
                        }
                    }
                }
                if (animatingObject.vYScale != undefined && animatingObject.vYScale != 0) {
                    isAnimating = true;
                    animatingObject.actor.scaleY += animatingObject.vYScale;
                    if (animatingObject.endYScale != undefined) {
                        if (animatingObject.vYScale > 0 && animatingObject.actor.scaleY >= animatingObject.endYScale) {
                            animatingObject.actor.scaleY = animatingObject.endYScale;
                            animatingObject.vYScale = null;
                            animatingObject.endYScale = null;
                        } else if (animatingObject.vYScale < 0 && animatingObject.actor.scaleY <= animatingObject.endYScale) {
                            animatingObject.actor.scaleY = animatingObject.endYScale;
                            animatingObject.vYScale = null;
                            animatingObject.endYScale = null;
                        }
                    }
                }

                // update x,y skew
                if (animatingObject.vYSkew != null && animatingObject.vYSkew != 0) {
                    isAnimating = true;
                    animatingObject.actor.skewY += animatingObject.vYSkew;
                    if (animatingObject.endYSkew != null && animatingObject.vYSkew != null && animatingObject.vYSkew != 0) {
                        if (animatingObject.vYSkew > 0 && animatingObject.actor.skewY >= animatingObject.endYSkew) {
                            animatingObject.actor.skewY = animatingObject.endYSkew;
                            animatingObject.vYSkew = null;
                            animatingObject.endYSkew = null;
                        } else if (animatingObject.vYSkew < 0 && animatingObject.actor.skewY <= animatingObject.endYSkew) {
                            animatingObject.actor.skewY = animatingObject.endYSkew;
                            animatingObject.vYSkew = null;
                            animatingObject.endYSkew = null;
                        }
                    }
                }

                // update rotation
                if (animatingObject.vRotation != null && animatingObject.vRotation != 0) {
                    isAnimating = true;
                    animatingObject.actor.rotation += animatingObject.vRotation;
                    if (animatingObject.endRotation != null && animatingObject.vRotation != null && animatingObject.vRotation != 0) {
                        if (animatingObject.vRotation > 0 && animatingObject.actor.rotation >= animatingObject.endRotation) {
                            animatingObject.actor.rotation = animatingObject.endRotation;
                            animatingObject.vRotation = null;
                            animatingObject.endAlpha = null;
                        } else if (animatingObject.vRotation < 0 && animatingObject.actor.rotation <= animatingObject.endRotation) {
                            animatingObject.actor.rotation = animatingObject.endRotation;
                            animatingObject.vRotation = null;
                            animatingObject.endRotation = null;
                        }
                    }
                }

                // update alpha
                if (animatingObject.vAlpha != null && animatingObject.vAlpha != 0) {
                    isAnimating = true;
                    animatingObject.actor.alpha += animatingObject.vAlpha;
                    if (animatingObject.endAlpha != null && animatingObject.vAlpha != null && animatingObject.vAlpha != 0) {
                        if (animatingObject.vAlpha > 0 && animatingObject.actor.alpha >= animatingObject.endAlpha) {
                            animatingObject.actor.alpha = animatingObject.endAlpha;
                            animatingObject.vAlpha = null;
                            animatingObject.endAlpha = null;
                        } else if (animatingObject.vAlpha < 0 && animatingObject.actor.alpha <= animatingObject.endAlpha) {
                            animatingObject.actor.alpha = animatingObject.endAlpha;
                            animatingObject.vAlpha = null;
                            animatingObject.endAlpha = null;
                        }
                    }
                }

                // call tick function
                if (animatingObject.tickFunction != null) {
                    isAnimating = true;
                    keepAnimating = animatingObject.tickFunction(animatingObject);
                    if ( ! keepAnimating) {
                        animatingObject.markedForRemoval = true;
                    }
                }

                // if the endTime has expired, or there is nothing going on with this object, then remove it from the queue
                if ((animatingObject.endTime > 0 && animatingObject.endTime <= timeNow) || ( ! isAnimating && animatingObject.endTime == 0)) {
                    animatingObject.markedForRemoval = true;
                }
                if (animatingObject.markedForRemoval) {
                    objectsToRemove ++;
                    if (animatingObject.showAtEnd != null) {
                        animatingObject.actor.visible = animatingObject.showAtEnd;
                    }
                    if (animatingObject.endFunction != null) {
                        animatingObject.endFunction(animatingObject.actor);
                    }
                }
            }
        }
        if (objectsToRemove > 0) {
            // go through list backwards and remove objects from activeCardQueue
            for (i = this.activeCardQueue.length - 1; i >= 0; i --) {
                animatingObject = this.activeCardQueue[i];
                if (animatingObject.markedForRemoval) {
                    this.activeCardQueue.splice(i, 1);
                }
            }
        }
        if (isAnimating) {
            MemoryMatch.stageUpdated = true;
        }
    },

    updateParticles: function (event, deltaTime) {
        // loop through all of the active particles

        var i,
            particle,
            numberOfParticles = this.allParticles.length,
            isAnimating = false;

        for (i = numberOfParticles - 1; i >= 0; i --) {
            particle = this.allParticles[i];

            // apply gravity and friction
            if (particle.applyGravity) {
                particle.vY += 0.5;
            } else {
                particle.vY *= particle.friction;
            }
            particle.vX *= particle.friction;
            isAnimating = true;

            // update position, scale, and alpha:
            particle.x += particle.vX;
            particle.y += particle.vY;
            particle.alpha += particle.vA;
            particle.scaleX += particle.vScale;
            particle.scaleY += particle.vScale;
            particle.rotation += particle.vRotation;

            // remove sparkles that are no longer visible or are stalled:
            if (particle.alpha <= 0 || particle.y >= this.maxHeight && particle.vY < 1) {
                this.allParticles.splice(i, 1);
                this.stage.removeChild(particle);
            }

            //bounce sparkles off the bottom
            if (particle.bounce) {
                if (particle.y > this.maxHeight) {
                    particle.vY *= -(Math.random() * 0.4 + 0.4);
                    particle.y -= particle.y % this.maxHeight;
                }
                if (particle.x >= this.maxWidth || particle.x <= 0) {
                    particle.vX *= -1;
                }
            } else {
                if (particle.y < 0 || particle.y > this.maxHeight || particle.x >= this.maxWidth || particle.x <= 0) {
                    particle.vA = 0;
                    particle.alpha = 0;
                }
            }
        }
        if (isAnimating) {
            MemoryMatch.stageUpdated = true;
        }
    },

    onEnterFrame: function (event, deltaTime) {
        if (this.activeCardQueue.length > 0) {
            this.updateAnimations(deltaTime);
        }
        if (this.allParticles.length > 0) {
            this.updateParticles(event, deltaTime);
        }
    },

    startSparklerParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.5;
            particle.vScale = 0.05;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = true;
            particle.friction = 0.95;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 40;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startSplatterParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.8;
            particle.vScale = 0;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = false;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 40;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startSplatterStars: function (numberOfStars, x, y) {
        // create the specified number of particles and send them off in random directions
        var angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfStars; i ++) {
            // clone the original star, so we don't need to set shared properties:
            particle = this.spriteTemplateStars.clone();
            particle.framerate = 0;

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.8;
            particle.vScale = 0;
            particle.vRotation = Math.random() * 30 - 15;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = false;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle = 2 * Math.PI * Math.random();
            v = (Math.random() - 0.5) * 80;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -Math.random() * 0.05 - 0.01;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }
            particle.gotoAndStop('particleStar');
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    startBurstParticles: function (numberOfParticles, x, y) {
        // create the specified number of particles and send them off in a burst
        var angleIncrement = (360 / numberOfParticles) * (Math.PI / 180),
            angle = 0,
            v,
            i,
            particle;

        if (MemoryMatch.gamePaused) {
            return;
        }
        for (i = 0; i < numberOfParticles; i ++) {
            // clone the original particle, so we don't need to set shared properties:
            particle = this.spriteTemplateParticles.clone();

            // set display properties:
            particle.x = x;
            particle.y = y;
            particle.alpha = Math.random() * 0.5 + 0.5;
            particle.scaleX = particle.scaleY = Math.random() + 0.9;
            particle.vScale = 0.02;
            particle.vRotation = Math.random() * 10 - 5;
            particle.compositeOperation = "lighter";
            particle.bounce = false;
            particle.applyGravity = true;
            particle.friction = 0.89;

            // set up velocities for x, y, and alpha:
            angle += angleIncrement;
            v = (0.8 + (Math.random() * 0.2)) * 20;
            particle.vX = Math.cos(angle) * v;
            particle.vY = Math.sin(angle) * v;
            particle.vA = -0.01; // -Math.random() * 0.01 - 0.005;
            if (particle.vX === 0) {
                particle.vX = 0.5;
            }
            if (particle.vY === 0) {
                particle.vY = 0.5;
            }
            if (particle.vA === 0) {
                particle.vA = -0.5;
            }

            // start the animation on a random frame:
            particle.gotoAndPlay(Math.random() * particle.spriteSheet.getNumFrames() | 0);

            // add to the display list:
            this.stage.addChild(particle);
            this.allParticles.push(particle);
        }
    },

    clearAll: function () {
        this.clearAllAnimations();
        this.clearAllParticles();
    },

    clearAllAnimations: function () {
        var i,
            sprite,
            numberOfActiveAnimations = this.activeCardQueue.length;

        for (i = numberOfActiveAnimations - 1; i > 0; i --) {
            sprite = this.activeCardQueue[i].actor;
            this.stage.removeChild(sprite);
        }
        this.activeCardQueue = [];
    },

    clearAllParticles: function () {
        var i,
            particle,
            numberOfActiveParticles = this.allParticles.length;

        for (i = numberOfActiveParticles - 1; i > 0; i --) {
            particle = this.allParticles[i];

            // reset gravity and friction
            particle.vY = 0;
            particle.vX = 0;
            particle.vScale = 0;
            particle.y = -10;
            particle.alpha = 0;
            this.stage.removeChild(particle);
        }
        this.allParticles = [];
    }
};
/**
 * AwardsPopup.js
 *
 * Show the Awards popup showing all earned achievements and other stats.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.AwardsPopup = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    contentDisplayObject: null,
    closeButtonInstance: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    animate: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    stateCompleteCallback: null,
    startYAchievements: 0,
    scrollMask: null,
    scrollOffset: null,
    scrollLimitMin: 0,
    scrollLimitMax: 0,
    scrollButtonSprite: null,
    scrollButtonOffset: null,
    scrollButtonMin: 0,
    scrollButtonMax: 0,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, callback) {
        this.parentDisplayObject = displayObject;
        this.stateCompleteCallback = callback;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.setupBackground();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.06;
        this.contentDisplayObject = new createjs.Container();
        this.setupMask();
        this.setupTitleText();
        this.startYAchievements = Math.floor(this.backgroundHeight * 0.12);
        this.startYAchievements += this.setupAward(0.5, this.startYAchievements);
        this.setupInfoText();
        this.setupAchievements();
        this.setupButtons();
        this.setupScrollBar();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.contentDisplayObject.setTransform(this.backgroundWidth * -0.028, this.backgroundHeight * 0.05);
        this.groupDisplayObject.addChild(this.contentDisplayObject);
        this.scrollLimitMin = this.contentDisplayObject.y;
        if (autoStart === null) {
            autoStart = false;
        }
        if (animate === null) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        var duration,
            animator;

        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            // begin animation, then wait for user event to end this state and alert callback
            duration = 0.3; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        }
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        // begin animation, then once close is complete send notification
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(closeEventType);
        }
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("close");
        }
    },

    onClickContinue: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onScrollMouseDownHandler: function (event) {
        this.scrollOffset = {x:this.contentDisplayObject.x, y:this.contentDisplayObject.y - event.stageY};
    },

    onScrollPressMoveHandler: function (event) {
        var newY = event.stageY + this.scrollOffset.y;

        if (newY > this.scrollLimitMin) {
            newY = this.scrollLimitMin;
        } else if (newY < this.scrollLimitMax) {
            newY = this.scrollLimitMax;
        }
        this.contentDisplayObject.y = newY;
        this.scrollButtonSprite.y = this.scrollButtonMin + (((newY - this.scrollLimitMin) / (this.scrollLimitMax - this.scrollLimitMin)) * (this.scrollButtonMax - this.scrollButtonMin));
    },

    onScrollHandleDown: function (event) {
        this.scrollButtonOffset = {x:this.scrollButtonSprite.x, y:this.scrollButtonSprite.y - event.stageY};
    },

    onScrollHandlePressMove: function (event) {
        var newY = event.stageY + this.scrollButtonOffset.y,
            percentScroll;

        if (newY < this.scrollButtonMin) {
            newY = this.scrollButtonMin;
        } else if (newY > this.scrollButtonMax) {
            newY = this.scrollButtonMax;
        }
        this.scrollButtonSprite.y = newY;
        percentScroll = (newY - this.scrollButtonMin) / (this.scrollButtonMax - this.scrollButtonMin);
        this.contentDisplayObject.y = this.scrollLimitMin + ((this.scrollLimitMax - this.scrollLimitMin) * percentScroll);
    },

    setupBackground: function () {
        // This method will scale the background image to fit the current stage if it is too big.
        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupMask: function () {
        var maskShape = this.groupDisplayObject.addChild(new createjs.Shape()),
            startY = this.marginTop * 3,
            height = this.backgroundHeight - (4 * this.marginTop);

        maskShape.graphics.beginFill("#521852").drawRoundRect(this.marginLeft, startY, this.backgroundWidth - (2.5 * this.marginLeft), height, 8);
        maskShape.alpha = 0.3333;
        maskShape.visible = true;
        maskShape.on("mousedown", this.onScrollMouseDownHandler.bind(this));
        maskShape.on("pressmove", this.onScrollPressMoveHandler.bind(this));
        this.scrollMask = maskShape;
        this.contentDisplayObject.mask = maskShape;
        this.scrollLimitMax = height - startY;
    },

    setupScrollBar: function () {
        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet1Frames,
            scrollBarHandle = 'awardsHandle',
            scrollBarBackground = 'awardsSlider',
            scrollBarSprite,
            scrollButtonSprite,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            barSpriteSize,
            handleSpriteSize,
            x,
            y;

        x = this.marginLeft + this.backgroundWidth - (2.3 * this.marginLeft);
        y = this.marginTop * 3;
        scrollBarSprite = new createjs.Sprite(spriteData, scrollBarBackground);
        barSpriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, scrollBarBackground);
        scrollBarSprite.setTransform(x, y);
        this.groupDisplayObject.addChild(scrollBarSprite);

        scrollButtonSprite = new createjs.Sprite(spriteData, scrollBarHandle);
        handleSpriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, scrollBarHandle);
        scrollButtonSprite.setTransform(x - ((handleSpriteSize.width - barSpriteSize.width) * 0.5), y);
        scrollButtonSprite.cursor = 'pointer';
        scrollButtonSprite.on("mousedown", this.onScrollHandleDown.bind(this));
        scrollButtonSprite.on("pressmove", this.onScrollHandlePressMove.bind(this));
        this.groupDisplayObject.addChild(scrollButtonSprite);
        this.scrollButtonSprite = scrollButtonSprite;
        this.scrollButtonMin = y;
        this.scrollButtonMax = y + barSpriteSize.height - handleSpriteSize.height;
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text("Your Awards & Stats", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop * 0.8;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupInfoText: function () {

        // Display various player statistics

        var titleTextField,
            playerStats = MemoryMatch.UserData.getUserDataObject(),
            leftX = this.backgroundWidth * 0.12,
            rightX = this.backgroundWidth * 0.49,
            Y,
            timePlayed,
            fieldWidth = this.backgroundWidth * 0.2,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontColor = MemoryMatch.GameSetup.guiFontColor,
            lineHeight = 54 * MemoryMatch.stageScaleFactor,
            numberOfGamesPlayed = playerStats['numberOfGamesPlayed'] | 0,
            totalMatchCount = playerStats['totalMatchCount'] | 0,
            totalCombos = playerStats['totalCombos'] | 0,
            totalTimePlayed = playerStats['totalTimePlayed'] | 0,
            luckyGuessCount = playerStats['luckyGuessCount'] | 0,
            bestScore = playerStats['bestScore'] | 0;

        if (totalTimePlayed == 0) {
            timePlayed = '-';
        } else if (totalTimePlayed >= 60*60*1000) {
            timePlayed = MemoryMatch.formatTimeAsString(totalTimePlayed, true, true);
        } else {
            timePlayed = MemoryMatch.formatTimeAsString(totalTimePlayed, true, false);
        }

        // first column
        Y = this.startYAchievements;
        titleTextField = new createjs.Text("Games:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(numberOfGamesPlayed.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Matches:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(totalMatchCount.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Best Score:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(bestScore), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        // Second column
        leftX = this.backgroundWidth * 0.55;
        rightX = this.backgroundWidth * 0.88;
        Y = this.startYAchievements;
        titleTextField = new createjs.Text("Combos:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(totalCombos.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Time:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(timePlayed, fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        Y += lineHeight;
        titleTextField = new createjs.Text("Lucky Guesses:", fontSizeBold, fontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = leftX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);
        titleTextField = new createjs.Text(luckyGuessCount.toString(), fontSizeBold, fontColor);
        titleTextField.textAlign = "right";
        titleTextField.x = rightX;
        titleTextField.y = Y;
        titleTextField.maxWidth = fieldWidth;
        this.contentDisplayObject.addChild(titleTextField);

        this.startYAchievements = Y + (lineHeight * 1.5);
    },

    setupAward: function (scaleFactor, startY) {
        var awardDisplayObject = new createjs.Container(),
            spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        imageSprite.setTransform(spriteSize.width * 0.5, spriteSize.height * 0.5, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        awardDisplayObject.addChild(imageSprite);
        awardDisplayObject.setBounds(0, 0, spriteSize.width, spriteSize.height);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position = {x: 0, y: 0};
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor), 1, 1);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            awardDisplayObject.addChild(imageSprite);
        }
        this.contentDisplayObject.addChild(awardDisplayObject);
        awardDisplayObject.setTransform((this.backgroundWidth - (spriteSize.width * scaleFactor)) * 0.5, startY, scaleFactor, scaleFactor, 0, 0, 0, 0, 0);
        return startY + (spriteSize.height * scaleFactor * 0.5);
    },

    setupAchievements: function () {
        var allAchievements = MemoryMatch.GameSetup.achievements,
            achievementInfo = null,
            achievementItem = null,
            earned = false,
            i,
            width = this.backgroundWidth * 0.41,
            height = width * 0.33,
            margin = width * 0.01,
            Y = this.startYAchievements + (height * 0.5),
            X = (this.backgroundWidth - width) * 0.51,
            x2Column = X + margin;

        for (i = 0; i < allAchievements.length; i ++ ) {
            achievementInfo = allAchievements[i];
            earned = MemoryMatch.didUserEarnAchievement(achievementInfo.id);
            achievementItem = new MemoryMatch.AchievementItem(this.contentDisplayObject, {achievementId: achievementInfo.id, x: x2Column, y: Y, width: width, height: height, autoClose: false, icon: 'metal', earned: earned, callback: null});
            if (i % 2 == 0) {
                x2Column = X + achievementItem.getBounds().width + margin + margin;
            } else {
                Y += achievementItem.getBounds().height + margin;
                x2Column = X + margin;
            }
        }
        // determine how far past the viewable bottom we are to scroll to
        this.scrollLimitMax = this.scrollLimitMax - achievementItem.y;
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            buttonSize;

        // Close button always shows in its own special place
        gameButton = MemoryMatch.GUIButton({name: "close", tag: 1, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.03, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.closeButtonInstance = gameButton;
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        this.scrollButtonSprite.removeAllEventListeners();
        this.scrollButtonSprite = null;
        this.closeButtonInstance.removeAllEventListeners();
        this.closeButtonInstance = null;
        this.scrollMask.removeAllEventListeners();
        this.scrollMask = null;
        this.groupDisplayObject.removeChild(this.contentDisplayObject);
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.contentDisplayObject = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * ChallengeIntroduction.js
 *
 * Show the Challenge Introduction popup. This popup introduces a challenge level.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.ChallengeIntroduction = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, stateCompleteCallbackFunction) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleAndMessageText();
        this.setupAward();
        this.setupButtons();
        this.groupDisplayObject.setTransform((this.parentDisplayObject.canvas.width * 0.5) - (this.backgroundWidth * 0.5), (this.parentDisplayObject.canvas.height * 0.5) - (this.backgroundHeight * 0.5), 1, 1);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
        MemoryMatch.stopBackgroundMusic();
        MemoryMatch.playInterstitialMusic("soundChallenge", true);
        if (this.stateCompleteCallback !== null) {
            // stateCompleteCallback();
        }
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        MemoryMatch.stopInterstitialMusic();
        // begin animation, then once close is complete send notification
        if (MemoryMatch.ChallengeIntroduction.stateCompleteCallback !== null) {
            MemoryMatch.ChallengeIntroduction.stateCompleteCallback(closeEventType);
        }
        MemoryMatch.ChallengeIntroduction.killScreen();
    },

    onClickHome: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.ChallengeIntroduction.isEnabled) {
            MemoryMatch.ChallengeIntroduction.closePopup("home");
        }
    },

    onClickContinue: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.ChallengeIntroduction.isEnabled) {
            MemoryMatch.ChallengeIntroduction.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleAndMessageText: function () {
        var titleTextField;
        var gameData = MemoryMatch.getGameData(true),
            yOffset;

        titleTextField = new createjs.Text("Challenge Game", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset = titleTextField.y + titleTextField.getMeasuredHeight();

//        titleTextField = new createjs.Text(gameData.levelName, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
//        titleTextField.textAlign = "center";
//        titleTextField.x = this.backgroundWidth * 0.5;
//        titleTextField.y = yOffset;
//        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
//        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
//        this.groupDisplayObject.addChild(titleTextField);
//        yOffset += titleTextField.getMeasuredHeight();

        titleTextField = new createjs.Text(gameData.levelIntro, MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonMargin = 0,
            buttonTagCounter = 0,
            totalWidth = (2 * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },


    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.54};
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.5;
        position.y -= spriteSize.height * 0.5;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor));
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].removeAllEventListeners();
        }
        this.buttonInstances = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * CreditsPopup.js
 *
 * Show game credits.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.CreditsPopup = {
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    closeButton: true,
    stateCompleteCallback: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,

    setup: function (displayObject, stateCompleteCallback) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.stateCompleteCallback = stateCompleteCallback;
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        this.setupCopyrightText();
        this.showCredits();
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // No animation for Credits
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        // begin animation and send notification we're done here
        this.isEnabled = false;
        if (this.stateCompleteCallback !== null) {
            this.stateCompleteCallback("close");
        }
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            this.closePopup("close");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text("Credits", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    showCredits: function () {
        var titleTextField,
            text1 = MemoryMatch.GameSetup.GUIStrings.creditsInfo,
            text2 = MemoryMatch.GameSetup.GUIStrings.creditsCredit;

        titleTextField = new createjs.Text(text1, MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.18;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        this.groupDisplayObject.addChild(titleTextField);

        titleTextField = new createjs.Text(text2, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.backgroundHeight * 0.32;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);

        // Show the JumpyDot logo
        var spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet2Frames);
        var iconSprite = new createjs.Sprite(spriteData, "JumpyDotLogo");
        iconSprite.setTransform(this.backgroundWidth * 0.15, this.backgroundHeight * 0.70);
        iconSprite.framerate = 1;
        this.groupDisplayObject.addChild(iconSprite);

        // Show the HTML5 icon
        iconSprite = new createjs.Sprite(spriteData, "html5-logo");
        iconSprite.setTransform(this.backgroundWidth * 0.80, this.backgroundHeight * 0.73);
        iconSprite.framerate = 1;
        this.groupDisplayObject.addChild(iconSprite);
    },

    setupCopyrightText: function () {
        var info = 'Copyright 2014 JumpyDot. All rights reserved.',
            infoTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiInfoColor);

        infoTextField.textAlign = "center";
        infoTextField.x = this.backgroundWidth * 0.5;
        infoTextField.y = this.backgroundHeight * 0.88;
        infoTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(infoTextField);
    },

    setupButtons: function () {
        var spriteFrame,
            spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames),
            buttonScale = 1.0,
            gameButton,
            newButtonInstance,
            buttonSize;

        // Close button always shows in its own special place
        gameButton = MemoryMatch.GUIButton({name: "close", tag: 1, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameComplete.js
 *
 * Show the Game Complete popup. We show this once the player has completed all 4 challenges.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.GameComplete = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    isEnabled: false,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setup: function (displayObject, stateCompleteCallbackFunction) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleAndMessageText();
        this.setupAward();
        this.setupButtons();
        this.groupDisplayObject.setTransform((this.parentDisplayObject.canvas.width * 0.5) - (this.backgroundWidth * 0.5), (this.parentDisplayObject.canvas.height * 0.5) - (this.backgroundHeight * 0.5), 1, 1);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
        MemoryMatch.stopBackgroundMusic();
        MemoryMatch.playInterstitialMusic("soundWin", false);
    },

    closePopup: function (closeEventType) {
        this.isEnabled = false;
        // begin animation, then once close is complete send notification
        if (MemoryMatch.GameComplete.stateCompleteCallback !== null) {
            MemoryMatch.GameComplete.stateCompleteCallback(closeEventType);
        }
        MemoryMatch.stopInterstitialMusic();
        MemoryMatch.GameComplete.killScreen();
    },

    onClickHome: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.GameComplete.isEnabled) {
            MemoryMatch.GameComplete.closePopup("home");
        }
    },

    onClickShare: function (event) {
        var shareMessage = '';
        if (MemoryMatch.GameComplete.isEnabled) {
            shareMessage = 'I just completed ' + MemoryMatch.GameSetup.gameTitle + ' with a score of ' + MemoryMatch.totalScore + '. can you beat me?';
            MemoryMatch.showSharePopup(shareMessage);
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleAndMessageText: function () {
        var titleTextField,
            yOffset,
            title,
            subtitle,
            info;

        title = MemoryMatch.GameSetup.winState.title;
        subtitle = MemoryMatch.GameSetup.winState.subtitle;
        info = MemoryMatch.GameSetup.winState.info;

        titleTextField = new createjs.Text(title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset = titleTextField.y + titleTextField.getMeasuredHeight();

        titleTextField = new createjs.Text(subtitle, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        yOffset += titleTextField.getMeasuredHeight() + (42 * MemoryMatch.stageScaleFactor);

        titleTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(38) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = yOffset;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            buttonMargin = 42 * MemoryMatch.stageScaleFactor,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonTagCounter = 0,
            xOffset = (this.backgroundWidth - (buttonWidth + buttonMargin + buttonWidth)) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "share", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickShare.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverShareIcon", iconOver: "gameOverShareDownIcon", iconDown: "gameOverShareDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.54};
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.5;
        position.y -= spriteSize.height * 0.5;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * MemoryMatch.stageScaleFactor));
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].removeAllEventListeners();
        }
        this.buttonInstances = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameGUI.js
 *
 * Show the HUD display. This abstracts the game GUI that is displayed and manages any
 * transactions to keep the GUI management and display separate from any game logic.
 *
 * Layout:
 * Score ######### Level ##/##  <* * *> Matches: ## Time: ##:## [O]
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.GameGUI = {
    groupDisplayObject: null,
    parentDisplayObject: null,
    width: 0,
    height: 0,
    hudHeight: 0,
    spriteData: null,
    headerSprite: null,
    levelNumber: 1,
    levelField: null,
    levelIcon: null,
    scoreField: null,
    matchCountLabel: null,
    matchCountField: null,
    gameTimerField: null,
    messageField: null,
    timerCountdownGroup: null,
    timerCountdownTimer: null,
    comboMultiplierSprite: null,
    matchCountFieldFlash: false,
    matchCountFieldFlashCount: 0,
    matchCountFlashTimer: null,
    optionsButton: null,
    optionsButtonHelper: null,
    gameOptionsButton: null,
    gameOptionsButtonHelper: null,
    isAnimating: false,
    flashThreshold: 2,
    comboMultiplier: 1,
    timerCountdownStarted: false,
    lastUpdateTime: 0,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    showingGameLevel: 0,

    build: function (stage) {
        // layout the display objects assuming parentDisplayObject is valid
        this.parentDisplayObject = stage;
        if (this.parentDisplayObject != null) {
            this.width = MemoryMatch.stageWidth;
            this.height = MemoryMatch.stageHeight;
            this.groupDisplayObject = new createjs.Container();
            this.showingGameLevel = MemoryMatch.gameLevel;
            if (this.spriteData == null) {
                this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            }
            this.setColorFilters();
            this.setupHeader();
            this.setupOptionsButton();
            this.setupGameOptionsButton();
            this.setupScoreTextField();
            this.setupLevelTextField();
            this.setupMatchCountTextField();
            this.setupGameTimerTextField();
            this.setupMessageTextField();
            this.parentDisplayObject.addChild(this.groupDisplayObject);
            this.groupDisplayObject.setTransform(0, this.hudHeight * -1, 1, 1);
        }
    },

    destroy: function () {
        // Kill all events, display objects and remove from stage
        if (this.matchCountFlashTimer != null) {
            window.clearTimeout(this.matchCountFlashTimer);
            this.matchCountFlashTimer = null;
        }
        if (this.timerCountdownTimer != null) {
            window.clearTimeout(this.timerCountdownTimer);
            this.timerCountdownTimer = null;
        }
        this.parentDisplayObject.removeChild(this.optionsButton);
        if (this.timerCountdownGroup != null) {
            this.parentDisplayObject.removeChild(this.timerCountdownGroup);
            this.timerCountdownGroup = null;
        }
        this.spriteData = null;
        this.headerSprite = null;
        this.levelField = null;
        this.levelIcon = null;
        this.scoreField = null;
        this.matchCountLabel = null;
        this.matchCountField = null;
        this.gameTimerField = null;
        this.messageField = null;
        this.optionsButton = null;
        this.optionsButtonHelper = null;
        this.gameOptionsButton = null;
        this.gameOptionsButtonHelper = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.groupDisplayObject = null;
        this.parentDisplayObject = null;
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        this.isAnimating = false;
    },

    pause: function (event) {
        // show the paused state
        this.hideTimerCountdown();
    },

    resume: function (event) {
        // undo the paused state and bring the GUI back to normal
    },

    show: function (showFlag) {
        // show or hide the HUD. This triggers the animation so it will take some time before it is in a ready state.
        var finalY,
            distance;

        if (this.groupDisplayObject == null) {
            return;
        }
        if (showFlag) {
            if (this.showingGameLevel != MemoryMatch.gameLevel) {
                this.setColorFilters();
                this.showingGameLevel = MemoryMatch.gameLevel
            }
            finalY = 0;
            distance = 0 - this.groupDisplayObject.y;
            this.optionsButton.visible = false;
        } else {
            finalY = this.hudHeight * -1;
            distance = finalY - this.groupDisplayObject.y;
            this.matchCountFieldFlash = false;
            this.comboMultiplierSprite.visible = false;
            this.hideTimerCountdown();
            this.optionsButton.visible = true;
        }
        if (finalY != this.groupDisplayObject.y && ! this.isAnimating) {
            this.messageField.visible = false; // hide message field until animation completes
            this.isAnimating = true;
            var guiAnimator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, 0, false, null, this.showAnimationComplete.bind(this));
            guiAnimator.vY = distance / (0.2 * MemoryMatch.fps);
            guiAnimator.endY = finalY;
        }
    },

    showAnimationComplete: function (g) {
        var isShowing = this.groupDisplayObject.y >= 0;
        this.messageField.visible = isShowing; // only show message field if GUI is showing
        this.comboMultiplierSprite.visible = isShowing;
        this.isAnimating = false;
    },

    setMessage: function (message) {
        this.messageField.text = message;
    },

    getHeight: function () {
        return this.hudHeight;
    },

    updateLevelDisplay: function (level, gameNumber) {
        // convert level # to icon image
        var displayGameNumber;
        if (level < 1) {
            level = 1;
        } else if (level > MemoryMatch.GameSetup.levels.length) {
            level = MemoryMatch.GameSetup.levels.length;
        }
        if (MemoryMatch.isChallengeGame) {
            displayGameNumber = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].gameCount + 1 + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
        } else {
            displayGameNumber = gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
        }
        this.levelNumber = level;
        this.levelIcon.gotoAndStop(MemoryMatch.GameSetup.levels[level - 1].iconHUD);
        this.levelField.text = displayGameNumber.toString();
    },

    updateScoreDisplay: function (newScoreValue) {
        if (newScoreValue == null || newScoreValue == '') {
            newScoreValue = 0;
        }
        if (newScoreValue > 0) {
            this.scoreField.text = MemoryMatch.formatNumberWithGroups(newScoreValue);
        } else {
            this.scoreField.text = "0";
        }
    },

    updateMatchCountDisplay: function (newValue) {
        var valueChanged = this.matchCountField.text != Number(newValue).toString();
        this.matchCountField.text = Number(newValue).toString();
        if ( ! MemoryMatch.isChallengeGame && newValue <= this.flashThreshold) {
            this.matchCountField.color = MemoryMatch.GameSetup.guiAlertFontColor;
            if (valueChanged) {
                if (newValue > 0) {
                    MemoryMatch.triggerSoundFx("soundMovesLast");
                } else {
                    MemoryMatch.triggerSoundFx("soundMovesLow");
                }
            }
            if ( ! this.matchCountFieldFlash) {
                this.flashMatchCountDisplay(true, -1);
            }
        } else {
            this.matchCountField.color = MemoryMatch.GameSetup.guiFontColor;
            this.matchCountField.alpha = 1;
            this.matchCountFieldFlash = false;
        }
    },

    flashMatchCountDisplay: function (flashFlag, flashCount) {
        if (this.matchCountFieldFlash === flashFlag) {
            return;
        }
        this.matchCountFieldFlash = flashFlag;
        this.matchCountFieldFlashCount = flashCount;
        if (flashFlag) {
            this.matchCountFlashTimer = window.setTimeout(this.flashMatchCountDisplayUpdate.bind(this), 500);
        } else {
            this.matchCountField.alpha = 1;
            if (this.matchCountFlashTimer != null) {
                window.clearTimeout(this.matchCountFlashTimer);
                this.matchCountFlashTimer = null;
            }
        }
    },

    flashMatchCountDisplayUpdate: function (event) {
        var stillFlashing = true;
        var newAlpha = 1;

        if (this.matchCountField == null) {
            return;
        }
        if (this.matchCountFieldFlash) {
            if (this.matchCountField.alpha < 1) {
                newAlpha = 1;
            } else {
                newAlpha = 0.4;
            }
            if (this.matchCountFieldFlashCount > 0) {
                this.matchCountFieldFlashCount --;
                if (this.matchCountFieldFlashCount == 0) {
                    newAlpha = 1;
                    stillFlashing = false;
                }
            }
            this.matchCountField.alpha = newAlpha;
            if (stillFlashing) {
                this.matchCountFlashTimer = window.setTimeout(this.flashMatchCountDisplayUpdate.bind(this), 500);
            } else {
                this.matchCountFlashTimer = null;
            }
        }
    },

    setFlashCountThreshold: function (newThreshold) {
        if (newThreshold < 0) {
            newThreshold = 0;
        }
        this.flashThreshold = newThreshold;
    },

    setMatchCountLabel: function (newLabel) {
        if (newLabel == null) {
            newLabel = 'Misses';
        }
        this.matchCountLabel.text = newLabel;
    },

    updateGameTimerDisplay: function (newValue) {
        var timeToShow;

        if (this.gameTimerField == null) {
            return;
        }
        if (newValue == null) {
            timeToShow = '';
        } else if (newValue == 0) {
            timeToShow = '0:00';
        } else {
            timeToShow = MemoryMatch.formatTimeAsString(newValue, true, false);
        }
        this.gameTimerField.text = timeToShow;
    },

    updateComboMultiplier: function (newValue) {
        var displayString = '';
        var startAnimation = false;

        if (this.comboMultiplierSprite != null) {
            if (newValue == null || newValue < 2) {
                this.comboMultiplier = 1;
            } else {
                if (newValue > this.comboMultiplier) {
                    this.comboMultiplier = newValue;
                    startAnimation = true;
                }
            }
            if (this.comboMultiplier > 1) {
                displayString = this.comboMultiplier.toString() + 'x';
            }
            this.comboMultiplierSprite.text = displayString;
            if (startAnimation) {
                this.startComboSpriteAnimation();
            }
        }
    },

    showOptionsButton: function (showFlag) {
        this.optionsButton.visible = showFlag;
    },

    showLevelField: function (showFlag) {
        this.levelField.visible = showFlag;
    },

    showMatchCountField: function (showFlag) {
        this.matchCountLabel.visible = showFlag;
        this.matchCountField.visible = showFlag;
    },

    showTimer: function (showFlag) {
        this.gameTimerField.visible = showFlag;
    },

    showTimerCountdown: function (message, startSeconds) {

        // display a count down timer with title message and seconds to count down

        var containerGroup,
            containerWidth,
            containerHeight,
            titleTextField,
            titleTextFieldSize,
            backgroundShape,
            timerTextField,
            timerTextFieldSize,
            timerTextFieldAnimate;

        if (this.timerCountdownStarted) {
            return;
        }
        if (message == null) {
            message = '';
        }
        if (startSeconds < 1) {
            startSeconds = 1;
        } else if (startSeconds > 99) {
            startSeconds = 99;
        }
        if (this.timerCountdownGroup == null) {
            titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(32) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
            titleTextField.textAlign = 'center';
            titleTextField.name = 'title';

            timerTextField = new createjs.Text(startSeconds.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
            timerTextField.textAlign = 'center';
            timerTextField.name = 'timer';

            titleTextFieldSize = titleTextField.getBounds();
            timerTextFieldSize = timerTextField.getBounds();
            containerWidth = Math.max(titleTextFieldSize.width, timerTextFieldSize.width) * 1.2;
            containerHeight = titleTextFieldSize.height + timerTextFieldSize.height * 1.1;
            titleTextField.x = containerWidth * 0.5;
            timerTextField.x = containerWidth * 0.5;
            titleTextField.y = containerHeight * 0.1;
            timerTextField.y = titleTextField.y + titleTextFieldSize.height;
            timerTextFieldAnimate = timerTextField.clone();
            timerTextFieldAnimate.name = 'timerAnimate';

            backgroundShape = new createjs.Shape();
            backgroundShape.graphics.beginFill("#000000").drawRoundRect(0, 0, containerWidth, containerHeight, 8);
            backgroundShape.alpha = 0.2;
            backgroundShape.name = 'background';

            containerGroup = new createjs.Container();
            containerGroup.addChild(backgroundShape);
            containerGroup.addChild(titleTextField);
            containerGroup.addChild(timerTextField);
            containerGroup.addChild(timerTextFieldAnimate);
            containerGroup.setTransform(MemoryMatch.stageWidth * 0.8, MemoryMatch.stageWidth * 0.014);
            this.groupDisplayObject.addChild(containerGroup);
            this.timerCountdownGroup = containerGroup;
        } else {
            containerGroup = this.timerCountdownGroup;
            containerGroup.visible = true;
            titleTextField = this.timerCountdownGroup.getChildByName('title');
            if (titleTextField != null) {
                titleTextField.text = message;
            }
            timerTextField = this.timerCountdownGroup.getChildByName('timer');
            if (timerTextField != null) {
                timerTextField.text = startSeconds.toString();
            }
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                timerTextFieldAnimate.text = startSeconds.toString();
            }
        }
        this.lastUpdateTime = 0;
    },

    hideTimerCountdown: function () {
        if (this.timerCountdownGroup != null) {
            this.timerCountdownGroup.visible = false;
            this.timerCountdownStarted = false;
            this.lastUpdateTime = 0;
            this.showTimer(true);
        }
    },

    startTimerCountdown: function () {
        if ( ! this.timerCountdownStarted) {
            this.timerCountdownStarted = true;
            this.showTimer(false);
            this.updateTimerCountdown();
        }
    },

    updateTimerCountdown: function () {
        var timerTextFieldAnimate,
            animator;

        if (this.timerCountdownGroup != null && this.timerCountdownGroup.visible) {
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(timerTextFieldAnimate, 0, 900, false, null, null);
                animator.showAtBegin = true;
                animator.vAlpha = -0.0167;
                animator.vXScale = 0.0093;
                animator.endXScale = 1.5;
                animator.vYScale = 0.0093;
                animator.endYScale = 1.5;
                this.timerCountdownTimer = window.setTimeout(this.onTimerCountdownTick.bind(this), 1000);
                this.lastUpdateTime = Date.now();
            }
        }
    },

    onTimerCountdownTick: function () {
        var timerTextFieldAnimate,
            timerTextField,
            updateTimeDelta,
            timeValue,
            lastUpdate;

        if (this.timerCountdownGroup != null) {
            updateTimeDelta = Date.now() - this.lastUpdateTime;
            timerTextFieldAnimate = this.timerCountdownGroup.getChildByName('timerAnimate');
            if (timerTextFieldAnimate != null) {
                timerTextFieldAnimate.alpha = 1.0;
                timerTextFieldAnimate.scaleX = 1.0;
                timerTextFieldAnimate.scaleY = 1.0;
                timeValue = parseInt(timerTextFieldAnimate.text);
                if (timeValue > 0) {
                    timeValue --;
                    lastUpdate = false;
                } else {
                    lastUpdate = true;
                }
                timerTextFieldAnimate.text = timeValue.toString();
                timerTextField = this.timerCountdownGroup.getChildByName('timer');
                if (timerTextField != null) {
                    timerTextField.text = timeValue.toString();
                }
                if (timeValue >= 0 && ! lastUpdate) {
                    this.updateTimerCountdown();
                } else {
                    this.timerCountdownStarted = false;
                    this.timerCountdownTimer = null;
                }
            }
        }
    },

    setupLevelTextField: function () {

        // add the icon on top of the button frame

        var iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[this.levelNumber - 1].iconHUD,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon),
            levelField;

        iconSprite.setTransform(this.width * 0.01, (this.hudHeight - spriteSize.height) * 0.5, iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";

        levelField = new createjs.Text("", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        levelField.textAlign = "left";
        levelField.textBaseline = "middle";
        levelField.setTransform(this.width * 0.09, this.hudHeight * 0.5);
        levelField.maxWidth = 120 * MemoryMatch.stageScaleFactor; // space for 3 chars

        this.groupDisplayObject.addChild(iconSprite);
        this.levelIcon = iconSprite;
        this.groupDisplayObject.addChild(levelField);
        this.levelField = levelField;
    },

    setupScoreTextField: function () {
        var scoreField = new createjs.Text("0", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        scoreField.textAlign = "center";
        scoreField.textBaseline = "middle";
        scoreField.setTransform(this.width * 0.25, this.hudHeight * 0.5);
        scoreField.maxWidth = this.width * 0.0974;
        this.groupDisplayObject.addChild(scoreField);
        this.scoreField = scoreField;
    },

    setupMatchCountTextField: function () {
        var matchCountLabel,
            matchCountField,
            matchCountWidth,
            matchCountHeight,
            backgroundShape;

        matchCountWidth = this.width * 0.18;
        matchCountHeight = this.hudHeight * MemoryMatch.GameSetup.guiHUDMatchCountHeight;
        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRect(0, 0, matchCountWidth, matchCountHeight);
        backgroundShape.alpha = 0.2;
        backgroundShape.setTransform((this.width - matchCountWidth) * 0.5, this.hudHeight * MemoryMatch.GameSetup.guiHUDMatchCountOffset);
        this.groupDisplayObject.addChild(backgroundShape);

        matchCountLabel = new createjs.Text("Misses:", MemoryMatch.getScaledFontSize(60) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountLabel.textAlign = "right";
        matchCountLabel.textBaseline = "middle";
        matchCountLabel.setTransform(this.width * 0.52, this.hudHeight * 0.5);
        matchCountLabel.maxWidth = this.width * 0.1;
        this.matchCountLabel = matchCountLabel;
        this.groupDisplayObject.addChild(matchCountLabel);

        matchCountField = new createjs.Text("0", MemoryMatch.getScaledFontSize(84) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountField.textAlign = "left";
        matchCountField.textBaseline = "middle";
        matchCountField.setTransform(this.width * 0.54, this.hudHeight * 0.44);
        matchCountField.maxWidth = this.width * 0.03;
        this.matchCountField = matchCountField;
        this.groupDisplayObject.addChild(matchCountField);
    },

    setupGameTimerTextField: function () {
        var maxFieldWidth = 10 * 22 * MemoryMatch.stageScaleFactor,
            gameTimerField = new createjs.Text("", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);

        gameTimerField.textAlign = "left";
        gameTimerField.textBaseline = "middle";
        gameTimerField.setTransform(this.width * 0.8, this.hudHeight * 0.5)
        gameTimerField.maxWidth = maxFieldWidth;
        this.groupDisplayObject.addChild(gameTimerField);
        this.gameTimerField = gameTimerField;
    },

    setupMessageTextField: function () {
        var bounds,
            comboSprite,
            messageField = new createjs.Text("", MemoryMatch.getScaledFontSize(24) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);

        messageField.textAlign = "left";
        messageField.x = 30 * MemoryMatch.stageScaleFactor;
        messageField.y = this.height - (40 * MemoryMatch.stageScaleFactor);
        messageField.maxWidth = this.width - (20  * MemoryMatch.stageScaleFactor);
        messageField.visible = false;
        this.groupDisplayObject.addChild(messageField);
        this.messageField = messageField;

        comboSprite = new createjs.Text("1x", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColorBonus);
        comboSprite.textAlign = "center";
        comboSprite.x = MemoryMatch.stageWidth * 0.9;
        comboSprite.y = MemoryMatch.stageHeight * 0.96;
        comboSprite.maxWidth = this.width - (20  * MemoryMatch.stageScaleFactor);
        comboSprite.visible = false;
        bounds = comboSprite.getBounds();
        comboSprite.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
        comboSprite.regY = bounds.height * 0.5;
        this.groupDisplayObject.addChild(comboSprite);
        this.comboMultiplierSprite = comboSprite;
    },

    setupHeader: function () {
        // we want the header centered in the current stage regardless of the stage width
        var spriteFrame = "topHud",
            guiHeaderSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);

        this.hudHeight = spriteSize.height;
        guiHeaderSprite.framerate = 1;
        guiHeaderSprite.gotoAndStop("topHud");
        guiHeaderSprite.setTransform((this.width - spriteSize.width) * 0.5, 0, 1, 1);
        if (this.primaryColorFilter != null) {
            guiHeaderSprite.filters = [this.primaryColorFilter];
        }
        guiHeaderSprite.cache(0, 0, spriteSize.width, spriteSize.height);
        this.groupDisplayObject.addChild(guiHeaderSprite);
        this.headerSprite = guiHeaderSprite;
    },

    setupOptionsButton: function () {
        var spriteFrame = "mapOptionsButtonUp",
            optionsButton = new createjs.Sprite(new createjs.SpriteSheet(MemoryMatch.GameSetup.mapSpritesheetFrames), spriteFrame),
            optionsButtonMargin = 20 * MemoryMatch.stageScaleFactor, // a little extra margin for the hit-area of the button
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.mapSpritesheetFrames, spriteFrame);

        optionsButton.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(-1 * optionsButtonMargin, 0, buttonSize.width + optionsButtonMargin, buttonSize.height + optionsButtonMargin));
        optionsButton.setTransform(this.width * 0.946, this.height * 0.04);
        optionsButton.framerate = 1;
        this.optionsButtonHelper = new createjs.ButtonHelper(optionsButton, "mapOptionsButtonUp", "mapOptionsButtonOver", "mapOptionsButtonDown", false);
        optionsButton.addEventListener("click", this.onOptions);
        this.parentDisplayObject.addChild(optionsButton);
        optionsButton.visible = true;
        this.optionsButton = optionsButton;
    },

    setupGameOptionsButton: function () {
        var spriteFrame = "optionsUp",
            optionsButton = new createjs.Sprite(this.spriteData, spriteFrame),
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);

        optionsButton.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(0, 0, buttonSize.width, buttonSize.height));
        optionsButton.setTransform(this.width * 0.93, (this.hudHeight - buttonSize) * 0.5);
        optionsButton.framerate = 1;
        this.gameOptionsButtonHelper = new createjs.ButtonHelper(optionsButton, "optionsUp", "optionsOver", "optionsDown", false);
        optionsButton.addEventListener("click", this.onGameOptions);
        this.groupDisplayObject.addChild(optionsButton);
        optionsButton.visible = true;
        this.gameOptionsButton = optionsButton;
    },

    onPauseGame: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.beginNewGame(1);
    },

    onOptions: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.GameGUI.optionsButton.gotoAndStop("optionsDown");

        // Show the Options popup
        if ( ! MemoryMatch.GameOptions.isShowing()) {
            MemoryMatch.pauseGameInProgress();
            MemoryMatch.GameOptions.setup(MemoryMatch.stage, MemoryMatch.GameGUI.onOptionsClosed, false);
            MemoryMatch.GameOptions.buildScreen(true, true);
        } else {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onHome: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("home");
        } else {
            MemoryMatch.GameResults.close();
            MemoryMatch.GameGUI.show(false);
            MemoryMatch.showMenuScreen();
        }
    },

    onGameOptions: function (eventType) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.GameGUI.optionsButton.gotoAndStop("optionsDown");

        // Show the Game Paused popup
        if ( ! MemoryMatch.GameOptions.isShowing()) {
            MemoryMatch.pauseGameInProgress();
            MemoryMatch.GameOptions.setup(MemoryMatch.stage, MemoryMatch.GameGUI.onOptionsClosed, true);
            MemoryMatch.GameOptions.buildScreen(true, true);
        } else {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onOptionsClosed: function (eventType) {
        switch (eventType) {
            case "home": // quit any current game and show main menu
                MemoryMatch.onQuitGame();
                break;
            case "restart": // restart the current game
                MemoryMatch.replayCurrentGame();
                break;
            case "continue":
            case "close":    // unpause the game
            default:
                if (MemoryMatch.gameState != MemoryMatch.GAMESTATE.MENU) {
                    MemoryMatch.resumePausedGame();
                }
                break;
        }
    },

    startComboSpriteAnimation: function () {
        var animator;

        if (this.comboMultiplierSprite != null) {
            // grow & rotate
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboMultiplierSprite, 0, 0, false, null, this.comboSpriteAnimationPhaseTwo.bind(this));
            animator.showAtBegin = true;
            animator.vXScale = 0.08;
            animator.endXScale = 1.2;
            animator.vYScale = 0.08;
            animator.endYScale = 1.2;
            animator.vRotation = -1.2;
            animator.endRotation = -12;
        }
    },

    comboSpriteAnimationPhaseTwo: function () {
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboMultiplierSprite, 0, 0, false, null, this.killComboSpriteAnimation.bind(this));
        animator.showAtBegin = true;
        animator.vXScale = -0.08;
        animator.endXScale = 1.0;
        animator.vYScale = -0.08;
        animator.endYScale = 1.0;
        animator.vRotation = 1.2;
        animator.endRotation = 0;
    },

    killComboSpriteAnimation: function () {
        if (this.comboMultiplierSprite != null) {
        }
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
        if (this.headerSprite != null && this.primaryColorFilter != null) {
            this.headerSprite.filters = [this.primaryColorFilter];
            this.headerSprite.updateCache();
        }
    }
};

/**
 * GameOptions.js
 *
 * Show the options popup. This popup has 2 contexts: current active game, and no game active.
 * If a game is active then show:
 *   Audio button
 *   Help button
 *   Home button
 *   Restart button
 *   Credits button
 *   Close button
 *
 * If no game is active then show:
 *   Audio button
 *   Credits button
 *   View Stats button
 *   Clear Stats button
 *   Close button
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.GameOptions = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    audioOnButtonInstance: null,
    audioOffButtonInstance: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    centerX: 0,
    marginX: 0,
    lineHeight: 0,
    isGameOptions: false,
    isEnabled: false,
    closeEventType: null,
    animate: true,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,

    setup: function (displayObject, stateCompleteCallbackFunction, isGameOptions) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.isGameOptions = isGameOptions;
        this.isEnabled = false;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.centerX = this.backgroundWidth * 0.5;
        this.marginX = 12 * MemoryMatch.stageScaleFactor;
        this.setupTitleText();
        this.setupButtons();
        this.setupInfoText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        if (autoStart === null) {
            autoStart = false;
        }
        if (animate === null) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        var duration,
            animator;

        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            // begin animation, then wait for user event to end this state and alert callback
            duration = 0.3; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        }
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1,
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        if (MemoryMatch.GameOptions.stateCompleteCallback !== null) {
            MemoryMatch.GameOptions.stateCompleteCallback(this.closeEventType);
        }
        MemoryMatch.GameOptions.killScreen();
    },

    closePopup: function (closeEventType) {
        if (this.isShowing()) {
            this.isEnabled = false;
            this.closeEventType = closeEventType;
            // begin animation, then once close is complete send notification
            this.closeStartAnimation();
        }
    },

    closePopupFromPopup: function (closeEventType) {
        // Close popup without animation
        if (this.isShowing()) {
            this.isEnabled = false;
            this.closeEventType = closeEventType;
            this.closeComplete();
        }
    },

    onClickClose: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("close");
        }
    },

    onClickHome: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("home");
        }
    },

    onClickRestart: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("restart");
        }
    },

    onClickContinue: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.GameOptions.closePopup("continue");
        }
    },

    onClickCredits: function (event) {
        if (this.isEnabled) {
            MemoryMatch.unlockAllLevelsCounter ++;
            MemoryMatch.CreditsPopup.setup(MemoryMatch.stage, this.closePopupFromPopup.bind(this));
            MemoryMatch.CreditsPopup.buildScreen(true);
        }
    },

    onClickAudio: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            var muteFlag = ! createjs.Sound.getMute();
            createjs.Sound.setMute(muteFlag);
            MemoryMatch.GameOptions.audioOnButtonInstance.visible = ! muteFlag;
            MemoryMatch.GameOptions.audioOnButtonInstance.setEnabled( ! muteFlag);
            MemoryMatch.GameOptions.audioOffButtonInstance.visible = muteFlag;
            MemoryMatch.GameOptions.audioOffButtonInstance.setEnabled(muteFlag);
            MemoryMatch.audioMute = muteFlag;
            MemoryMatch.updateUserDataObject(null);
        }
    },

    onClickHelp: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            if (MemoryMatch.GameOptions.isGameOptions) {
                MemoryMatch.LevelIntroduction.setup(MemoryMatch.stage, MemoryMatch.GameOptions.onHelpCallback.bind(MemoryMatch.GameOptions), MemoryMatch.gameId, MemoryMatch.gameLevel, MemoryMatch.gameNumber);
                MemoryMatch.LevelIntroduction.buildScreen(true, false);
            } else {
                this.showHelp();
                this.closePopupFromPopup(null);
            }
        }
    },

    onClickFullScreen: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.goFullScreen();
        }
    },

    onClickShare: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.showSharePopup(MemoryMatch.GameSetup.gameSubTitle);
        }
    },

    onClickViewStats: function (event) {
        if (MemoryMatch.GameOptions.isEnabled) {
            MemoryMatch.unlockAllLevelsCounter ++;
            MemoryMatch.AwardsPopup.setup(MemoryMatch.stage, MemoryMatch.GameOptions.onMessagePopupCallback.bind(MemoryMatch.GameOptions));
            MemoryMatch.AwardsPopup.buildScreen(true, false);
        }
    },

    onClickClearStats: function (event) {
        var objectToDisplay;
        if (MemoryMatch.GameOptions.isEnabled) {
            if (MemoryMatch.unlockAllLevelsCounter > 2) {
                MemoryMatch.unlockAllLevels();
                objectToDisplay = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: "UNLOCKED", message: 'You have unlocked all levels.', sound: 'soundCorrect'});
            } else {
                MemoryMatch.resetUserData();
                objectToDisplay = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: "CLEARED", message: 'You have reset all levels.', sound: 'soundCorrect'});
            }
            MemoryMatch.unlockAllLevelsCounter = 0;
            if (MemoryMatch.MainMenu != null) {
                MemoryMatch.MainMenu.refreshButtons();
            }
            objectToDisplay = null;
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onMessagePopupCallback: function (closeEventType) {
        // closeEventType indicates the button used to close the popup
        this.closePopupFromPopup(closeEventType);
    },

    onHelpCallback: function (closeEventType, level, gameNumber) {
        this.closePopupFromPopup(closeEventType);
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {
        var title,
            titleTextField;

        if (this.isGameOptions) {
            title = "Game Paused";
        } else {
            title = "Options";
        }
        titleTextField = new createjs.Text(title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupInfoText: function () {
        var info,
            infoTextField;

        info = MemoryMatch.GameSetup.gameTitle + " version " + MemoryMatch.GameVersion + " on " + MemoryMatch.platform + " locale " + MemoryMatch.locale + (MemoryMatch.isTouchDevice ? " / Touch" : " / Mouse");
        infoTextField = new createjs.Text(info, MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiInfoColor);
        infoTextField.textAlign = "left";
        infoTextField.x = this.marginLeft;
        infoTextField.y = this.backgroundHeight * 0.92;
        infoTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(infoTextField);
    },

    setupButtons: function () {
        var buttonsGroup = new createjs.Container(),
            spriteFrame,
            buttonScale = 1.0,
            gameButton,
            buttonTagCounter = 0, // 8 * MemoryMatch.stageScaleFactor
            buttonSize,
            buttonMargin = 42 * MemoryMatch.stageScaleFactor,
            groupWidth,
            groupHeight,
            muted,
            fullScreenDisabled = ! MemoryMatch.isFullScreenAvailable(),
            xOffset,
            yOffset,
            buttonGap,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        // Figure out how to size the whole group of buttons.
        // This logic assumes all buttons are the same height.
        // We need a wide button to figure out how wide the button group will be.
        spriteFrame = "optionsLargeButtonBase";
        buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame);
        groupWidth = buttonSize.width;
        groupHeight = buttonSize.height * 3;
        xOffset = 0;
        yOffset = 0;

        // Audio button always shows but we need to set the correct state
        buttonTagCounter ++;
        muted = createjs.Sound.getMute();
        gameButton = MemoryMatch.GUIButton({name: "audioOn", tag: buttonTagCounter, disabled: false, callback: this.onClickAudio.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallSoundOnIcon", iconOver: "optionsSmallSoundOnDownIcon", iconDown: "optionsSmallSoundOnDownIcon"});
        gameButton.setTransform(xOffset, yOffset, 1, 1);
        gameButton.visible = ! muted;
        gameButton.setEnabled( ! muted);
        buttonsGroup.addChild(gameButton);
        this.audioOnButtonInstance = gameButton;
        this.buttonInstances.push(gameButton);

        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "audioOff", tag: buttonTagCounter, disabled: false, callback: this.onClickAudio.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallSoundOffIcon", iconOver: "optionsSmallSoundOffDownIcon", iconDown: "optionsSmallSoundOffDownIcon"});
        gameButton.setTransform(xOffset, yOffset, 1, 1);
        gameButton.visible = muted;
        gameButton.setEnabled(muted);
        buttonsGroup.addChild(gameButton);
        this.audioOffButtonInstance = gameButton;
        this.buttonInstances.push(gameButton);

        if (this.isGameOptions) {
            // Show Map button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "home", tag: buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallMenuIcon", iconOver: "optionsSmallMenuDownIcon", iconDown: "optionsSmallMenuDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Credits button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "credits", tag: buttonTagCounter, disabled: false, callback: this.onClickCredits.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallCreditIcon", iconOver: "optionsSmallCreditDownIcon", iconDown: "optionsSmallCreditDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Help button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "help", tag: buttonTagCounter, disabled: false, callback: this.onClickHelp.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallHelpIcon", iconOver: "optionsSmallHelpDownIcon", iconDown: "optionsSmallHelpDownIcon"});
            buttonSize = gameButton.getSize();
            xOffset = groupWidth - buttonSize.width;
            yOffset = 0;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Restart (Replay) button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "restart", tag: buttonTagCounter, disabled: false, callback: this.onClickRestart.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallReplayIcon", iconOver: "optionsSmallReplayDownIcon", iconDown: "optionsSmallReplayDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show fullscreen button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "fullscreen", tag: buttonTagCounter, disabled: fullScreenDisabled, callback: this.onClickFullScreen.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallFullScreenIcon", iconOver: "optionsSmallFullScreenDownIcon", iconDown: "optionsSmallFullScreenDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        } else {
            // Show View Stats button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "viewstats", tag: buttonTagCounter, disabled: false, callback: this.onClickViewStats.bind(this), baseUp: "optionsLargeButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, text: "View Stats", iconUp: "optionsLargeAwardsIcon", iconOver: "optionsLargeAwardsDownIcon", iconDown: "optionsLargeAwardsDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show Clear Stats button
            buttonTagCounter ++;
            yOffset += buttonSize.height + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "clearstats", tag: buttonTagCounter, disabled: false, callback: this.onClickClearStats.bind(this), baseUp: "optionsLargeButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, text: "Clear Stats", iconUp: "optionsLargeClearIcon", iconOver: "optionsLargeClearDownIcon", iconDown: "optionsLargeClearDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Help button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "help", tag: buttonTagCounter, disabled: false, callback: this.onClickHelp.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallHelpIcon", iconOver: "optionsSmallHelpDownIcon", iconDown: "optionsSmallHelpDownIcon"});
            buttonSize = gameButton.getSize();
            xOffset = groupWidth - buttonSize.width;
            yOffset = 0;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // adjust width of group for a 3rd column of buttons. Assumes 3rd column buttons are same width/height as the help button we just placed.
            buttonGap = xOffset - buttonSize.width;
            groupWidth += buttonGap + buttonSize.width;
            xOffset += buttonSize.width + buttonGap;
            yOffset = 0;

            // Show small Full screen button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "fullscreen", tag: buttonTagCounter, disabled: fullScreenDisabled, callback: this.onClickFullScreen.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallFullScreenIcon", iconOver: "optionsSmallFullScreenDownIcon", iconDown: "optionsSmallFullScreenDownIcon"});
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Share button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "share", tag: buttonTagCounter, disabled: false, callback: this.onClickShare.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverShareIcon", iconOver: "gameOverShareDownIcon", iconDown: "gameOverShareDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);

            // Show small Credits button
            buttonTagCounter ++;
            gameButton = MemoryMatch.GUIButton({name: "credits", tag: buttonTagCounter, disabled: false, callback: this.onClickCredits.bind(this), baseUp: "optionsSmallButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "optionsSmallCreditIcon", iconOver: "optionsSmallCreditDownIcon", iconDown: "optionsSmallCreditDownIcon"});
            yOffset += buttonSize.height + buttonMargin;
            gameButton.setTransform(xOffset, yOffset, 1, 1);
            buttonsGroup.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
        // center the group in the popup
        buttonsGroup.setTransform((this.backgroundWidth - groupWidth) * 0.5, (this.backgroundHeight - groupHeight) * 0.5, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(buttonsGroup);
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    showHelp: function () {
        // Position a DOM element and close. DOM element is responsible to close itself.
        var pageElement = document.getElementById('helpArea');
        pageElement.style.display = 'block';
    },


    killScreen: function () {
        // remove all display objects and object references:
        var i;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.audioOnButtonInstance = null;
        this.audioOffButtonInstance = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GameResults.js
 *
 * Show the results screen, either for a game or for the end of a level.
 * Waits for the user to indicate they are ready to move on then stateCompleteCallback is called.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.GameResults = {
    stateCompleteCallback: null,
    levelData: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    animationDisplayObject: null,
    buttonInstances: null,
    spriteData: null,
    gemSprite: null,
    gemSpriteFinalPosition: null,
    matchBonusText: null,
    comboBonusText: null,
    currentScoreTextField: null,
    bestScoreTextField: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    marginTop: 0,
    marginLeft: 0,
    totalGameTime: 0,
    timeBonus: 0,
    movesRemainingBonus: 0,
    comboBonus: 0,
    achievementBonus: 0,
    totalMatches: 0,
    totalMisses: 0,
    totalCombos: 0,
    totalMoves: 0,
    unusedMoves: 0,
    accuracy: 0,
    playerScore: 0,
    playerBestScore: 0,
    gameStarsEarned: 0,
    isChallenge: false,
    isEnabled: false,
    lineHeight: 0,
    priorGameData: null,
    gameNumber: 0,
    streakCount: 0,
    starHalfWidth: 0,
    holdThirdStar: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    refreshTimerId: null,
    cacheRefreshCount: 0,


    setup: function (displayObject, nextLevelData, stateCompleteCallbackFunction) {
        var winOrLose,
            displayGameNumber,
            eventDataValue;

        if (this.levelData !== null) {
            return;
        }
        // use the level data to do any level-specific results
        this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
        this.levelData = nextLevelData;
        this.gameNumber = MemoryMatch.isChallengeGame ? 99 : MemoryMatch.gameNumber;
        this.streakCount = 0;
        this.priorGameData = MemoryMatch.getPriorScoreDataForGameNumber(this.gameNumber, null);
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.playerScore = MemoryMatch.gameScore;
        this.totalCombos = MemoryMatch.numberOfCombos;
        this.unusedMoves = MemoryMatch.moveCountDown;
        this.totalMoves = MemoryMatch.levelTolerance - MemoryMatch.moveCountDown;
        this.totalMatches = MemoryMatch.matchCount;
        this.totalMisses = MemoryMatch.missCount;
        this.totalGameTime = MemoryMatch.gameEndTime - MemoryMatch.gameStartTime;
        this.timeBonus = MemoryMatch.calculateTimeBonus();
        this.movesRemainingBonus = MemoryMatch.calculateUnusedMovesBonus();
        this.comboBonus = MemoryMatch.calculateComboBonus();
        this.achievementBonus = MemoryMatch.calculateAchievementBonus();
        this.totalGameTime = MemoryMatch.formatTimeAsString(this.totalGameTime, false, false);
        this.accuracy = MemoryMatch.calculateLevelAccuracy();
        this.gameStarsEarned = MemoryMatch.starsEarnedInCurrentGame();
        this.buttonInstances = [];
        this.playerBestScore = MemoryMatch.priorBestGameScore;
        if (MemoryMatch.levelComplete) {
            winOrLose = "win";
        } else {
            winOrLose = "lose";
        }
        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.playerBeatChallenge && MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.SIMON) {
                this.streakCount = MemoryMatch.gameNumber;
            } else {
                this.streakCount = MemoryMatch.gameNumber - 1;
            }
            displayGameNumber = MemoryMatch.gameLevel * 100;
            eventDataValue = this.streakCount;
        } else {
            displayGameNumber = MemoryMatch.gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel);
            eventDataValue = this.totalMisses;
        }
        this.isEnabled = false;
        enginesisSession.gameTrackingRecord('level', winOrLose, 'Level ' + displayGameNumber.toString(), eventDataValue, null);
    },

    buildScreen: function (autoStart) {
        var hiFiveWord;

        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.animationDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.parentDisplayObject.addChild(this.animationDisplayObject);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.06;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText(this.groupDisplayObject);
        if (MemoryMatch.isChallengeGame) {
            this.setupAward(this.groupDisplayObject);

            hiFiveWord = MemoryMatch.hiFiveEarnedInCurrentGame();
            if (hiFiveWord != null && hiFiveWord.length > 0) {
                MemoryMatch.showMessageBalloon(null, hiFiveWord + '!', 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.2);
            }
        } else {
            this.setupStars(this.groupDisplayObject);
        }
        this.setupTipText(this.groupDisplayObject);
        this.setupLevelText(this.groupDisplayObject);
        this.setupButtons(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        this.groupDisplayObject.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        this.animationDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        var playThisMusic,
            duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        if (MemoryMatch.levelComplete) {
            playThisMusic = "soundWin";
        } else {
            playThisMusic = "soundLose";
        }
        MemoryMatch.playInterstitialMusic(playThisMusic, false);
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        if (MemoryMatch.isChallengeGame) {
            this.isEnabled = true;
            this.flashNextButton();
        }
        if (this.stateCompleteCallback !== null) {
            // stateCompleteCallback();
        }
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        MemoryMatch.stopInterstitialMusic();
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        if (this.stateCompleteCallback !== null) {
            this.stateCompleteCallback(this.closeEventType);
        }
        this.killScreen();
    },

    close: function () {
        MemoryMatch.GameResults.isEnabled = false;
        if (MemoryMatch.GameResults.isShowing()) {
            MemoryMatch.GameResults.closeStartAnimation();
        }
    },

    onClickNext: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "next";
            MemoryMatch.GameResults.close();
        }
    },

    onClickReplay: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "replay";
            MemoryMatch.GameResults.close();
        }
    },

    onClickHome: function (event) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.GameResults.isEnabled) {
            MemoryMatch.GameResults.closeEventType = "home";
            MemoryMatch.GameResults.close();
        }
    },

    refreshCache: function () {
        this.groupDisplayObject.updateCache();
//        MemoryMatch.debugLog("Cache updated " + this.cacheRefreshCount ++);
    },

    flashNextButton: function () {
        if (this.buttonInstances.length > 2) {
            this.buttonInstances[2].setFlashing(true);
            this.startRefreshInterval();
        }
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupStars: function (groupDisplayObject) {
        var i,
            starFrame = "gameOverStarFill",
            starWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][2],
            starHeight = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][3],
            slotFrame = "gameOverStarEmpty",
            slotWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[slotFrame][0]][2],
            slotHeight = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[slotFrame][0]][3],
            starSprite,
            starSpriteCloned,
            slotSprite,
            slotSpriteCloned,
            starGap = 36 * MemoryMatch.stageScaleFactor,
            topMargin = Math.floor(this.backgroundHeight * 0.12),
            starsTotalWidth = (3 * (slotWidth + starGap)) - starGap,
            startX = Math.floor((this.backgroundWidth - starsTotalWidth) * 0.5),
            animator,
            starAnimationDelay = 800;

        if (this.gameStarsEarned === 3) { // we hold back the 3rd star for extra affect
            this.holdThirdStar = true;
        } else {
            this.holdThirdStar = null;
        }
        for (i = 0; i < MemoryMatch.GameSetup.numberOfStars; i ++) {
            if (i === 0) {
                starSprite = new createjs.Sprite(this.spriteData, starFrame);
                slotSprite = new createjs.Sprite(this.spriteData, slotFrame);
                starSprite.framerate = 1;
                slotSprite.framerate = 1;
                starSprite.visible = false;
                slotSprite.visible = true;
                starSpriteCloned = starSprite;
                slotSpriteCloned = slotSprite;
            } else {
                starSpriteCloned = starSprite.clone();
                slotSpriteCloned = slotSprite.clone();
            }
            slotSpriteCloned.setTransform(startX, topMargin);
            groupDisplayObject.addChild(slotSpriteCloned);
            if (i < this.gameStarsEarned) {
                starSpriteCloned.setTransform(startX + (slotWidth - starWidth) - 1, topMargin + (slotHeight - starHeight) - 1);
                starSpriteCloned.visible = false;
                starSpriteCloned.starNumber = i + 1;
                groupDisplayObject.addChild(starSpriteCloned);
                if (i === 2 && this.holdThirdStar) {
                    this.holdThirdStar = starSpriteCloned;
                } else {
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(starSpriteCloned, starAnimationDelay + (500 * i), 0, false, null, this.showStar.bind(this));
                    animator.showAtBegin = true;
                }
            }
            startX += slotWidth + starGap;
        }
    },

    showStar: function (starSprite) {
        var numberOfParticles,
            hiFiveWord,
            starFrame = "gameOverStarFill",
            starHalfWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[starFrame][0]][2] * 0.5,
            globalStarPoint = this.groupDisplayObject.localToGlobal(starSprite.x, starSprite.y);

        if (starSprite.starNumber < 3) {
            numberOfParticles = Math.random() * 100 + 30;
        } else {
            numberOfParticles = Math.random() * 120 + 50;
            hiFiveWord = MemoryMatch.hiFiveEarnedInCurrentGame();
            if (hiFiveWord != null && hiFiveWord.length > 0) {
                MemoryMatch.showMessageBalloon(null, hiFiveWord + '!', 0, starSprite.x, starSprite.y);
            }
        }
        MemoryMatch.AnimationHandler.startSplatterParticles(numberOfParticles, globalStarPoint.x + starHalfWidth, globalStarPoint.y + starHalfWidth);
        this.refreshCache();
        MemoryMatch.triggerSoundFx("soundBump");
        if (MemoryMatch.isChallengeGame) {
            this.isEnabled = true;
            this.flashNextButton();
        }
    },

    showThirdStar: function (delay) {
        var animator;

        if (this.holdThirdStar !== null) {
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.holdThirdStar, delay, 0, false, null, this.showStar.bind(this));
            animator.showAtBegin = true;
            this.holdThirdStar = null;
            MemoryMatch.triggerSoundFx("soundBonus", {delay: delay});
        }
    },

    setupAward: function (groupDisplayObject) {

        // Show Award instead of stars

        var spriteFrame = 'mapTrophy',
            spriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            imageSprite = new createjs.Sprite(spriteData, spriteFrame),
            spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, spriteFrame),
            position,
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        position = {x: this.backgroundWidth * 0.5, y: this.backgroundHeight * 0.22};
        imageSprite.setTransform(position.x, position.y, 0.5, 0.5, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= spriteSize.width * 0.25;
        position.y -= spriteSize.height * 0.25;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform(position.x + (gemPosition.x * 0.5 * MemoryMatch.stageScaleFactor), position.y + (gemPosition.y * 0.5 * MemoryMatch.stageScaleFactor), 0.5, 0.5);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
            if (MemoryMatch.levelComplete && imageSprite.visible && landNumber == MemoryMatch.gameLevel) {
                spriteSize = MemoryMatch.getSpriteFrameSize(spriteFrames, gemName);
                this.gemSprite = imageSprite.clone();
                this.gemSprite.width = spriteSize.width;
                this.gemSprite.height = spriteSize.height;
                this.gemSpriteFinalPosition = {x: imageSprite.x + spriteSize.width * 0.5, y: imageSprite.y + spriteSize.height * 0.5};
                this.animateGemToAward();
            }
        }
    },

    setupTitleText: function (groupDisplayObject) {

        // Show the icon representing the level and the popup title

        var titleTextField,
            levelSummary,
            iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].iconPopup,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon);

        iconSprite.setTransform(this.marginLeft - (spriteSize.width * 0.25), this.marginTop - (spriteSize.height * 0.25), iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";
        groupDisplayObject.addChild(iconSprite);

        if (MemoryMatch.isChallengeGame) {
            if (MemoryMatch.levelComplete) {
                levelSummary = "Challenge Complete!";
                if (MemoryMatch.gameLevel < MemoryMatch.GameSetup.levels.length) {
                    levelSummary += " Play On!";
                }
            } else {
                levelSummary = "Challenge Failed! Try Again?";
            }
        } else if (MemoryMatch.levelComplete) {
            levelSummary = "Level " + (MemoryMatch.gameNumber + MemoryMatch.getGameLevelNumberOffset(MemoryMatch.gameLevel)).toString() + " Complete! Play On!";
        } else {
            levelSummary = "Out of Moves! Try Again?";
        }
        titleTextField = new createjs.Text(levelSummary, MemoryMatch.getScaledFontSize(58) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        groupDisplayObject.addChild(titleTextField);
    },

    setupTipText: function (groupDisplayObject) {
        var tipTextField,
            tipText = this.getRandomTip(MemoryMatch.levelComplete);

        tipTextField = new createjs.Text(tipText, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        tipTextField.textAlign = "center";
        tipTextField.x = this.backgroundWidth * 0.5;
        tipTextField.y = this.backgroundHeight * 0.32;
        tipTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        tipTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        tipTextField.lineHeight = tipTextField.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(tipTextField);
    },

    addTextBackgroundSprite: function (groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX) {
        var textBackgroundSprite = textBackgroundSpriteSource.clone(),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'gameOverInfoBoxSmall');
        textBackgroundSprite.x = rightX - spriteSize.width;
        textBackgroundSprite.y = levelTextField.y - (spriteSize.height * 0.5);
        groupDisplayObject.addChild(textBackgroundSprite);
    },

    setupLevelText: function (groupDisplayObject) {
        // Room for 4 lines of text at 28 px line height
        var leftX = this.backgroundWidth * 0.12,
            rightX = this.backgroundWidth * 0.44,
            fieldWidth = this.backgroundWidth * 0.2,
            levelTextField,
            Y,
            animator,
            accuracy,
            starAnimationDelay = 1000,
            fieldOffset = 0,
            fontSize = MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBestScore,
            fontColor = MemoryMatch.GameSetup.guiFontColor,
            fontColorBonus = MemoryMatch.GameSetup.guiFontColorBonus,
            fontSizeDifference,
            textBackgroundSpriteSource,
            animationDisplayObject = this.animationDisplayObject;

        textBackgroundSpriteSource = new createjs.Sprite(this.spriteData, 'gameOverInfoBoxSmall');
        textBackgroundSpriteSource.alpha = 0.1;
        this.lineHeight = 96 * MemoryMatch.stageScaleFactor;
        if ( ! MemoryMatch.isChallengeGame) {
            Y = Math.floor(this.backgroundHeight * 0.5);

            // 1: Misses
            levelTextField = new createjs.Text("Misses:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(this.totalMisses.toString(), fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextMisses.bind(this));
            animator.showAtBegin = true;
            if (this.movesRemainingBonus > 0) {
                this.matchBonusText = new createjs.Text("+ " + this.movesRemainingBonus.toString(), fontSizeBold, fontColorBonus);
                this.matchBonusText.textAlign = "left";
                this.matchBonusText.x = rightX;
                this.matchBonusText.y = Y;
                this.matchBonusText.maxWidth = fieldWidth;
                this.matchBonusText.visible = false;
                animationDisplayObject.addChild(this.matchBonusText);
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.matchBonusText, starAnimationDelay + (750 * fieldOffset), 0, false, null, null);
                animator.showAtBegin = true;
                animator.vAlpha = -0.02;
                animator.vY = -1.2;
                animator.vXscale = 0.1;
                animator.vYscale = 0.1;
//                animator.tickFunction = this.animateBonusTick.bind(this);
            }
            fieldOffset ++;

            // 2: Accuracy
            Y += this.lineHeight;
            accuracy = this.accuracy > 0 ? this.accuracy.toString() + "%" : '--';
            levelTextField = new createjs.Text("Accuracy:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(accuracy, fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateText.bind(this));
            animator.showAtBegin = true;
            fieldOffset ++;

            if (MemoryMatch.gameType != MemoryMatch.GAMEPLAYTYPE.CHAINS) {
                // Combo bonus
                Y += this.lineHeight;
                levelTextField = new createjs.Text("Combos:", fontSize, fontColor);
                levelTextField.textAlign = "left";
                levelTextField.textBaseline = "middle";
                levelTextField.x = leftX;
                levelTextField.y = Y;
                levelTextField.maxWidth = fieldWidth;
                this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.03);
                groupDisplayObject.addChild(levelTextField);

                levelTextField = new createjs.Text(this.totalCombos.toString(), fontSizeBold, fontColor);
                levelTextField.textAlign = "right";
                levelTextField.textBaseline = "middle";
                levelTextField.x = rightX;
                levelTextField.y = Y;
                levelTextField.maxWidth = fieldWidth;
                levelTextField.visible = false;
                groupDisplayObject.addChild(levelTextField);
                animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextComboBonus.bind(this));
                animator.showAtBegin = true;
                this.matchBonusText = null;
                if (this.comboBonus > 0) {
                    this.comboBonusText = new createjs.Text("+ " + this.comboBonus.toString(), fontSizeBold, fontColorBonus);
                    this.comboBonusText.textAlign = "left";
                    this.comboBonusText.x = rightX;
                    this.comboBonusText.y = Y;
                    this.comboBonusText.maxWidth = fieldWidth;
                    this.comboBonusText.visible = false;
                    animationDisplayObject.addChild(this.comboBonusText);
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.comboBonusText, starAnimationDelay + (500 * fieldOffset), 0, false, null, null);
                    animator.showAtBegin = true;
                    animator.vAlpha = -0.02;
                    animator.vY = -1.2;
                    animator.vXscale = 0.1;
                    animator.vYscale = 0.1;
//                    animator.tickFunction = this.animateBonusTick.bind(this);
                }
                fieldOffset ++;
            }

            // Second Column
            leftX = this.backgroundWidth * 0.56;
            rightX = this.backgroundWidth * 0.88;
            Y = Math.floor(this.backgroundHeight * 0.5);

            // Time Bonus
            levelTextField = new createjs.Text("Time Bonus:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.timeBonus), fontSizeBold, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            levelTextField.visible = false;
            groupDisplayObject.addChild(levelTextField);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(levelTextField, starAnimationDelay + (500 * fieldOffset), 0, false, null, this.animateTextTimeBonus.bind(this));
            animator.showAtBegin = true;

            Y += this.lineHeight;
        } else {
            // Centered
            Y = Math.floor(this.backgroundHeight * 0.52);
            leftX = this.backgroundWidth * 0.38;
            rightX = this.backgroundWidth * 0.68;

            // 1: Streak
            levelTextField = new createjs.Text("Streak:", fontSize, fontColor);
            levelTextField.textAlign = "left";
            levelTextField.textBaseline = "middle";
            levelTextField.x = leftX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
            groupDisplayObject.addChild(levelTextField);

            levelTextField = new createjs.Text(this.streakCount.toString(), this.streakCount < 5 ? fontSizeBold : fontSizeBoldBig, fontColor);
            levelTextField.textAlign = "right";
            levelTextField.textBaseline = "middle";
            levelTextField.x = rightX;
            levelTextField.y = Y;
            levelTextField.maxWidth = fieldWidth;
            groupDisplayObject.addChild(levelTextField);

            Y += this.lineHeight;
        }

        // Score
        if (this.playerScore >= this.playerBestScore) {
            fontSizeBestScore = fontSizeBoldBig;
        } else {
            fontSizeBestScore = fontSizeBold;
        }
        levelTextField = new createjs.Text("Score:", fontSize, fontColor);
        levelTextField.textAlign = "left";
        levelTextField.textBaseline = "middle";
        levelTextField.x = leftX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
        groupDisplayObject.addChild(levelTextField);

        levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.playerScore), fontSizeBestScore, fontColor);
        levelTextField.textAlign = "right";
        levelTextField.textBaseline = "middle";
        levelTextField.x = rightX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        levelTextField.name = 'playerscore';
        groupDisplayObject.addChild(levelTextField);
        this.currentScoreTextField = levelTextField;

        // Best Score
        Y += this.lineHeight;
        if (this.playerScore >= this.playerBestScore) {
            fontSizeBestScore = fontSizeBold;
            fontSizeDifference = 0;
            if (this.playerBestScore == 0) {
                this.playerBestScore = this.playerScore;
            }
        } else {
            fontSizeBestScore = fontSizeBoldBig;
            fontSizeDifference = 10 * MemoryMatch.stageScaleFactor;
        }
        levelTextField = new createjs.Text("Best:", fontSize, fontColor);
        levelTextField.textAlign = "left";
        levelTextField.textBaseline = "middle";
        levelTextField.x = leftX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        this.addTextBackgroundSprite(groupDisplayObject, textBackgroundSpriteSource, levelTextField, rightX * 1.02);
        groupDisplayObject.addChild(levelTextField);

        levelTextField = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.playerBestScore), fontSizeBestScore, fontColor);
        levelTextField.textAlign = "right";
        levelTextField.textBaseline = "middle";
        levelTextField.x = rightX;
        levelTextField.y = Y;
        levelTextField.maxWidth = fieldWidth;
        levelTextField.name = 'bestscore';
        groupDisplayObject.addChild(levelTextField);
        this.bestScoreTextField = levelTextField;
        if (MemoryMatch.isChallengeGame) {
            window.setTimeout(this.showBestScoreBurstIfBeatBestScore.bind(this), 500);
        }
    },

    animateText: function (textSprite) {
        if (this.groupDisplayObject != null) {
            this.refreshCache();
            return true;
        } else {
            return false;
        }
    },

    animateTextMisses: function (textSprite) {
        this.playerScore += this.movesRemainingBonus;
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
        }
        this.refreshCache();
    },

    animateTextComboBonus: function (textSprite) {
        this.playerScore += this.comboBonus;
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
        }
        this.refreshCache();
    },

    animateTextTimeBonus: function (textSprite) {

        // This is the final animation update, bump the score/best score if player beats best score.

        var scoreFont,
            fontSizeBold = MemoryMatch.getScaledFontSize(52) + " " + MemoryMatch.GameSetup.guiBoldFontName,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName;

        this.playerScore += this.timeBonus;
        if (this.playerScore >= this.playerBestScore) {
            scoreFont = fontSizeBoldBig;
        } else {
            scoreFont = fontSizeBold;
        }
        if (this.currentScoreTextField !== null) {
            this.currentScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerScore);
            this.currentScoreTextField.font = scoreFont;
        }
        this.showBestScoreBurstIfBeatBestScore();
        this.showThirdStar(250);
        this.isEnabled = true;
        this.flashNextButton();
        this.refreshCache();
    },

//    animateBonusTick: function (textSprite) {
//        this.refreshCache();
//        return textSprite.actor.alpha > 0;
//    },

    showBestScoreBurstIfBeatBestScore: function () {
        // display particle effect if player beat her best score
        var globalTextPoint,
            fontSizeBoldBig = MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName;

        if (this.bestScoreTextField !== null) {
            if (this.playerScore >= this.playerBestScore && this.playerScore != 0) {
                this.playerBestScore = this.playerScore;
                this.bestScoreTextField.text = MemoryMatch.formatNumberWithGroups(this.playerBestScore);
                if (MemoryMatch.levelComplete) {
                    globalTextPoint = this.groupDisplayObject.localToGlobal(this.bestScoreTextField.x, this.bestScoreTextField.y);
                    MemoryMatch.AnimationHandler.startSplatterParticles(Math.random() * 100 + 30, globalTextPoint.x, globalTextPoint.y);
                }
                this.bestScoreTextField.font = fontSizeBoldBig;
                this.refreshCache();
            }
        }
    },

    setupButtons: function (groupDisplayObject) {
        // 2 or 3 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            numberOfButtons = MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN ? 3 : 2,
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.GameSetup.guiSpritesheet1Frames.frames[MemoryMatch.GameSetup.guiSpritesheet1Frames.animations[spriteFrame][0]][2] * buttonScale,
            gameButton,
            buttonTagCounter = 0,
            buttonMargin = 0, // 8 * MemoryMatch.stageScaleFactor;
            totalWidth = (numberOfButtons * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.77,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        gameButton.refreshParent = this;
        groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "replay", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickReplay.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverReplayIcon", iconOver: "gameOverReplayDownIcon", iconDown: "gameOverReplayDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        gameButton.refreshParent = this;
        groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        if (MemoryMatch.gamePlayState == MemoryMatch.GAMEPLAYSTATE.WIN) {
            xOffset += buttonWidth + buttonMargin;
            gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickNext.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
            gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
            gameButton.refreshParent = this;
            groupDisplayObject.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    getRandomTip: function (forTheWin) {
        var tipIndex = MemoryMatch.gameLevel - 1,
            tipsArray = MemoryMatch.GameSetup.tips[tipIndex],
            tipsArrayLength = tipsArray.length,
            tipStartIndex = MemoryMatch.getRandomNumberBetween(0, tipsArrayLength - 1),
            tipIndex = tipStartIndex,
            tip,
            matched = false;

        while ( ! matched) {
            if ((forTheWin && tipsArray[tipIndex].category == 'win') || (! forTheWin && tipsArray[tipIndex].category != 'win')) {
                matched = true;
            } else {
                tipIndex ++;
                if (tipIndex == tipStartIndex) {
                    matched = true; // we scanned the entire array and didn't find a match, just use whatever we got
                } else if (tipIndex == tipsArrayLength) {
                    tipIndex = 0;
                }
            }
        }
        tip = tipsArray[tipIndex].text;
        return tip;
    },

    startRefreshInterval: function () {
        this.refreshTimerId = window.setTimeout(this.refreshInterval.bind(this), 500);
    },

    refreshInterval: function () {
        this.refreshCache();
        this.startRefreshInterval();
    },

    animateGemToAward: function () {
        // gem animation:
        // 1. gem sprite starts centered in popup very large scale
        // 2. gem scales to size and position moves to award
        // 3. done, cleanup

        var animator,
            startAlpha = 0.4,
            startScale = 14,
            endScale = 0.75,
            duration = 0.8,
            steps;

        if (this.gemSprite != null) {
            this.gemSprite.setTransform(this.backgroundWidth * 0.5, this.backgroundHeight * 0.5, startScale, startScale, 0, 0, 0, this.gemSprite.width * 0.5, this.gemSprite.height * 0.5);
            this.gemSprite.alpha = startAlpha;
            this.animationDisplayObject.addChild(this.gemSprite);
            steps = MemoryMatch.fps * duration;
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.gemSprite, 300, 0, false, null, this.gemAnimationComplete.bind(this));
            animator.vX = (this.gemSpriteFinalPosition.x - this.gemSprite.x) / steps;
            animator.endX = this.gemSpriteFinalPosition.x;
            animator.vY = (this.gemSpriteFinalPosition.y - this.gemSprite.y) / steps;
            animator.endY = this.gemSpriteFinalPosition.y;
            animator.vAlpha = (1 - startAlpha) / steps;
            animator.endAlpha = 1;
            animator.vXScale = -1 * (startScale - endScale) / steps;
            animator.endXScale = 0.75;
            animator.vYScale = animator.vXScale;
            animator.endYScale = animator.endXScale;
            animator.tickFunction = this.gemAnimationUpdate.bind(this);
        }
    },

    gemAnimationUpdate: function (animator) {
        var stillAnimating = false,
            endScale = 0.75;

        if (this.animationDisplayObject != null) {
            if (animator.actor.alpha != 1 || animator.actor.scaleX != endScale) {
                stillAnimating = true;
            }
        }
        return stillAnimating;
    },

    gemAnimationComplete: function (actor) {
        var globalCardPoint = this.groupDisplayObject.localToGlobal(this.gemSprite.x, this.gemSprite.y);
        MemoryMatch.AnimationHandler.startSplatterStars(Math.random() * 120 + 100, globalCardPoint.x, globalCardPoint.y);
        MemoryMatch.triggerSoundFx("soundBump");
        this.animationDisplayObject.removeChild(this.gemSprite);
        this.gemSprite = null;
        this.gemSpriteFinalPosition = null;
        this.refreshCache();
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i;

        if (this.refreshTimerId != null) {
            window.clearTimeout(this.refreshTimerId);
            this.refreshTimerId = null;
        }
        this.spriteData = null;
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.backgroundSoundInstance != null) {
            this.backgroundSoundInstance.stop();
            this.backgroundSoundInstance = null;
        }
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.currentScoreTextField = null;
        this.bestScoreTextField = null;
        this.matchBonusText = null;
        this.comboBonusText = null;
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * GUIButton.js
 *
 * GUI buttons are buttons built from composite parts with specific functionality:
 *   Display a button back, an Icon (optional), text (optional)
 *   Supports display and behavior for active and disabled states
 *   Support for standard event states: rollover, rollout, up, down, pressed
 *   Call a function when clicked
 *   Supports a blinking state
 *   This is an auto-creating object you should just call teh constructor of these and release it when you are done.
 *
 *   To create one of these, call GUIButton(parameters) where parameters is an object with the following properties:
 *      baseUp: sprite frame reference of the button back when enabled/up
 *      baseDisabled: sprite frame reference of the button back when disabled
 *      baseOver: sprite frame reference of the button back when mouse over
 *      baseDown: sprite frame reference of the button back when pressed
 *      text: the text to show on the button. If there is an icon, text is left justified to the icon. If no icon, text is centered
 *      addTextShadow: true will add a shadow to the text
 *      icon Up/Over/Down: if there is no text, icon is centered. If there is text icon is left justified
 *      callback: function to call when click event generated. parameter is the button name.
 *      name: unique name of this button
 *      tag: unique tag number of this button
 *      disabled: show button is the disabled state, otherwise the button is enabled
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.GUIButton = function (parameters) {
    var guiButton = new createjs.Container();

    guiButton.callback = null;
    guiButton.buttonSprite = null;
    guiButton.iconSprite = null;
    guiButton.text = null;
    guiButton.addTextShadow = false;
    guiButton.name = "button";
    guiButton.tag = 0;
    guiButton.buttonScale = 1;
    guiButton.disabled = false;
    guiButton.forceDisabledDisplay = false;
    guiButton._isPressed = false;
    guiButton._isOver = false;
    guiButton._isFlashing = false;
    guiButton.spriteFrames = null;
    guiButton.spriteData = null;
    guiButton.shadowSource = null;
    guiButton.buttonFaceActive = null;
    guiButton.buttonFaceOver = null;
    guiButton.buttonFaceDown = null;
    guiButton.buttonFaceDisabled = null;
    guiButton.buttonBaseActive = null;
    guiButton.buttonBaseOver = null;
    guiButton.buttonBaseDown = null;
    guiButton.buttonBaseDisabled = null;
    guiButton.buttonBaseColor = null;
    guiButton.buttonBaseRollOverColor = null;
    guiButton.spriteSheet = guiButton.spriteData;
    guiButton.buttonColorFilter = null;
    guiButton.buttonRollOverColorFilter = null;
    guiButton.refreshParent = null;
    guiButton.flashingTimerId = null;
    guiButton.flashingCounter = null;
    guiButton.flashingInterval = 500;

    guiButton.setParameters = function (parameters) {
        if (parameters != null) {
            if (parameters.text != null) {
                guiButton.text = parameters.text;
            }
            if (parameters.name != null) {
                guiButton.name = parameters.name;
            }
            if (parameters.tag != null) {
                guiButton.tag = parseInt(parameters.tag);
            }
            if (parameters.callback != null) {
                guiButton.callback = parameters.callback;
            }
            if (parameters.disabled != null) {
                guiButton.disabled = parameters.disabled;
            }
            if (parameters.baseUp != null) {
                guiButton.buttonBaseActive = parameters.baseUp;
            }
            if (parameters.baseOver != null) {
                guiButton.buttonBaseOver = parameters.baseOver;
            }
            if (parameters.baseDown != null) {
                guiButton.buttonBaseDown = parameters.baseDown;
            }
            if (parameters.baseDisabled != null) {
                guiButton.buttonBaseDisabled = parameters.baseDisabled;
            }
            if (parameters.buttonBaseColor != null) {
                guiButton.buttonBaseColor = parameters.buttonBaseColor;
            }
            if (parameters.buttonBaseRollOverColor != null) {
                guiButton.buttonBaseRollOverColor = parameters.buttonBaseRollOverColor;
            }
            if (parameters.icon != null) {
                guiButton.buttonFaceActive = parameters.icon;
            }
            if (parameters.iconUp != null) {
                guiButton.buttonFaceActive = parameters.iconUp;
            }
            if (parameters.iconDown != null) {
                guiButton.buttonFaceDown = parameters.iconDown;
            }
            if (parameters.iconOver != null) {
                guiButton.buttonFaceOver = parameters.iconOver;
            }
            if (parameters.iconDisabled != null) {
                guiButton.buttonFaceDisabled = parameters.iconDisabled;
            }
            if (parameters.addTextShadow != null) {
                guiButton.addTextShadow = parameters.addTextShadow;
            }
            if (parameters.spriteFrames != null) {
                guiButton.spriteFrames = parameters.spriteFrames;
            } else {
                guiButton.spriteFrames = MemoryMatch.GameSetup.guiSpritesheet1Frames;
            }
            // set defaults for things not provided
            if (guiButton.buttonBaseOver == null) {
                guiButton.buttonBaseOver = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonBaseDown == null) {
                guiButton.buttonBaseDown = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonBaseDisabled == null) {
                guiButton.buttonBaseDisabled = guiButton.buttonBaseActive;
            }
            if (guiButton.buttonFaceOver == null) {
                guiButton.buttonFaceOver = guiButton.buttonFaceActive;
            }
            if (guiButton.buttonFaceDown == null) {
                guiButton.buttonFaceDown = guiButton.buttonFaceActive;
            }
            if (guiButton.buttonFaceDisabled == null) {
                guiButton.forceDisabledDisplay = true;
                guiButton.buttonFaceDisabled = guiButton.buttonFaceActive;
            }
            if (this.name == null) {
                this.name = 'button' + this.tag.toString();
            }
            guiButton.spriteData = new createjs.SpriteSheet(guiButton.spriteFrames);
        }
    }

    guiButton.createButton = function () {
        var spriteFrame,
            buttonSize,
            buttonColor;

        if (this.disabled) {
            spriteFrame = this.buttonBaseDisabled;
        } else {
            spriteFrame = this.buttonBaseActive;
        }
        if (this.buttonSprite == null) {
            this.buttonSprite = new createjs.Sprite(this.spriteData, spriteFrame);
            this.buttonSprite.name = "button";
            this.buttonSprite.framerate = 1;
            this.addChild(this.buttonSprite);
        }
        buttonSize = MemoryMatch.getSpriteFrameSize(this.spriteFrames, spriteFrame);
        this.width = buttonSize.width * this.buttonScale;
        this.height = buttonSize.height * this.buttonScale;
        this.buttonSprite.hitArea = new createjs.Shape(new createjs.Graphics().beginFill('909090').drawRect(0, 0, this.width, this.height));
        this.flashingCounter = 0;
        this.setTransform(0, 0, this.buttonScale, this.buttonScale);
        this.createButtonIcon();
        this.createButtonText();
        if (this.buttonBaseColor != null) {
            buttonColor = MemoryMatch.htmlColorStringToColorArray(this.buttonBaseColor);
            this.buttonColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonColor[0], buttonColor[1], buttonColor[2], 0);
            this.buttonSprite.filters = [this.buttonColorFilter];
            this.buttonSprite.cache(0, 0, buttonSize.width, buttonSize.height);
            if (this.buttonBaseRollOverColor != null) {
                buttonColor = MemoryMatch.htmlColorStringToColorArray(this.buttonBaseRollOverColor);
                this.buttonRollOverColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonColor[0], buttonColor[1], buttonColor[2], 0);
            }
        }
        if ( ! this.disabled) {
            this.setEnabled(true);
            this.handleEvent({type: "rollout"});
        } else {
            this.showEnabled(false);
        }
    };

    guiButton.createButtonText = function () {

        // this logic assumes the icon was dealt with first, so we can position text based on the icon position

        var buttonText = new createjs.Text(this.text, MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor),
            lineHeight = buttonText.getMeasuredLineHeight();

        if (this.iconSprite == null) {
            buttonText.textAlign = "center";
            buttonText.x = this.width * 0.5;
            buttonText.maxWidth = this.width;
        } else {
            buttonText.textAlign = "left";
            buttonText.x = this.iconSprite.x + this.iconSprite.width;
            buttonText.maxWidth = this.width - this.iconSprite.width;
        }
        buttonText.y = (this.height - lineHeight) * 0.5;
        buttonText.visible = true;
        buttonText.name = "buttonText";
        if (this.addTextShadow) {
            if (this.shadowSource == null) {
                this.shadowSource = new createjs.Shadow("#000000", 2, 2, 10);
            }
        }
        buttonText.shadow = this.shadowSource;
        this.addChild(buttonText);
    };

    guiButton.setButtonText = function (newText) {
        var buttonText = this.getChildByName("buttonText");

        this.text = newText;
        if ( buttonText == null) {
            this.createButtonText();
        } else {
            buttonText.text = this.text;
        }
    };

    guiButton.setText = function (text) {
        this.setButtonText(text);
    };

    guiButton.createButtonIcon = function () {
        var icon,
            spriteSize,
            x,
            y;

        if (this.iconSprite == null && this.buttonFaceActive != null) {
            icon = new createjs.Sprite(this.spriteData, this.buttonFaceActive);
            spriteSize = MemoryMatch.getSpriteFrameSize(this.spriteFrames, this.buttonFaceActive);
            icon.framerate = 1;
            icon.name = "buttonIcon";
            y = (this.height - spriteSize.height) * 0.5;
            if (this.text == null) {
                x = (this.width - spriteSize.width) * 0.5
            } else {
                x = 0;
            }
            icon.setTransform(x, y, 1, 1);
            icon.width = spriteSize.width;
            icon.height = spriteSize.height;
            this.addChild(icon);
            this.iconSprite = icon;
        }
    };

    guiButton.setIcon = function (spriteFrame) {
        if (this.iconSprite != null) {
            this.iconSprite.gotoAndStop(spriteFrame);
        }
    };

    guiButton.getSize = function () {
        return {width: this.width, height: this.height};
    };

    guiButton.handleEvent = function (event) {
        var spriteFrameBase,
            spriteFrameIcon,
            eventType = event.type,
            clicked = false;

        switch (eventType) {
            case "click":
                break;
            case "mousedown":
                this._isPressed = true;
                spriteFrameBase = this.buttonBaseDown;
                spriteFrameIcon = this.buttonFaceDown;
                if (this.buttonBaseRollOverColor != null) {
                    this.buttonSprite.filters = [this.buttonRollOverColorFilter];
                    this.buttonSprite.updateCache();
                }
                break;
            case "rollover":
                if (this._isPressed) {
                    spriteFrameBase = this.buttonBaseDown;
                    spriteFrameIcon = this.buttonFaceDown;
                } else {
                    spriteFrameBase = this.buttonBaseOver;
                    spriteFrameIcon = this.buttonFaceOver;
                }
                break;
            case "pressup":
                this._isPressed = false;
                if (this._isOver) {
                    spriteFrameBase = this.buttonBaseOver;
                    spriteFrameIcon = this.buttonFaceOver;
                } else {
                    spriteFrameBase = this.buttonBaseActive;
                    spriteFrameIcon = this.buttonFaceActive;
                }
                if (this.buttonBaseRollOverColor != null && this.buttonBaseColor != null) {
                    this.buttonSprite.filters = [this.buttonColorFilter];
                    this.buttonSprite.updateCache();
                }
                clicked = true;
                break;
            case "rollout":
            default:
                if (this._isPressed) {
                    spriteFrameBase = this.buttonBaseDown;
                    spriteFrameIcon = this.buttonFaceDown;
                } else {
                    spriteFrameBase = this.buttonBaseActive;
                    spriteFrameIcon = this.buttonFaceActive;
                }
                break;
        }
        if (this.buttonSprite != null && spriteFrameBase != null) {
            this.buttonSprite.gotoAndStop(spriteFrameBase);
        }
        if (this.iconSprite != null && spriteFrameIcon != null) {
            this.iconSprite.gotoAndStop(spriteFrameIcon);
        }
        if (this.refreshParent != null && this.refreshParent.refreshCache != null) {
            this.refreshParent.refreshCache();
        }
    };

    guiButton.onClicked = function (event) {
        if (event != null && event.target != null) {
            var that = event.target.parent;
            if (that.callback != null) {
                MemoryMatch.triggerSoundFx("soundTap");
                that.callback(that.name); // fire the callback function and let them know who was clicked
            }
        }
    };

    guiButton.show = function (showFlag) {
        this.visible = showFlag;
    };

    guiButton.enable = function () {
        // show button in the enabled state
        if (this.disabled) {
            this.setEnabled(true);
            this.showEnabled(true);
            this.handleEvent({type: "rollout"});
        }
    };

    guiButton.disable = function () {
        // show button in the disabled state
        this.setEnabled(false);
        this.showEnabled(false);
    };

    guiButton.setEnabled = function (enableFlag) {
        if (enableFlag) {
            this.disabled = false;
            this.cursor = "pointer";
            this.addEventListener("click", this.onClicked);
            this.addEventListener("rollover", this);
            this.addEventListener("rollout", this);
            this.addEventListener("mousedown", this);
            this.addEventListener("pressup", this);
        } else {
            this.disabled = true;
            this.cursor = null;
            this.removeEventListener("click", this.onClicked);
            this.removeEventListener("rollover", this);
            this.removeEventListener("rollout", this);
            this.removeEventListener("mousedown", this);
            this.removeEventListener("pressup", this);
        }
    };

    guiButton.showEnabled = function (enableFlag) {
        var alpha = 1,
            buttonBase,
            buttonFace,
            buttonText = this.getChildByName("buttonText");

        if (enableFlag) {
            buttonBase = this.buttonBaseActive;
            buttonFace = this.buttonFaceActive;
            if (this.forceDisabledDisplay) {
                buttonText = this.getChildByName("buttonText");
            }
        } else {
            if (this.forceDisabledDisplay) {
                alpha = 0.4;
                buttonText = this.getChildByName("buttonText");
            }
            buttonBase = this.buttonBaseDisabled;
            buttonFace = this.buttonFaceDisabled;
        }
        if (this.buttonSprite != null) {
            this.buttonSprite.gotoAndStop(buttonBase);
            this.buttonSprite.alpha = alpha;
        }
        if (this.iconSprite != null) {
            this.iconSprite.gotoAndStop(buttonFace);
            this.iconSprite.alpha = alpha;
        }
        if (buttonText != null) {
            buttonText.alpha = alpha;
        }
    };

    guiButton.setFlashing = function (flashingFlag) {
        this._isFlashing = flashingFlag;
        if (this._isFlashing && this.flashingTimerId == null) {
            this.flashingCounter = 1;
            this.updateFlashing();
        } else if ( ! this._isFlashing) {
            this.flashingCounter = 0;
            if (this.flashingTimerId != null) {
                window.clearTimeout(this.flashingTimerId);
                this.flashingTimerId = null;
            }
        }
    };

    guiButton.updateFlashing = function () {
        var buttonText = this.getChildByName("buttonText"),
            alpha;

        if (this._isFlashing) {
            this.flashingCounter ++;
            alpha = this.flashingCounter % 2 == 0 ? 0.3 : 1.0;
            this.flashingTimerId = window.setTimeout(this.updateFlashing.bind(this), this.flashingInterval);
        } else {
            alpha = 1;
        }
        if (this.iconSprite != null) {
            this.iconSprite.alpha = alpha;
        }
        if (buttonText != null) {
            buttonText.alpha = alpha;
        }
    };

    guiButton.toString = function () {
        return "[GUIButton] name=" + this.name + "; tag=" + this.tag.toString() + "; enabled=" + (this.disabled ? "NO" : "YES");
    };

    guiButton.kill = function () {
        if (this.flashingTimerId != null) {
            window.clearTimeout(this.flashingTimerId);
            this.flashingTimerId = null;
        }
        this.buttonColorFilter = null;
        this.buttonRollOverColorFilter = null;
        this.removeAllEventListeners();
        this.removeAllChildren();
        this.shadowSource = null;
        this.callback = null;
        this.spriteData = null;
        this.iconSprite = null;
        this.text = null;
    };

    guiButton.setParameters(parameters);
    guiButton.createButton();
    return guiButton;
};

/**
 * InfoPopup.js
 *
 * Show a generic popup that can be used for informational or error messages.
 * Construct one of these with a parameters object using this format:
 * {width: 300, height: 90, title: 'Title', message: 'Message', icon: 'iconCards', sound: 'soundAsset', borderColor:'#FFFFFF', backgroundColor: '#FFFFFF', callback: function}
 *
 */
// namespace to MemoryMatch
MemoryMatch = MemoryMatch || {};

(function() {

    'use strict';

    var InfoPopup = function(displayObject, autoStart, parameters) {
        this.setParameters(displayObject, parameters);
        this.buildScreen(autoStart);
    };
    var p = InfoPopup.prototype;

    p.stateCompleteCallback = null;
    p.parentDisplayObject = null;
    p.groupDisplayObject = null;
    p.x = 0;
    p.y = 0;
    p.width = -1;
    p.height = -1;
    p.marginTop = 0;
    p.marginLeft = 0;
    p.centerX = 0;
    p.marginX = 0;
    p.lineHeight = 0;
    p.title = null;
    p.message = null;
    p.icon = null;
    p.sound = null;
    p.displayDuration = 2.5;
    p.fadeTime = 1;
    p.borderColor = MemoryMatch.GameSetup.achievementBorderColor; // '#d640d6';
    p.backgroundColor = MemoryMatch.GameSetup.achievementBackgroundColor; // '#521852';

    p.setParameters = function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        if (parameters !== null) {
            if (parameters.x != null) {
                this.x = parameters.x;
            } else if (this.x < 1) {
                this.x = this.parentDisplayObject.canvas.width * 0.5;
            }
            if (parameters.y != null) {
                this.y = parameters.y;
            } else if (this.y < 1) {
                this.y = this.parentDisplayObject.canvas.height * 0.5;
            }
            if (parameters.width != null) {
                this.width = parameters.width;
            } else if (this.width < 1) {
                this.width = 900;
            }
            this.width *= MemoryMatch.stageScaleFactor;
            if (parameters.height != null) {
                this.height = parameters.height;
            } else if (this.height < 1) {
                this.height = 270;
            }
            this.height *= MemoryMatch.stageScaleFactor;
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.icon != null) {
                this.icon = parameters.icon;
            } else if (this.icon == null) {
                this.icon = null;
            }
            if (parameters.backgroundColor != null) {
                this.backgroundColor = parameters.backgroundColor;
            }
            if (parameters.borderColor != null) {
                this.borderColor = parameters.borderColor;
            }
            if (parameters.sound != null) {
                this.sound = parameters.sound;
            }
            if (parameters.duration != null) {
                this.displayDuration = parameters.duration;
            }
            if (parameters.callback !== null) {
                this.stateCompleteCallback = parameters.callback;
            }
        }
    };

    p.drawBackground = function () {
        var shape = new createjs.Shape();
        shape.x = 0;
        shape.y = 0;
        var graphics = shape.graphics;
        graphics.beginFill(this.backgroundColor);
        graphics.beginStroke(this.borderColor);
        graphics.setStrokeStyle(3);
        graphics.drawRoundRect(0, 0, this.width, this.height, 12);
        this.groupDisplayObject.addChild(shape);
        return shape;
    };

    p.buildScreen = function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.marginTop = 8 * MemoryMatch.stageScaleFactor;
        this.marginLeft = 8 * MemoryMatch.stageScaleFactor;
        this.drawBackground();
        this.setupIcon();
        this.setupTitleText();
        this.setupMessageText();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.x, this.y, 1, 1, 0, 0, 0, this.width * 0.5, this.height * 0.5);
        this.groupDisplayObject.visible = true;
        if (autoStart === null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    };

    p.start = function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.closeStartAnimation();
        if (this.sound != null) {
            MemoryMatch.triggerSoundFx(this.sound, {delay: 0});
        }
    };

    p.closeStartAnimation = function () {
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, this.displayDuration * 1000, this.fadeTime * 1000, true, null, this.closeComplete.bind(this));
        animator.showAtBegin = true;
        animator.vAlpha = -1 / (this.fadeTime * MemoryMatch.fps);
        animator.endAlpha = 0;
    };

    p.closeComplete = function () {
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback("close");
        }
        this.killObject();
    };

    p.setupIcon = function () {
        // add the icon on top of the button frame
        if (this.icon != null) {
            var spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
            var iconSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, this.icon);
            var iconSprite = new createjs.Sprite(spriteData, this.icon);
            iconSprite.setTransform(this.width * 0.02, (this.height - iconSize.height) * 0.5, 1, 1);
            iconSprite.framerate = 1;
            iconSprite.name = "icon";
            this.groupDisplayObject.addChild(iconSprite);
        }
    };

    p.setupTitleText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.width * 0.5;
        titleTextField.y = this.height * 0.1;
        titleTextField.lineWidth = this.width * 0.8;
        titleTextField.maxWidth = this.width * 0.8;
        titleTextField.name = "title";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.setupMessageText = function () {
        var titleTextField;
        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.width * 0.5;
        titleTextField.y = this.height * 0.34;
        titleTextField.lineWidth = this.width * 0.8;
        titleTextField.maxWidth = this.width * 0.8;
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        titleTextField.name = "message";
        this.groupDisplayObject.addChild(titleTextField);
    };

    p.isShowing = function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    };

    p.killObject = function () {
        // remove all display objects and object references:
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    };

    MemoryMatch.InfoPopup = InfoPopup;

}());

/**
 * LevelButton.js
 *
 * Level buttons are display object containers that support some unique functionality:
 *   Display the game number
 *   Show number of stars earned
 *   Show best score
 *   Show different states for locked, unlocked, played
 *   Show different states for Challenge levels
 *   ...and act like a button!
 */
this.MemoryMatch = this.MemoryMatch || {};

this.MemoryMatch.LevelButton = function (parameters) {
    var levelButton = new createjs.Container();

    levelButton.callback = null;
    levelButton.width = 0;
    levelButton.height = 0;
    levelButton.gameNumber = 0;
    levelButton.landNumber = 0;
    levelButton.starsEarned = 0;
    levelButton.maxStars = 3;
    levelButton.showStarsForChallenge = false;
    levelButton.bestScore = 0;
    levelButton.wasPlayed = false;
    levelButton.isLocked = true;
    levelButton.isChallengeGame = false;
    levelButton.userBeatChallenge = false;
    levelButton.buttonScale = 1.0;
    levelButton.addShadow = false;
    levelButton.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.mapSpritesheetFrames);
    levelButton.shadowSource = null;
    levelButton.nextYPosition = 0;
    levelButton.primaryColor = 'ffffff';
    levelButton.secondaryColor = '000000';
    levelButton.liteColor = 'C0C0C0';
    levelButton.buttonPrimaryColorFilter = null;
    levelButton.buttonSecondaryColorFilter = null;
    levelButton.changeEventNotification = null;


    levelButton.setParameters = function (parameters) {
        if (parameters != null) {
            if (parameters.gameNumber != null) {
                levelButton.gameNumber = parameters.gameNumber;
            }
            if (parameters.landNumber != null) {
                levelButton.landNumber = parameters.landNumber;
            }
            if (parameters.starsEarned != null) {
                levelButton.starsEarned = parameters.starsEarned;
            }
            if (parameters.bestScore != null) {
                levelButton.bestScore = parameters.bestScore;
            }
            if (parameters.wasPlayed != null) {
                levelButton.wasPlayed = parameters.wasPlayed;
            }
            if (parameters.isLocked != null) {
                levelButton.isLocked = parameters.isLocked;
            }
            if (parameters.primaryColor != null) {
                levelButton.primaryColor = parameters.primaryColor;
            }
            if (parameters.secondaryColor != null) {
                levelButton.secondaryColor = parameters.secondaryColor;
            }
            if (parameters.liteColor != null) {
                levelButton.liteColor = parameters.liteColor;
            }
            if (parameters.scale != null) {
                levelButton.buttonScale = parameters.scale;
            }
            if (parameters.addShadow != null) {
                levelButton.addShadow = parameters.addShadow;
                levelButton.shadowSource = new createjs.Shadow("#000000", 2, 2, 10);
            }
            if (parameters.isChallengeGame != null) {
                levelButton.isChallengeGame = parameters.isChallengeGame;
                if (levelButton.isChallengeGame) {
                    levelButton.userBeatChallenge = MemoryMatch.didUserBeatChallenge(levelButton.landNumber);
                }
            }
            if (parameters.callback != null) {
                levelButton.callback = parameters.callback;
            }
            if (parameters.changeEventNotification != null) {
                levelButton.changeEventNotification = parameters.changeEventNotification;
            }
        }
    }

    levelButton.createGameNumberText = function () {
        var gameNumber = this.gameNumber.toString(),
            textColor = this.isChallengeGame ? this.primaryColor : MemoryMatch.GameSetup.mapLevelColor,
            fontSize = this.isChallengeGame ? 56 : 44,
            gameNumberText = new createjs.Text(gameNumber, MemoryMatch.getScaledFontSize(fontSize) + " " + MemoryMatch.GameSetup.guiBoldFontName, textColor),
            button = this.getChildByName('button'),
            textHeight = gameNumberText.getMeasuredLineHeight(),
            useFontPositionHack = MemoryMatch.platform == 'Win32'; // TODO: this is the worst! font does not position the same for Windows as anywhere else.

        gameNumberText.textAlign = "center";
        gameNumberText.x = this.width * 0.5;
        gameNumberText.maxWidth = this.width;
        gameNumberText.color = textColor;
        gameNumberText.visible = true;
        gameNumberText.name = "gameNumber";
        if (this.isChallengeGame) {
            gameNumberText.visible = ! this.isLocked && ! this.userBeatChallenge;
            gameNumberText.y = button.y + ((button.height - textHeight) * 0.54);
        } else {
            gameNumberText.visible = ! this.isLocked;
            gameNumberText.y = button.y + ((button.height - textHeight) * 0.6666);
        }
        if (useFontPositionHack) {
            gameNumberText.y *= 0.9;
        }
        if (this.addShadow && this.shadowSource != null) {
            gameNumberText.shadow = this.shadowSource.clone();
        }
        this.addChild(gameNumberText);
    };

    levelButton.createBestScoreText = function () {
        var bestScoreText = new createjs.Text(MemoryMatch.formatNumberWithGroups(this.bestScore), MemoryMatch.getScaledFontSize(36) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.mapLevelColor);
        bestScoreText.textAlign = "center";
        bestScoreText.x = this.width * 0.5;
        bestScoreText.y = this.nextYPosition;
        bestScoreText.maxWidth = this.width;
        bestScoreText.visible = ! (this.isLocked || ! this.wasPlayed);
        bestScoreText.name = "bestScore";
        if (this.addShadow && this.shadowSource != null) {
            bestScoreText.shadow = levelButton.shadowSource.clone();
        }
        this.addChild(bestScoreText);
        this.height = bestScoreText.y + (bestScoreText.getMeasuredLineHeight() * 2);
    };

    levelButton.createLockIcon = function () {
        var lockIcon,
            spriteFrame = 'levelSelectLock',
            spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][2],
            spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][3],
            button = this.getChildByName('button'),
            regx = spriteWidth * 0.5,
            regy = spriteHeight * 0.5,
            rotation = 15;

        lockIcon = new createjs.Sprite(this.spriteData, spriteFrame);
        lockIcon.setTransform(this.width * 0.5, button.y + (button.height * 0.5), 1, 1, rotation, 0, 0, regx, regy);
        lockIcon.framerate = 0;
        lockIcon.name = 'lock';
        lockIcon.visible = this.isLocked;
        if (this.isChallengeGame) {
            lockIcon.filters = [this.buttonPrimaryColorFilter];
            lockIcon.cache(0, 0, spriteWidth, spriteHeight);
        }
        this.addChild(lockIcon);
    };

    levelButton.createGemIcon = function () {
        var gemIcon,
            spriteFrame = 'mapAwardLand' + this.landNumber.toString(),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.mapSpritesheetFrames, spriteFrame),
            button = this.getChildByName('button'),
            regx = spriteSize.width * 0.5,
            regy = spriteSize.height * 0.5,
            rotation = 0;

        gemIcon = new createjs.Sprite(this.spriteData, spriteFrame);
        gemIcon.setTransform(this.width * 0.5, button.y + (button.height * 0.5), 1, 1, rotation, 0, 0, regx, regy);
        gemIcon.framerate = 0;
        gemIcon.name = 'award';
        gemIcon.visible = ! this.isLocked && this.userBeatChallenge;
        this.addChild(gemIcon);
    };

    levelButton.createStars = function () {
        var i,
            star,
            spriteFrame = "mapStarUnearned",
            spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][2],
            spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrame][0]][3],
            regx = spriteWidth * 0.5,
            regy = spriteHeight * 2,
            x,
            y = regy,
            rotation,
            showStar;

        for (i = 0; i < this.maxStars; i ++) {
            if (i < this.starsEarned) {
                spriteFrame = 'mapStarEarned';
            } else {
                spriteFrame = 'mapStarUnearned';
            }
            if (i == 0) {
                rotation = -45;
                x = spriteWidth * 1.5;
            } else if (i == 2) {
                rotation = 45;
            } else {
                rotation = 0;
                x += spriteWidth * 0.05;
            }
            star = new createjs.Sprite(this.spriteData, spriteFrame);
            star.setTransform(x, y, 1, 1, rotation, 0, 0, regx, regy);
            star.framerate = 0;
            star.name = 'star' + (i + 1);
            if (this.isChallengeGame) {
                showStar = ! this.isLocked && this.showStarsForChallenge;
            } else {
                showStar = ! this.isLocked;
            }
            star.visible = showStar;
            this.addChild(star);
        }
        this.nextYPosition = spriteHeight * 1.1;
        this.width = (spriteWidth * 3);
    };

    levelButton.showStars = function (showFlag) {
        var i,
            star,
            showStar;

        for (i = 0; i < this.maxStars; i ++) {
            star = this.getChildByName('star' + (i + 1));
            if (star != null) {
                if (i < this.starsEarned) {
                    star.gotoAndStop('mapStarEarned');
                } else {
                    star.gotoAndStop('mapStarUnearned');
                }
                if (this.isChallengeGame) {
                    showStar = ! this.isLocked && this.showStarsForChallenge;
                } else {
                    showStar = ! this.isLocked;
                }
                star.visible = showStar;
            }
        }
        this.changeEvent();
    };

    levelButton.removeStars = function () {
        var i,
            star;

        for (i = 0; i < this.maxStars; i ++) {
            star = this.getChildByName('star' + i);
            if (star != null) {
                this.removeChild(star);
            }
        }
    };

    levelButton.createButton = function () {
        var spriteFrameBase = null, // a reference sprite frame, they should all be the same size
            spriteFrameRing,
            spriteFrameRingOver,
            spriteFrameCircle,
            gameButton,
            buttonRing,
            rollOverFrame,
            spriteWidth,
            spriteHeight,
            hitArea,
            buttonPrimaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColor),
            buttonSecondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColor);

        this.buttonPrimaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonPrimaryColor[0], buttonPrimaryColor[1], buttonPrimaryColor[2], 0);
        this.buttonSecondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, buttonSecondaryColor[0], buttonSecondaryColor[1], buttonSecondaryColor[2], 0);
        levelButton.createStars();
        if (this.isChallengeGame) {
            spriteFrameBase = 'bossBase';
            spriteFrameCircle = 'bossCircle';
            spriteFrameRing = 'bossRing';
            spriteFrameRingOver = 'bossRingOver';
        } else {
            spriteFrameBase = 'levelSelectCircle';
            spriteFrameRing = 'levelSelectRing';
            spriteFrameRingOver = 'levelSelectRingOver';
            spriteFrameCircle = null;
        }
        spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrameBase][0]][2] * this.buttonScale;
        spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[spriteFrameBase][0]][3] * this.buttonScale;
        if (this.width < spriteWidth) {
            this.width = spriteWidth;
        }
        gameButton = new createjs.Sprite(this.spriteData, spriteFrameBase);
        gameButton.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        gameButton.framerate = 0;
        gameButton.name = 'button';
        gameButton.filters = [this.buttonSecondaryColorFilter];
        gameButton.cache(0, 0, spriteWidth, spriteHeight);
        gameButton.width = spriteWidth;
        gameButton.height = spriteHeight;
        this.addChildAt(gameButton, 0);
        if (spriteFrameCircle != null) {
            buttonRing = new createjs.Sprite(this.spriteData, spriteFrameCircle);
            buttonRing.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
            buttonRing.framerate = 0;
            buttonRing.name = 'circle';
            buttonRing.visible = ! (this.isLocked || ! this.wasPlayed) || this.isChallengeGame;
            this.addChild(buttonRing);
        }
        buttonRing = new createjs.Sprite(this.spriteData, spriteFrameRing);
        buttonRing.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        buttonRing.framerate = 0;
        buttonRing.name = 'ring';
        if (this.isChallengeGame) {
            buttonRing.filters = [this.buttonPrimaryColorFilter];
            buttonRing.cache(0, 0, spriteWidth, spriteHeight);
        }
        buttonRing.visible = ! (this.isLocked || ! this.wasPlayed) || this.isChallengeGame;
        this.addChild(buttonRing);

        rollOverFrame = new createjs.Sprite(this.spriteData, spriteFrameRingOver);
        rollOverFrame.setTransform(this.width * 0.5, this.nextYPosition, this.buttonScale, this.buttonScale, 0, 0, 0, spriteWidth * 0.5, 0);
        rollOverFrame.visible = false;
        rollOverFrame.name = 'rollover';
        if (this.isChallengeGame) {
            rollOverFrame.filters = [this.buttonPrimaryColorFilter];
            rollOverFrame.cache(0, 0, spriteWidth, spriteHeight);
        }
        this.addChild(rollOverFrame);

        this.nextYPosition += spriteHeight;
        levelButton.createLockIcon();
        if (this.isChallengeGame) {
            levelButton.createGemIcon();
        }
        levelButton.createGameNumberText();
        levelButton.createBestScoreText();
        levelButton.cache(0, 0, this.width, this.height);
        hitArea = new createjs.Shape();
        hitArea.graphics.beginFill("#ff0000").drawRect(0, 0, this.width, this.height);
        levelButton.hitArea = hitArea;
        if ( ! this.isLocked) {
            this.setEnabled(true);
        }
    };

    levelButton.refreshButton = function (parameters) {
        this.setParameters(parameters);
        this.coordinateDisplayInformation();
    };

    levelButton.onLevelSelect = function (event) {
        var that;
        if (event != null && event.target != null) {
            that = event.target;
            if (that.callback == null) {
                that = event.target.parent;
            }
            if (that.callback != null) {
                MemoryMatch.triggerSoundFx("soundTap");
                that.callback(that.gameNumber);
            }
        }
    };

    levelButton.onRollover = function (event) {
        var rollOverFrame = this.getChildByName('rollover'),
            gameNumberText = this.getChildByName('gameNumber');

        if (rollOverFrame != null) {
            rollOverFrame.visible = true;
        }
        if (gameNumberText != null) {
            gameNumberText.color = this.liteColor;
        }
        this.changeEvent();
    };

    levelButton.onRollout = function (event) {
        var rollOverFrame = this.getChildByName('rollover'),
            gameNumberText = this.getChildByName('gameNumber');

        if (rollOverFrame != null) {
            rollOverFrame.visible = false;
        }
        if (gameNumberText != null) {
            gameNumberText.color = this.isChallengeGame ? this.primaryColor : MemoryMatch.GameSetup.mapLevelColor;
        }
        this.changeEvent();
    };

    levelButton.onTouchDown = function (event) {
        if (MemoryMatch.isTouchDevice) {
            this.onRollover(event);
        }
    };

    levelButton.onTouchUp = function (event) {
        if (MemoryMatch.isTouchDevice) {
            this.onRollout(event);
        }
    };

    levelButton.show = function (showFlag) {
        this.visible = showFlag;
        this.changeEvent();
    };

    levelButton.setGameNumber = function (gameNumber) {
        var gameNumberField = this.getChildByName("gameNumber");

        this.gameNumber = gameNumber;
        if (gameNumberField != null) {
            gameNumberField.text = this.gameNumber.toString(); // (this.gameNumber + MemoryMatch.getGameLevelNumberOffset(this.landNumber)).toString();
        }
    };

    levelButton.setStarsEarned = function (numberOfStars) {
        this.showStars(false);
        if (numberOfStars < 0) {
            numberOfStars = 0;
        } else if (numberOfStars > this.maxStars) {
            numberOfStars = this.maxStars;
        }
        this.starsEarned = numberOfStars;
        if (numberOfStars >= 0) {
            this.showStars(true);
        }
    };

    levelButton.setBestScore = function (newScore) {
        this.bestScore = newScore;
        this.coordinateDisplayInformation();
    };

    levelButton.setIsLocked = function (isLocked) {
        this.isLocked = isLocked;
        this.coordinateDisplayInformation();
    };

    levelButton.setWasPlayed = function (wasPlayed) {
        this.wasPlayed = wasPlayed;
        this.coordinateDisplayInformation();
    };

    levelButton.coordinateDisplayInformation = function () {

        // Make sure the level button agrees with the state of the game for this user

        var bestScoreField = this.getChildByName("bestScore"),
            gameNumberText = this.getChildByName("gameNumber"),
            buttonRing = this.getChildByName("ring"),
            lockIcon = this.getChildByName("lock"),
            gemIcon,
            showStarsFlag = false;

        if (this.gameNumber == 1 || this.wasPlayed) {
            this.isLocked = false;
        }
        if (this.isChallengeGame) {
            gemIcon = this.getChildByName("award");
            if (gemIcon != null) {
                gemIcon.visible = false;
            }
        }
        if (this.isLocked) {
            this.setEnabled(false);
            lockIcon.visible = true;
            bestScoreField.visible = false;
            gameNumberText.visible = false;
            buttonRing.visible = false;
        } else {
            this.setEnabled(true);
            lockIcon.visible = false;
            if (this.wasPlayed) {
                if (this.isChallengeGame && this.userBeatChallenge) { // challenge game and user passed challenge
                    if (gemIcon != null) {
                        gemIcon.visible = true;
                        gameNumberText.visible = false;
                    }
                } else {
                    gameNumberText.visible = true;
                }
                bestScoreField.visible = true;
                bestScoreField.text = MemoryMatch.formatNumberWithGroups(this.bestScore);
                buttonRing.visible = true;
                if (this.isChallengeGame) {
                    showStarsFlag = ! this.isLocked && this.showStarsForChallenge;
                } else {
                    showStarsFlag = ! this.isLocked;
                }
            } else {
                gameNumberText.visible = true;
                bestScoreField.visible = false;
                buttonRing.visible = false;
            }
        }
        this.showStars(showStarsFlag);
        if (showStarsFlag) {
            this.setStarsEarned(this.starsEarned);
        }
        this.bestScore = this.bestScore;
        this.changeEvent();
    };

    levelButton.setEnabled = function (enableFlag) {
        if (enableFlag) {
            levelButton.cursor = 'pointer';
            this.addEventListener("click", this.onLevelSelect);
            this.addEventListener("rollover", this.onRollover.bind(this));
            this.addEventListener("rollout", this.onRollout.bind(this));
            this.addEventListener("mousedown", this.onTouchDown.bind(this));
            this.addEventListener("pressup", this.onTouchUp.bind(this));
            this.addEventListener("rollout", this.onTouchUp.bind(this));
        } else {
            levelButton.cursor = null;
            this.removeEventListener("click", this.onLevelSelect);
            this.removeEventListener("rollover", this.onRollover.bind(this));
            this.removeEventListener("rollout", this.onRollout.bind(this));
            this.removeEventListener("mousedown", this.onTouchDown.bind(this));
            this.removeEventListener("pressup", this.onTouchUp.bind(this));
            this.removeEventListener("rollout", this.onTouchUp.bind(this));
        }
    }

    levelButton.kill = function () {
        this.setEnabled(false);
        levelButton.shadowSource = null;
        levelButton.callback = null;
        levelButton.spriteData = null;
        this.removeAllChildren();
    };

    levelButton.toString = function() {
        return "[LevelButton] gameNumber: " + levelButton.gameNumber.toString();
    };

    levelButton.changeEvent = function () {
        this.updateCache();
        if (this.changeEventNotification != null) {
            this.changeEventNotification();
        }
    };

    levelButton.setParameters(parameters);
    levelButton.createButton();
    return levelButton;
};

/**
 * LevelIntroduction.js
 *
 * Introduce a new level. Designed to tell the user how to play the level.
 * This object just layouts out the screen, animates the pieces,
 * and waits for the user to indicate they are ready to play.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.LevelIntroduction = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    boardContainer: null,
    spriteData: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    isEnabled: false,
    animate: true,
    marginTop: 0,
    marginLeft: 0,
    buttonInstances: null,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    gameId: 0,
    level: 0,
    gameNumber: 0,
    captionTextFontSize: 42,
    timerId: null,
    demoTimer: 0,
    demoAnimationState: 1,


    setup: function (displayObject, stateCompleteCallbackFunction, gameId, gameLevel, gameNumber) {
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.isEnabled = false;
        this.gameId = gameId;
        this.level = gameLevel;
        this.gameNumber = gameNumber;
    },

    buildScreen: function (autoStart, animate) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.spriteData = new createjs.SpriteSheet(MemoryMatch.GameSetup.guiSpritesheet1Frames);
        this.setColorFilters();
        this.showBackgroundImage(this.parentDisplayObject.canvas);
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        this.setupLayoutForGameId(this.gameId);
        this.setupButtons();
        if (autoStart == undefined) {
            autoStart = false;
        }
        if (animate === undefined) {
            animate = true;
        }
        this.animate = animate;
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        var duration = 0.3, // seconds of animation
            animator;

        this.demoAnimationState = 1;
        if (this.animate) {
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 0, 0, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationPhaseTwo.bind(this));
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        } else {
            this.isEnabled = true;
            this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
            this.scheduleDemoAnimation(1000);
        }
//        this.groupDisplayObject.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
    },

    startAnimationPhaseTwo: function (sprite) {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.startAnimationComplete.bind(this));

        animator.endYScale = animator.endXScale = 1.0;
        animator.vYScale = animator.vXScale = -1 * (animator.endXScale / (duration * MemoryMatch.fps));
    },

    startAnimationComplete: function (sprite) {
        this.isEnabled = true;
        this.scheduleDemoAnimation(1000);
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        animator.endYScale = animator.endXScale = 1.08;
        animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        if (this.backgroundSoundInstance != null) {
            this.backgroundSoundInstance.stop();
            this.backgroundSoundInstance = null;
        }
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    close: function () {
        this.isEnabled = false;
        if (this.isShowing()) {
            if (this.stateCompleteCallback !== null) {
                this.stateCompleteCallback(this.closeEventType, this.level, this.gameNumber);
            }
            this.closeStartAnimation();
        }
    },

    onClickHome: function (event) {
        if (MemoryMatch.LevelIntroduction.isEnabled) {
            this.closeEventType = 'home';
            this.close();
        }
    },

    onClickContinue: function (event) {
        if (MemoryMatch.LevelIntroduction.isEnabled) {
            this.closeEventType = 'continue';
            this.close();
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function (canvas) {
        // This method will scale the background image to fit the current stage if it is too big.
        var popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect((canvas.width - popupImageAsset.width) * -0.5, (canvas.height - popupImageAsset.height) * -0.5, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);

        this.groupDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupTitleText: function () {

        // Show the icon representing the level and the popup title and subtitle

        var titleTextField,
            gameData = MemoryMatch.getGameData(false),
            iconScale = 1,
            icon = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].iconPopup,
            iconSprite = new createjs.Sprite(this.spriteData, icon),
            spriteSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, icon),
            nextY;

        iconSprite.setTransform(this.marginLeft - (spriteSize.width * 0.25), this.marginTop - (spriteSize.height * 0.25), iconScale, iconScale);
        iconSprite.framerate = 1;
        iconSprite.name = "icon";
        this.groupDisplayObject.addChild(iconSprite);

        titleTextField = new createjs.Text(gameData.levelName, MemoryMatch.getScaledFontSize(58) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
        nextY = titleTextField.y + (titleTextField.getMeasuredLineHeight() * 2);

        titleTextField = new createjs.Text(gameData.levelIntro, MemoryMatch.getScaledFontSize(46) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = nextY;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.lineHeight = titleTextField.getMeasuredLineHeight() * 1.5;
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupLayoutForGameId: function (gameId) {
        var groupDisplayObject = this.groupDisplayObject,
            levelData = MemoryMatch.GameSetup.levels[this.level - 1],
            tipId;

        // convert game id into a tip id
        tipId = levelData.tipId;
        switch (tipId) {
            case 1:
                this.setupLayoutForConcentration(groupDisplayObject);
                break;
            case 2:
                this.setupLayoutForChains(groupDisplayObject);
                break;
            case 3:
                this.setupLayoutForNemesis(groupDisplayObject);
                break;
            case 4:
                this.setupLayoutForHaystack(groupDisplayObject);
                break;
            default:
                break;
        }
    },

    setupLayoutForConcentration: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextMatchLikeCards;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.5, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextClearBoard;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup timer display
        this.setupGameTimerTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.86, middleY);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextPlayQuick;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForChains: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextStudyBoard;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Study swatch
        this.showTimerCountdown(groupDisplayObject, this.backgroundWidth * 0.5, middleY);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextOnlyAFewSeconds;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup 2 chains slots
        this.showChainsPath(groupDisplayObject, this.backgroundWidth * 0.75, middleY, 0.5);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextFindPairs;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForNemesis: function (groupDisplayObject) {
        // 1. setup 4 cards
        // setup caption
        // 2. setup Misses display
        // setup caption
        // 3. setup winebottle
        // setup caption
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextMatchLikeCards;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.5, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextClearBoard;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup Nemesis
        MemoryMatch.Nemesis.layoutNemesisDemo(groupDisplayObject, this.backgroundWidth * 0.88, middleY, 0.3333);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextNemesisGoal;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.8;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.25;
        captionText.maxWidth = this.backgroundWidth * 0.25;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupLayoutForHaystack: function (groupDisplayObject) {
        var captionText,
            caption,
            middleY = this.backgroundHeight * 0.4,
            bottomY = this.backgroundHeight * 0.58;

        // 1. setup 4 cards
        this.buildDemoBoard(groupDisplayObject, this.backgroundWidth * 0.28, this.backgroundHeight * 0.48);

        // setup up text caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextRememberLocation;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.25;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 2. setup Study swatch
        this.showTimerCountdown(groupDisplayObject, this.backgroundWidth * 0.5, middleY);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextOnlyAFewSeconds;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.5;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);

        // 3. setup Misses display
        this.setupMatchCountTextField(groupDisplayObject, (this.backgroundWidth - (300 * MemoryMatch.stageScaleFactor)) * 0.8, middleY, 300 * MemoryMatch.stageScaleFactor, 144 * MemoryMatch.stageScaleFactor);

        // setup caption
        caption = MemoryMatch.GameSetup.GUIStrings.demoTextHaystackGoal;
        captionText = new createjs.Text(caption, MemoryMatch.getScaledFontSize(this.captionTextFontSize) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        captionText.textAlign = "center";
        captionText.x = this.backgroundWidth * 0.75;
        captionText.y = bottomY;
        captionText.lineWidth = this.backgroundWidth * 0.2;
        captionText.maxWidth = this.backgroundWidth * 0.2;
        captionText.lineHeight = captionText.getMeasuredLineHeight() * 1.5;
        groupDisplayObject.addChild(captionText);
    },

    setupMatchCountTextField: function (groupDisplayObject, x, y, width, height) {
        var matchCountLabel,
            matchCountField,
            backgroundShape;

        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRect(0, 0, width, height);
        backgroundShape.alpha = 0.2;
        backgroundShape.setTransform(x, y);
        groupDisplayObject.addChild(backgroundShape);

        matchCountLabel = new createjs.Text("Misses", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        matchCountLabel.textAlign = "right";
        matchCountLabel.textBaseline = "middle";
        matchCountLabel.setTransform(x + (width * 0.65), y + (height * 0.5));
        matchCountLabel.maxWidth = width * 0.75;
        groupDisplayObject.addChild(matchCountLabel);

        matchCountField = new createjs.Text("2", MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiAlertFontColor);
        matchCountField.textAlign = "left";
        matchCountField.textBaseline = "middle";
        matchCountField.setTransform(x + (width * 0.7), y + (height * 0.55));
        matchCountField.maxWidth = width * 0.25;
        matchCountField.name = 'matchCounter';
        groupDisplayObject.addChild(matchCountField);
    },

    setupGameTimerTextField: function (groupDisplayObject, x, y) {
        var maxFieldWidth = 10 * 22 * MemoryMatch.stageScaleFactor,
            fieldHeight,
            gameTimerField = new createjs.Text("0:00", MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);

        gameTimerField.textAlign = "left";
        gameTimerField.textBaseline = "middle";
        fieldHeight = gameTimerField.getMeasuredLineHeight() * 1.3;
        gameTimerField.setTransform(x, y + fieldHeight)
        gameTimerField.maxWidth = maxFieldWidth;
        gameTimerField.name = 'gameTimer';
        groupDisplayObject.addChild(gameTimerField);
    },

    showTimerCountdown: function (groupDisplayObject, x, y) {

        // this is the "Study" timer

        var timerCountdownGroup,
            message,
            containerWidth,
            containerHeight,
            titleTextField,
            titleTextFieldSize,
            backgroundShape,
            timerTextField,
            timerTextFieldSize,
            timerTextFieldAnimate;

        message = 'Study';
        this.demoTimer = 5;
        titleTextField = new createjs.Text(message, MemoryMatch.getScaledFontSize(32) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = 'center';
        titleTextField.name = 'title';

        timerTextField = new createjs.Text(this.demoTimer.toString(), MemoryMatch.getScaledFontSize(56) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        timerTextField.textAlign = 'center';
        timerTextField.name = 'studyTimer';

        titleTextFieldSize = titleTextField.getBounds();
        timerTextFieldSize = timerTextField.getBounds();
        containerWidth = Math.max(titleTextFieldSize.width, timerTextFieldSize.width) * 1.2;
        containerHeight = titleTextFieldSize.height + timerTextFieldSize.height * 1.1;
        titleTextField.x = containerWidth * 0.5;
        timerTextField.x = containerWidth * 0.5;
        titleTextField.y = containerHeight * 0.1;
        timerTextField.y = titleTextField.y + titleTextFieldSize.height;

        backgroundShape = new createjs.Shape();
        backgroundShape.graphics.beginFill("#000000").drawRoundRect(0, 0, containerWidth, containerHeight, 8);
        backgroundShape.alpha = 0.2;
        backgroundShape.name = 'background';

        timerCountdownGroup = new createjs.Container();
        timerCountdownGroup.addChild(backgroundShape);
        timerCountdownGroup.addChild(titleTextField);
        timerCountdownGroup.addChild(timerTextField);
        timerCountdownGroup.setTransform(x - (containerWidth * 0.5), y);
        timerCountdownGroup.name = 'studyGroup';
        groupDisplayObject.addChild(timerCountdownGroup);
    },

    showChainsPath: function (groupDisplayObject, x, y, scale) {
        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            numberOfTiles = 2,
            chainsGroup = new createjs.Container(),
            secondaryColor,
            tileColorFilter,
            tileFrame = "chainCardSlot1",
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame),
            tileGap = 0,
            tileHeight,
            tileSpriteSource = new createjs.Sprite(spriteData, tileFrame),
            tileNumberSource = new createjs.Text("1", MemoryMatch.getScaledFontSize(64) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor),
            i,
            tileSprite,
            tileText,
            totalHeightRequired = numberOfTiles * (tileSize.height + tileGap);

        tileSpriteSource.framerate = 1;
        tileNumberSource.textAlign = 'center';
        tileNumberSource.textBaseline = 'middle';
        tileHeight = tileSize.height; // the first tile is the tallest, use that for reference since all the other tiles are different heights!
        tileGap = tileHeight * 0.25;
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            tileColorFilter = new createjs.ColorFilter(0.5, 0.5, 0.5, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        }
        for (i = 0; i < numberOfTiles; i ++) {
            tileSprite = tileSpriteSource.clone();
            tileText = tileNumberSource.clone();
            switch (i) {
                case 0:
                    tileFrame = "chainCardSlot1";
                    break;
                case 1:
                    tileFrame = "chainCardSlot2";
                    break;
                default:
                    tileFrame = "chainCardSlot3";
                    break;
            }
            tileSprite.gotoAndStop(tileFrame);
            tileSprite.name = "chainstile" + i;
            tileSize = MemoryMatch.getSpriteFrameSize(spriteFrames, tileFrame);
            tileSprite.setTransform(tileSize.width * -0.5, (tileHeight + tileGap) * i, 1, 1, 0, 0, 0, 0, 0);
            tileSprite.width = tileSize.width;
            tileSprite.height = tileSize.height;
            if (tileColorFilter != null) {
                tileSprite.filters = [tileColorFilter];
                tileSprite.cache(0, 0, tileSprite.width, tileSprite.height);
            }
            tileText.name = "chainstext" + i;
            tileText.text = (i + 1).toString();
            tileText.setTransform(0, tileSprite.y + (tileSize.height * 0.5), 1, 1, 0, 0, 0, 0, 0);
            chainsGroup.addChild(tileSprite);
            chainsGroup.addChild(tileText);
        }
        chainsGroup.setTransform(x, y - (totalHeightRequired * 0.2), scale, scale, 0, 0, 0, 0, 0);
        groupDisplayObject.addChild(chainsGroup);
        chainsGroup.name = 'chainsGroup';
    },

    showChainsMatches: function (groupDisplayObject, matchesToShow) {

        // display a demo match summary

        var spriteFrames = MemoryMatch.GameSetup.guiSpritesheet2Frames,
            m,
            x = 0,
            y = 0,
            offset,
            spriteData = new createjs.SpriteSheet(spriteFrames),
            cardFrame = "chainCard",
            cardSize = MemoryMatch.getSpriteFrameSize(spriteFrames, cardFrame),
            cardSpriteName,
            cardSprite,
            tileSprite,
            chainsGroup,
            totalMatchCounter = 0,
            cardSpriteSource = new createjs.Sprite(spriteData, cardFrame),
            animator,
            startAnimationDelay = 250,
            animationDelay;

        chainsGroup = groupDisplayObject.getChildByName('chainsGroup');
        if (chainsGroup == null) {
            return;
        }
        tileSprite = chainsGroup.getChildByName("chainstile0");
        if (tileSprite != null) {
            offset = 0;
            x = tileSprite.x + (tileSprite.width - cardSize.width) * 0.5;
            y = tileSprite.y + (tileSprite.height - cardSize.height) * 0.5;
            for (m = 0; m < matchesToShow; m ++) {
                totalMatchCounter ++;
                cardSpriteName = "chaincard" + totalMatchCounter;
                cardSprite = chainsGroup.getChildByName(cardSpriteName);
                if (cardSprite == null) {
                    cardSprite = cardSpriteSource.clone();
                    cardSprite.name = cardSpriteName;
                    chainsGroup.addChild(cardSprite);
                    cardSprite.visible = false;
                    animationDelay = startAnimationDelay + (100 * m);
                    animator = MemoryMatch.AnimationHandler.addToAnimationQueue(cardSprite, startAnimationDelay + (100 * m), 0, false, null, null);
                    animator.showAtBegin = true;
                } else {
                    cardSprite.visible = true;
                }
                cardSprite.setTransform(x + offset, y - offset);
                offset += 4 * MemoryMatch.stageScaleFactor;
            }
        }
    },

    clearChainsMatches: function (groupDisplayObject, matchesToShow) {
        var cardSprite,
            chainsGroup;

        chainsGroup = groupDisplayObject.getChildByName('chainsGroup');
        if (chainsGroup == null) {
            return;
        }
        while (matchesToShow > 0) {
            cardSprite = chainsGroup.getChildByName("chaincard" + matchesToShow);
            if (cardSprite != null) {
                chainsGroup.removeChild(cardSprite);
            }
            matchesToShow --;
        }
    },


    setupButtons: function () {

        // 2 buttons centered horizontal at bottom of popup

        var spriteFrame = "gameOverButtonBase",
            buttonScale = 1.0,
            buttonWidth = MemoryMatch.getSpriteFrameWidth(MemoryMatch.GameSetup.guiSpritesheet1Frames, spriteFrame) * buttonScale,
            gameButton,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor,
            buttonMargin = 0,
            buttonTagCounter = 0,
            totalWidth = (2 * (buttonWidth + buttonMargin)) - buttonMargin,
            xOffset = (this.backgroundWidth - totalWidth) * 0.5,
            yOffset = this.backgroundHeight * 0.75;

        gameButton = MemoryMatch.GUIButton({name: "home", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickHome.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverMenuIcon", iconOver: "gameOverMenuDownIcon", iconDown: "gameOverMenuDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        xOffset += buttonWidth + buttonMargin;
        gameButton = MemoryMatch.GUIButton({name: "continue", tag: ++ buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: spriteFrame, buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
        gameButton.setTransform(xOffset, yOffset, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);
    },

    flashContinueButton: function () {
        if (this.buttonInstances.length > 1) {
            this.buttonInstances[1].setFlashing(true);
        }
    },

    buildDemoBoard: function (groupDisplayObject, x, y) {

        // Layout 4 demo cards in a 2x2 pattern

        var distanceBetweenCards = MemoryMatch.cardMargin * 4.0,
            columns = 2,
            rows = 2,
            boardScale = 0.25,
            allCardsShuffled = [3, 4, 4, 3],
            boardContainer = new createjs.Container(),
            halfWidthNeeded = ((MemoryMatch.cardWidth + distanceBetweenCards) * columns) * 0.5,
            halfHeightNeeded = ((MemoryMatch.cardHeight + distanceBetweenCards) * rows) * 0.5,
            spriteData,
            cardIndex,
            row,
            column,
            card;

        spriteData = new createjs.SpriteSheet({
            "images": [MemoryMatch.imageSheetImage],
            "frames": {"regX": 0, "regY": 0, "width": MemoryMatch.cardWidth, "height": MemoryMatch.cardHeight, "count": 0}
        });

        cardIndex = 0;
        for (row = 0; row < rows; row ++) {
            for (column = 0; column < columns; column ++) {
                card = MemoryMatch.makeCard(cardIndex, allCardsShuffled[cardIndex], spriteData);
                card.isEnabled = false;
                card.setTransform(column * (MemoryMatch.cardWidth + distanceBetweenCards), row * (MemoryMatch.cardHeight + distanceBetweenCards));
                boardContainer.addChild(card);
                card.showCardDemo();
                cardIndex ++;
            }
        }
        boardContainer.setTransform(x, y, boardScale, boardScale, 0, 0, 0, halfWidthNeeded, halfHeightNeeded);
        groupDisplayObject.addChild(boardContainer);
        this.boardContainer = boardContainer;
    },

    scheduleDemoAnimation: function (delay) {
        this.timerId = window.setTimeout(this.demoAnimationStep.bind(this), delay);
    },

    demoAnimationStep: function () {
        switch (this.gameId) {
            case 2:
                this.demoAnimationStepForHaystack();
                break;
            case 4:
                this.demoAnimationStepForConcentration();
                break;
            case 5:
                this.demoAnimationStepForChains();
                break;
            case 7:
                this.demoAnimationStepForNemesis();
                break;
            default:
                break;
        }
        this.scheduleDemoAnimation(1000);
    },

    demoAnimationStepForConcentration: function () {
        var card,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip 1st card
                card = this.boardContainer.getChildAt(0);
                if (card != null) {
                    card.flip();
                }
                break;
            case 2: // flip 2nd card
                card = this.boardContainer.getChildAt(3);
                if (card != null) {
                    card.flip();
                }
                break;
            case 3: // wait
                break;
            case 4: // flash misses
                card = this.boardContainer.getChildAt(0);
                if (card != null) {
                    card.flipBack();
                }
                card = this.boardContainer.getChildAt(3);
                if (card != null) {
                    card.flipBack();
                }
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 5: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 6: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 7: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('gameTimer');
        if (timerTextField != null) {
            this.demoTimer += 1001;
            if (this.demoTimer > 6000) {
                this.demoTimer = 0;
            }
            timerTextField.text = MemoryMatch.formatTimeAsString(this.demoTimer, true, false);
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForChains: function () {
        var card,
            i,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flip();
                    }
                }
                break;
            case 2: // wait
                break;
            case 3: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flipBack();
                    }
                }
                break;
            case 4: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                this.showChainsMatches(this.groupDisplayObject, 3);
                break;
            case 5: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 6: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 7:
                this.clearChainsMatches(this.groupDisplayObject, 3);
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('studyGroup');
        if (timerTextField != null) {
            timerTextField = timerTextField.getChildByName('studyTimer');
            if (timerTextField != null) {
                this.demoTimer -= 1;
                if (this.demoTimer < 0) {
                    this.demoTimer = 5;
                }
                timerTextField.text = this.demoTimer.toString();
            }
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForNemesis: function () {
        var card,
            misses,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip 1st card
                card = this.boardContainer.getChildAt(2);
                if (card != null) {
                    card.flip();
                }
                break;
            case 2: // flip 2nd card
                card = this.boardContainer.getChildAt(1);
                if (card != null) {
                    card.flip();
                }
                break;
            case 3: // wait
                break;
            case 4: // flash misses
                card = this.boardContainer.getChildAt(1);
                if (card != null) {
                    card.flipBack();
                }
                card = this.boardContainer.getChildAt(2);
                if (card != null) {
                    card.flipBack();
                }
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.2;
                }
                break;
            case 5: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 6: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.2;
                }
                break;
            case 7: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 8: // move Nemesis
            case 9:
            case 10:
            case 11:
            case 12:
                misses = this.demoAnimationState - 7;
                MemoryMatch.Nemesis.moveNemesisCharacterDemo(this.groupDisplayObject, misses);
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        this.demoAnimationState ++;
    },

    demoAnimationStepForHaystack: function () {
        var card,
            i,
            timerTextField;

        switch (this.demoAnimationState) {
            case 1: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flip();
                    }
                }
                break;
            case 2: // wait
                break;
            case 3: // flip all cards
                for (i = 0; i < 4; i ++) {
                    card = this.boardContainer.getChildAt(i);
                    if (card != null) {
                        card.flipBack();
                    }
                }
                break;
            case 4: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            case 5: // flash misses
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 0.1;
                }
                break;
            case 6: // wait
                timerTextField = this.groupDisplayObject.getChildByName('matchCounter');
                if (timerTextField != null) {
                    timerTextField.alpha = 1;
                }
                break;
            default: // wait
                this.demoAnimationState = 0;
                this.flashContinueButton();
                break;
        }
        timerTextField = this.groupDisplayObject.getChildByName('studyGroup');
        if (timerTextField != null) {
            timerTextField = timerTextField.getChildByName('studyTimer');
            if (timerTextField != null) {
                this.demoTimer -= 1;
                if (this.demoTimer < 0) {
                    this.demoTimer = 5;
                }
                timerTextField.text = this.demoTimer.toString();
            }
        }
        this.demoAnimationState ++;
    },

    isShowing: function () {
        return this.groupDisplayObject != null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        var i;

        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        for (i = 0; i < this.buttonInstances.length; i ++) {
            this.buttonInstances[i].kill();
        }
        this.buttonInstances = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.stateCompleteCallback = null;
        this.spriteData = null;
        this.boardContainer = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};

/**
 * MainMenu.js
 *
 * Show the main menu screen. This object just layouts out the screen, animates the pieces,
 * and waits for the user to make a choice. The callback is used to indicate which choice was
 * made by the user.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.MainMenu = {
    stateCompleteCallback: null,
    levelData: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    awardSprite: null,
    spriteData: null,
    mapSpriteFrames: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    width: 0,
    height: 0,
    animate: true,
    connectorShape: null,

    setup: function (displayObject, nextLevelData, stateCompleteCallbackFunction) {
        // use the level data to do any level-specific setup
        this.levelData = nextLevelData;
        this.stateCompleteCallback = stateCompleteCallbackFunction;
        this.parentDisplayObject = displayObject;
        this.backgroundWidth = displayObject.canvas.width;
        this.backgroundHeight = displayObject.canvas.height;
        this.mapSpriteFrames = MemoryMatch.GameSetup.mapSpritesheetFrames;
        this.spriteData = new createjs.SpriteSheet(this.mapSpriteFrames);
    },

    buildScreen: function (autoStart) {
        // layout the map
        this.width = this.parentDisplayObject.canvas.width;
        this.height = this.parentDisplayObject.canvas.height;
        this.groupDisplayObject = new createjs.Container();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.setupBackgroundAndGameLogo();
        this.setupLandImages();
        this.setupAward();
        this.setupLevelButtons();
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
        // The entire Map is cached, so any updates will require a call to updateCache()
        this.groupDisplayObject.setTransform(0, 0, 1, 1);
        if (this.animate) {
            this.groupDisplayObject.alpha = 0;
        }
        this.groupDisplayObject.cache(0, 0, this.width, this.height);
    },

    start: function () {

        // begin animation, then wait for user event to end this state and alert callback

        var duration,
            animator;

        if (this.animate) {
            duration = 1; // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, 0, false, null, this.onStartFadeInComplete.bind(this));
            animator.endAlpha = 1;
            animator.vAlpha = duration / MemoryMatch.fps;
        }
        if (this.stateCompleteCallback != null) {
            // stateCompleteCallback();
        }
    },

    onStartFadeInComplete: function () {
        if (MemoryMatch.shouldAskUserToBookmarkApp()) {
            var infoPopup = new MemoryMatch.InfoPopup(MemoryMatch.stage, true, {title: MemoryMatch.GameSetup.GUIStrings.bookmarkTitle, message: MemoryMatch.GameSetup.GUIStrings.bookmarkMessage, x: MemoryMatch.stageWidth * 0.5, y: MemoryMatch.stageHeight * 0.09, duration: 5.5, backgroundColor: MemoryMatch.GameSetup.achievementBackgroundColor, borderColor: MemoryMatch.GameSetup.achievementBorderColor});
        }
    },

    onContinue: function (levelNumber) {
        // begin animation, then wait for user event to end this state and alert callback
        if (MemoryMatch.MainMenu.stateCompleteCallback != null) {
            MemoryMatch.MainMenu.stateCompleteCallback(levelNumber);
        }
        MemoryMatch.MainMenu.killScreen();
    },

    onClickedAward: function (event) {
        MemoryMatch.triggerSoundFx("soundTap");
        MemoryMatch.AwardsPopup.setup(MemoryMatch.stage, null);
        MemoryMatch.AwardsPopup.buildScreen(true, true);
    },

    setupBackgroundAndGameLogo: function () {
        // Show Hero image
        var spriteFrame = 'gameLogo',
            imageSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            position = MemoryMatch.GameSetup.mapLogoPosition,
            spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, spriteFrame);

        if (position == null) {
            position = {x: this.width * 0.5, y: this.height * 0.5};
            imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        } else {
            imageSprite.setTransform(position.x * MemoryMatch.stageScaleFactor, position.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
        }
        imageSprite.framerate = 0;
        this.groupDisplayObject.addChild(imageSprite);
    },

    setupLandImages: function () {
        // Show map parts
        var i,
            mapImage,
            mapPosition,
            imageSprite,
            spriteSize;

        for (i = 0; i < MemoryMatch.GameSetup.levels.length; i ++) {
            mapImage = MemoryMatch.GameSetup.levels[i].mapImage;
            if (mapImage != null && mapImage.length > 0) {
                mapPosition = MemoryMatch.GameSetup.levels[i].mapPosition;
                imageSprite = new createjs.Sprite(this.spriteData, mapImage);
                if (imageSprite != null) {
                    spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, mapImage);
                    imageSprite.setTransform(mapPosition.x * MemoryMatch.stageScaleFactor, mapPosition.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteSize.width * 0.5, spriteSize.height * 0.5);
                    imageSprite.framerate = 0;
                    this.groupDisplayObject.addChild(imageSprite);
                }
            }
        }
        this.showSpecialCrap();
    },

    setupAward: function () {
        // Show Award
        var spriteFrame = 'mapTrophy',
            imageSprite = new createjs.Sprite(this.spriteData, spriteFrame),
            awardPosition = MemoryMatch.GameSetup.mapAwardPosition,
            position,
            spriteSize = MemoryMatch.getSpriteFrameSize(this.mapSpriteFrames, spriteFrame),
            i,
            gemPosition,
            gemName,
            landNumber,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        if (awardPosition == null) {
            position = {x: ((this.width - spriteSize.width) * 0.5) | 0, y: ((this.height - spriteSize.height) * 0.5) | 0};
        } else {
            position = {x: (awardPosition.x * MemoryMatch.stageScaleFactor) | 0, y: (awardPosition.y * MemoryMatch.stageScaleFactor) | 0};
        }
        imageSprite.setTransform(position.x, position.y, 1, 1, 0, 0, 0, (spriteSize.width * 0.5) | 0, (spriteSize.height * 0.5) | 0);
        imageSprite.framerate = 0;
        imageSprite.cursor = 'pointer';
        imageSprite.addEventListener('click', this.onClickedAward.bind(this));
        this.groupDisplayObject.addChild(imageSprite);
        this.awardSprite = imageSprite;

        // position gems relative to award position, accounting for the center registration of the award sprite
        spriteFrame = 'mapAwardLand';
        position.x -= (spriteSize.width * 0.5) | 0;
        position.y -= (spriteSize.height * 0.5) | 0;
        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = spriteFrame + landNumber.toString();
            imageSprite = new createjs.Sprite(this.spriteData, gemName);
            gemPosition = MemoryMatch.GameSetup.levels[i].gemPosition;
            imageSprite.setTransform((position.x + (gemPosition.x * MemoryMatch.stageScaleFactor)) | 0, (position.y + (gemPosition.y * MemoryMatch.stageScaleFactor)) | 0);
            imageSprite.name = gemName;
            imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            this.groupDisplayObject.addChild(imageSprite);
        }
    },

    showAwardedGems: function () {
        var gemName = 'mapAwardLand',
            landNumber,
            imageSprite,
            i,
            numberOfLevels = MemoryMatch.GameSetup.levels.length;

        for (i = 0; i < numberOfLevels; i ++) {
            landNumber = i + 1;
            gemName = 'mapAwardLand' + landNumber.toString();
            imageSprite = this.groupDisplayObject.getChildByName(gemName);
            if (imageSprite != null) {
                imageSprite.visible = MemoryMatch.didUserBeatChallenge(landNumber);
            }
        }
    },

    setupLevelButtons: function (groupDisplayObject) {

        // Each Level button will come from a data array in Setup.js representing the type of object and the
        // center of the rectangle

        var mapLevelPositions = MemoryMatch.GameSetup.mapLevelPositions,
            levelData = MemoryMatch.GameSetup.levels,
            levelMapPosition,
            landIndex,
            landNumber,
            levelIndexLandOffset,
            levelIndex,
            levelNumber,
            levelButton,
            gameNumber,
            starsEarned,
            bestScore,
            wasPlayed,
            isLocked,
            buttonScale,
            primaryColor,
            secondaryColor,
            liteColor,
            gameScoresCollection,
            gameScoreData,
            totalGamesPlayed,
            gamesUnlocked,
            buttonBeforeThisOne;

        if (mapLevelPositions == null || levelData == null) {
            return;
        }
        levelIndexLandOffset = 0;
        totalGamesPlayed = 0;
        for (landIndex = 0; landIndex < levelData.length; landIndex ++) {
            landNumber = landIndex + 1;
            primaryColor = levelData[landIndex].primaryColor;
            secondaryColor = levelData[landIndex].secondaryColor;
            liteColor = levelData[landIndex].liteColor;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(landNumber, "levelScoreCollection");
            gamesUnlocked = gameScoresCollection.length;
            buttonBeforeThisOne = null;
            for (levelIndex = 0; levelIndex < levelData[landIndex].gameCount; levelIndex ++) {
                levelNumber = levelIndex + levelIndexLandOffset + 1;
                gameNumber = levelIndex + 1;
                if (mapLevelPositions[landIndex] != null && mapLevelPositions[landIndex].length > levelIndex) {
                    levelMapPosition = mapLevelPositions[landIndex][levelIndex];
                } else {
                    levelMapPosition = {x: 0, y: 0};
                }
                gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
                if (gameScoreData != null && gameScoreData.playCount > 0) {
                    wasPlayed = true;
                    totalGamesPlayed ++;
                    isLocked = false;
                    bestScore = gameScoreData.bestScore;
                    starsEarned = gameScoreData.starsEarned;
                } else if (gameNumber == gamesUnlocked) {
                    wasPlayed = false;
                    isLocked = false;
                    bestScore = 0;
                    starsEarned = 0;
                } else {
                    wasPlayed = false;
                    isLocked = true;
                    bestScore = 0;
                    starsEarned = 0;
                }
                buttonScale = 1;
                levelButton = MemoryMatch.LevelButton({gameNumber: levelNumber, landNumber: landNumber, starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked, isChallengeGame: false, primaryColor: primaryColor, secondaryColor: secondaryColor, liteColor: liteColor, scale: buttonScale, callback:this.onContinue.bind(this), changeEventNotification:this.changeEvent.bind(this)});
                levelButton.x = levelMapPosition.x * MemoryMatch.stageScaleFactor;
                levelButton.y = levelMapPosition.y * MemoryMatch.stageScaleFactor;
                levelButton.name = this.makeLevelButtonName(landNumber, levelNumber);
                this.groupDisplayObject.addChild(levelButton);
                if (buttonBeforeThisOne != null) {
                    this.connectPath(buttonBeforeThisOne, levelButton);
                }
                buttonBeforeThisOne = levelButton;
            }
            levelNumber ++;
            gameNumber = 99;
            if (mapLevelPositions[landIndex] != null && mapLevelPositions[landIndex].length >= levelIndex) {
                levelMapPosition = mapLevelPositions[landIndex][levelIndex];
            } else {
                levelMapPosition = {x: 0, y: 0};
            }
            gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
            if (gameScoreData != null && gameScoreData.playCount > 0) {
                wasPlayed = true;
                totalGamesPlayed ++;
                isLocked = false;
                bestScore = gameScoreData.bestScore;
                starsEarned = gameScoreData.starsEarned;
            } else if (gameNumber <= gamesUnlocked || gamesUnlocked > levelData[landIndex].gameCount) {
                wasPlayed = false;
                isLocked = false;
                bestScore = 0;
                starsEarned = 0;
            } else {
                wasPlayed = false;
                isLocked = true;
                bestScore = 0;
                starsEarned = 0;
            }
            levelButton = MemoryMatch.LevelButton({gameNumber: levelNumber, landNumber: landNumber, starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked, isChallengeGame: true, primaryColor: primaryColor, secondaryColor: secondaryColor, liteColor: liteColor, scale: buttonScale, callback:this.onContinue.bind(this), changeEventNotification:this.changeEvent.bind(this)});
            levelButton.x = levelMapPosition.x * MemoryMatch.stageScaleFactor;
            levelButton.y = levelMapPosition.y * MemoryMatch.stageScaleFactor;
            levelButton.name = this.makeLevelButtonName(landNumber, levelNumber);
            if (buttonBeforeThisOne != null) {
                this.connectPath(buttonBeforeThisOne, levelButton);
            }
            this.groupDisplayObject.addChild(levelButton);
            levelIndexLandOffset += levelData[landIndex].gameCount + 1;
        }
    },

    refreshButtons: function () {

        // Update the state of all level buttons and the Award

        var levelData = MemoryMatch.GameSetup.levels,
            landIndex,
            landNumber,
            levelIndexLandOffset,
            levelIndex,
            levelNumber,
            levelButton,
            gameNumber,
            starsEarned,
            bestScore,
            wasPlayed,
            isLocked,
            gameScoresCollection,
            gameScoreData,
            totalGamesPlayed,
            gamesUnlocked;

        if (levelData == null || ! this.isShowing()) {
            return;
        }
        levelIndexLandOffset = 0;
        totalGamesPlayed = 0;
        for (landIndex = 0; landIndex < levelData.length; landIndex ++) {
            landNumber = landIndex + 1;
            gameScoresCollection = MemoryMatch.UserData.getLevelDataItem(landNumber, "levelScoreCollection");
            gamesUnlocked = gameScoresCollection.length;
            for (levelIndex = 0; levelIndex < levelData[landIndex].gameCount; levelIndex ++) {
                levelNumber = levelIndex + levelIndexLandOffset + 1;
                gameNumber = levelIndex + 1;
                gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
                if (gameScoreData != null && gameScoreData.playCount > 0) {
                    wasPlayed = true;
                    totalGamesPlayed ++;
                    isLocked = false;
                    bestScore = gameScoreData.bestScore;
                    starsEarned = gameScoreData.starsEarned;
                } else if (gameNumber == gamesUnlocked) {
                    wasPlayed = false;
                    isLocked = false;
                    bestScore = 0;
                    starsEarned = 0;
                } else {
                    wasPlayed = false;
                    isLocked = true;
                    bestScore = 0;
                    starsEarned = 0;
                }
                levelButton = this.groupDisplayObject.getChildByName(this.makeLevelButtonName(landNumber, levelNumber));
                if (levelButton != null) {
                    levelButton.refreshButton({starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked});
                }
            }
            levelNumber ++;
            gameNumber = 99;
            gameScoreData = MemoryMatch.getPriorScoreDataForGameNumber(gameNumber, gameScoresCollection);
            if (gameScoreData != null && gameScoreData.playCount > 0) {
                wasPlayed = true;
                totalGamesPlayed ++;
                isLocked = false;
                bestScore = gameScoreData.bestScore;
                starsEarned = gameScoreData.starsEarned;
            } else if (gameNumber == gamesUnlocked) {
                wasPlayed = false;
                isLocked = false;
                bestScore = 0;
                starsEarned = 0;
            } else {
                wasPlayed = false;
                isLocked = true;
                bestScore = 0;
                starsEarned = 0;
            }
            levelButton = this.groupDisplayObject.getChildByName(this.makeLevelButtonName(landNumber, levelNumber));
            if (levelButton != null) {
                levelButton.refreshButton({starsEarned: starsEarned, bestScore: bestScore, wasPlayed: wasPlayed, isLocked: isLocked});
            }
            levelIndexLandOffset += levelData[landIndex].gameCount + 1;
        }
        this.showAwardedGems();
        this.groupDisplayObject.updateCache();
    },

    connectPath: function (firstPoint, secondPoint) {
        var lineShape,
            strokeColor;

        if (firstPoint != null && secondPoint != null && firstPoint.x != null && secondPoint.x != null) {
            lineShape = new createjs.Shape();
            strokeColor = MemoryMatch.GameSetup.mapPathColor;
            if (strokeColor == null || strokeColor == '') {
                strokeColor = 'rgba(102,102,102,0.5)';
            }
            lineShape.graphics.beginStroke(strokeColor).setStrokeStyle(12 * MemoryMatch.stageScaleFactor);
            lineShape.graphics.moveTo(firstPoint.x + (firstPoint.width * 0.5), firstPoint.y + (firstPoint.height * 0.5));
            lineShape.graphics.lineTo(secondPoint.x + (secondPoint.width * 0.5), secondPoint.y + (secondPoint.height * 0.5));
            lineShape.graphics.endStroke();
            this.groupDisplayObject.addChildAt(lineShape, this.groupDisplayObject.getChildIndex(firstPoint));
        }
    },

    showSpecialCrap: function () {
        // some levels/maps will require placing special markers and eye candy on the map, do that one-off crap here
        // markerData format is an array of objects {x, y, icon}

        var specialMarkers = MemoryMatch.GameSetup.mapSpecialMarkers,
            markerData,
            markerSprite,
            spriteWidth,
            spriteHeight,
            i;

        if (specialMarkers != null) {
            for (i = 0; i < specialMarkers.length; i ++) {
                markerData = specialMarkers[i];
                if (markerData.icon != null) {
                    markerSprite = new createjs.Sprite(this.spriteData, markerData.icon);
                    spriteWidth = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[markerData.icon][0]][2];
                    spriteHeight = MemoryMatch.GameSetup.mapSpritesheetFrames.frames[MemoryMatch.GameSetup.mapSpritesheetFrames.animations[markerData.icon][0]][3];
                    markerSprite.setTransform(markerData.x * MemoryMatch.stageScaleFactor, markerData.y * MemoryMatch.stageScaleFactor, 1, 1, 0, 0, 0, spriteWidth * 0.5, spriteHeight * 0.5);
                    this.groupDisplayObject.addChild(markerSprite);
                }
            }
        }
    },

    isShowing: function () {
        return this.groupDisplayObject != null && this.groupDisplayObject.visible;
    },

    changeEvent: function () {
        // provide a notification event if a child makes a display change so we can update our cache
        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.updateCache();
        }
    },

    makeLevelButtonName: function (landNumber, levelNumber) {
        return 'land' + landNumber.toString() + ':level' + levelNumber.toString();
    },

    killScreen: function () {
        // remove all display objects and references
        this.stateCompleteCallback = null;
        this.levelData = null;
        this.spriteData = null;
        this.mapSpriteFrames = null;
        this.awardSprite = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.groupDisplayObject = null;
        this.parentDisplayObject = null;
        this.backgroundWidth = 0;
        this.backgroundHeight = 0;
        this.width = 0;
        this.height = 0;
    }
};

/**
 * MessagePopup.js
 *
 * Show a generic popup that can be used for informational or error messages.
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.MessagePopup = {
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    bgImageScaleX: 1,
    bgImageScaleY: 1,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    domElement: null,
    noscale: false,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,


    setParameters: function (parameters) {
        if (parameters != null) {
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.domElement != null) {
                this.domElement = parameters.domElement;
            }
            if (parameters.closeButton != null) {
                this.closeButton = parameters.closeButton;
            }
            if (parameters.continueButton != null) {
                this.continueButton = parameters.continueButton;
            }
            if (parameters.callback != null) {
                this.stateCompleteCallback = parameters.callback;
            }
            if (parameters.noscale != null) {
                this.noscale = parameters.noscale;
            }
        }
    },

    setup: function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.setParameters(parameters);
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        if (this.domElement == null) {
            this.setupMessageText();
        }
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (this.domElement != null) {
            this.setupDOMElement(); // need to do this after the transformation
        }
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, then wait for user event to end this state and alert callback
        this.isEnabled = true;
    },

    closeStartAnimation: function () {
        var duration = 0.1; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));
        if (animator != null) {
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        }
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(this.closeEventType);
        }
    },

    closeShrink: function () {
        var duration = 0.3; // seconds of animation
        var animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));
        animator.endYScale = animator.endXScale = 0;
        animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        var domElement = this.groupDisplayObject.getChildByName('text'),
            pageElement;

        this.isEnabled = false;
        this.closeEventType = closeEventType;
        if (domElement != null) {
            domElement.visible = false;
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.display = 'none';
            }
        }
        // begin animation, then once close is complete send notification
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("close");
        }
    },

    onClickContinue: function (event) {
        if (this.isEnabled) {
            MemoryMatch.triggerSoundFx("soundTap");
            this.closePopup("continue");
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    showBackgroundImage: function () {

        // This method will scale the background image to fit the current stage if it is too big.

        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        this.bgImageScaleX = xScale;
        this.bgImageScaleY = yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupDOMElement: function () {
        // Position a DOM element in the center of the popup. Expecting the element to be a div containing what we want to show.
        // Register domElement to its center
        var pageElement = document.getElementById(this.domElement),
            domElement = new createjs.DOMElement(pageElement),
            positionOffset,
            scaleFactorX,
            scaleFactorY,
            x,
            y,
            width,
            height;

        if (domElement != null) {
            domElement.name = 'text';
            width = pageElement.clientWidth;
            height = pageElement.clientHeight;

            // the div was scaled by CSS, we need to determine how much the div was scaled, then center it
            scaleFactorX = MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
            scaleFactorY = MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
            if (MemoryMatch.stageScaleFactor == 0.5) {
                positionOffset = -0.5;
                x = (this.backgroundWidth * positionOffset) | 0;
                y = (this.backgroundHeight * positionOffset) | 0;
            } else if (MemoryMatch.stageScaleFactor > 0.5) {
                positionOffset = -0.415;
                x = (this.backgroundWidth * positionOffset) | 0;
                y = (this.backgroundHeight * positionOffset) | 0;
            } else {
                x = (this.backgroundWidth * -0.52) | 0;
                y = (this.backgroundHeight * -0.48) | 0;
            }
            this.parentDisplayObject.addChild(domElement);
            pageElement.style.display = 'block';
            pageElement.width = this.parentDisplayObject.width;
            pageElement.height = this.parentDisplayObject.height;
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupMessageText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.4;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            buttonTagCounter = 0,
            buttonSize,
            buttonBaseColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].liteColor,
            buttonRollOverColor = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].secondaryColor;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        if (this.continueButton) {
            buttonTagCounter ++;
            buttonSize = MemoryMatch.getSpriteFrameSize(MemoryMatch.GameSetup.guiSpritesheet1Frames, 'gameOverButtonBase');
            gameButton = MemoryMatch.GUIButton({name: "continue", tag: buttonTagCounter, disabled: false, callback: this.onClickContinue.bind(this), baseUp: "gameOverButtonBase", buttonBaseColor: buttonBaseColor, buttonBaseRollOverColor: buttonRollOverColor, iconUp: "gameOverNextIcon", iconOver: "gameOverNextDownIcon", iconDown: "gameOverNextDownIcon"});
            gameButton.setTransform((this.backgroundWidth - buttonSize.width) * 0.5, this.backgroundHeight * 0.75, buttonScale, buttonScale);
            this.groupDisplayObject.addChild(gameButton);
            this.buttonInstances.push(gameButton);
        }
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i,
            pageElement;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        if (this.domElement != null) {
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.visibility = "hidden";
            }
        }
        this.domElement = null;
        this.title = null;
        this.message = null;
        this.groupDisplayObject.removeAllChildren();
        this.parentDisplayObject.removeChild(this.groupDisplayObject);
        this.parentDisplayObject.removeChild(this.backgroundCover);
        this.backgroundCover = null;
        this.stateCompleteCallback = null;
        this.parentDisplayObject = null;
        this.groupDisplayObject = null;
    }
};
/**
 * Nemesis.js
 *
 * Handle all the logic to control the Nemesis Character and tile layout.
 * Use this object in the following interface:
 * 1. layoutNemesisPath will place all Nemesis sprites on the display object
 * 2. moveNemesisCharacter will update the state of the sprites based on number of misses. Typically called when player misses.
 * 3. awakeNemesisCharacter will show an animation when player makes a match or on idle.
 * 4. removeNemesisCharacter when Nemesis games is over and remove sprites from stage
 *
 */
this.MemoryMatch = this.MemoryMatch || {};

this.MemoryMatch.Nemesis = {
    nemesisGroupDisplayObject: null,
    parentDisplayObject: null,
    spriteFrameData: null,
    bottleTopFilled: "nemesis1",
    bottleTopEmpty: "nemesis1Empty",
    bottleNeckFilled: "nemesis2",
    bottleNeckEmpty: "nemesis2Empty",
    bottleNeckEmptyEmpty: "nemesis2Empty2",
    bottleSectionFilled: "nemesis3",
    bottleSectionEmpty: "nemesis3Empty",
    bottleSectionEmptyEmpty: "nemesis3Empty2",
    bottleBottomFilled: "nemesis4",
    bottleBottomEmpty: "nemesis4Empty",
    maxNumberOfPieces: 0, // Total bottle size in pieces

    layoutNemesisPath: function (parentDisplayObject) {

        // function to call to initialize and layout the Nemesis tiles and setup the character

        var spriteData,
            missCounter,
            topPieceSize,
            middlePieceSize,
            tileSize,
            nextY,
            i,
            bottleTopSprite,
            bottleNeckSprite,
            bottleMiddleSprite,
            bottleMiddleSpriteCloned,
            bottleBottomSprite,
            numberOfMiddlePieces,
            groupWidth,
            groupCenterX,
            thisGameData,
            gameProgressionData;

        this.parentDisplayObject = parentDisplayObject;
        // find the highest tolerance, make the wine bottle that big
        thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
        if (thisGameData.progression != null && thisGameData.progression.length >= MemoryMatch.gameNumber) {
            this.maxNumberOfPieces = 0;
            gameProgressionData = thisGameData.progression;
            for (i = 0; i < gameProgressionData.length; i ++) {
                if (this.maxNumberOfPieces < gameProgressionData[i].tolerance) {
                    this.maxNumberOfPieces = gameProgressionData[i].tolerance;
                }
            }
        } else {
            this.maxNumberOfPieces = thisGameData.tolerance;
        }
        if (this.maxNumberOfPieces == null || this.maxNumberOfPieces < 3) {
            this.maxNumberOfPieces = 3;
        }
        this.spriteFrameData = MemoryMatch.GameSetup.guiSpritesheet2Frames;
        spriteData = new createjs.SpriteSheet(this.spriteFrameData);

        if (this.nemesisGroupDisplayObject == null) {
            this.nemesisGroupDisplayObject = new createjs.Container();
            parentDisplayObject.addChild(this.nemesisGroupDisplayObject);
        } else {
            this.nemesisGroupDisplayObject.removeAllChildren();
        }
        numberOfMiddlePieces = this.maxNumberOfPieces - 3;
        nextY = 0;
        missCounter = 1;
        bottleTopSprite = new createjs.Sprite(spriteData, this.bottleTopFilled);
        bottleTopSprite.framerate = 1;
        bottleTopSprite.name = 'miss' + missCounter.toString();
        bottleTopSprite.gotoAndStop(this.bottleTopFilled);
        topPieceSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleTopFilled);

        missCounter ++;
        bottleNeckSprite = new createjs.Sprite(spriteData, this.bottleNeckFilled);
        bottleNeckSprite.framerate = 1;
        bottleNeckSprite.name = 'miss' + missCounter.toString();
        bottleNeckSprite.gotoAndStop(this.bottleNeckFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleNeckFilled);
        groupWidth = tileSize.width; // all remaining pieces have the same width
        groupCenterX = (groupWidth * 0.5) | 0;

        bottleTopSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (topPieceSize.width * 0.5) | 0, 0);
        nextY += topPieceSize.height;
        bottleNeckSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, groupCenterX, 0);
        nextY += tileSize.height;
        this.nemesisGroupDisplayObject.addChild(bottleTopSprite);
        this.nemesisGroupDisplayObject.addChild(bottleNeckSprite);

        bottleMiddleSprite = new createjs.Sprite(spriteData, this.bottleSectionFilled);
        bottleMiddleSprite.framerate = 1;
        bottleMiddleSprite.gotoAndStop(this.bottleSectionFilled);
        middlePieceSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleSectionFilled);
        for (i = 0; i < numberOfMiddlePieces; i ++) {
            missCounter ++;
            if (i == 0) {
                bottleMiddleSpriteCloned = bottleMiddleSprite;
            } else {
                bottleMiddleSpriteCloned = bottleMiddleSprite.clone();
            }
            this.nemesisGroupDisplayObject.addChild(bottleMiddleSpriteCloned);
            bottleMiddleSpriteCloned.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (middlePieceSize.width * 0.5) | 0, 0);
            bottleMiddleSpriteCloned.name = 'miss' + missCounter.toString();
            nextY += middlePieceSize.height;
        }

        missCounter ++;
        bottleBottomSprite = new createjs.Sprite(spriteData, this.bottleBottomFilled);
        bottleBottomSprite.framerate = 1;
        bottleBottomSprite.name = 'miss' + missCounter.toString();
        bottleBottomSprite.gotoAndStop(this.bottleBottomFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(this.spriteFrameData, this.bottleBottomFilled);
        bottleBottomSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (tileSize.width * 0.5) | 0, 0);
        nextY += tileSize.height;
        this.nemesisGroupDisplayObject.addChild(bottleBottomSprite);

        this.nemesisGroupDisplayObject.setTransform((MemoryMatch.stageWidth - tileSize.width - (tileSize.width * 0.14)) | 0, ((MemoryMatch.stageHeight - nextY) * 0.5) | 0, 1, 1, 0, 0, 0, 0, 0);
        this.moveNemesisCharacter();
        MemoryMatch.stageUpdated = true;
    },

    layoutNemesisDemo: function (parentDisplayObject, x, y, scale) {

        // function to call to initialize and layout the Nemesis tiles for demo purposes

        var spriteData,
            spriteFrameData,
            groupDisplayObject,
            missCounter,
            topPieceSize,
            middlePieceSize,
            tileSize,
            nextY,
            i,
            maxNumberOfPieces,
            bottleTopSprite,
            bottleNeckSprite,
            bottleMiddleSprite,
            bottleMiddleSpriteCloned,
            bottleBottomSprite,
            numberOfMiddlePieces,
            groupWidth,
            groupCenterX,
            thisGameData,
            gameProgressionData;

        // find the highest tolerance, make the wine bottle that big
        thisGameData = MemoryMatch.getGameData(MemoryMatch.isChallengeGame);
        if (thisGameData.progression != null && thisGameData.progression.length >= MemoryMatch.gameNumber) {
            maxNumberOfPieces = 0;
            gameProgressionData = thisGameData.progression;
            for (i = 0; i < gameProgressionData.length; i ++) {
                if (maxNumberOfPieces < gameProgressionData[i].tolerance) {
                    maxNumberOfPieces = gameProgressionData[i].tolerance;
                }
            }
        } else {
            maxNumberOfPieces = thisGameData.tolerance;
        }
        if (maxNumberOfPieces == null || maxNumberOfPieces < 3) {
            maxNumberOfPieces = 3;
        }
        spriteFrameData = MemoryMatch.GameSetup.guiSpritesheet2Frames;
        spriteData = new createjs.SpriteSheet(spriteFrameData);

        groupDisplayObject = new createjs.Container();
        groupDisplayObject.name = 'nemesisContainer';
        groupDisplayObject.maxNumberOfPieces = maxNumberOfPieces;
        numberOfMiddlePieces = maxNumberOfPieces - 3;
        nextY = 0;
        missCounter = 1;
        bottleTopSprite = new createjs.Sprite(spriteData, this.bottleTopFilled);
        bottleTopSprite.framerate = 1;
        bottleTopSprite.name = 'miss' + missCounter.toString();
        bottleTopSprite.gotoAndStop(this.bottleTopFilled);
        topPieceSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleTopFilled);

        missCounter ++;
        bottleNeckSprite = new createjs.Sprite(spriteData, this.bottleNeckFilled);
        bottleNeckSprite.framerate = 1;
        bottleNeckSprite.name = 'miss' + missCounter.toString();
        bottleNeckSprite.gotoAndStop(this.bottleNeckFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleNeckFilled);
        groupWidth = tileSize.width; // all remaining pieces have the same width
        groupCenterX = (groupWidth * 0.5) | 0;

        bottleTopSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (topPieceSize.width * 0.5) | 0, 0);
        nextY += topPieceSize.height;
        bottleNeckSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, groupCenterX, 0);
        nextY += tileSize.height;
        groupDisplayObject.addChild(bottleTopSprite);
        groupDisplayObject.addChild(bottleNeckSprite);

        bottleMiddleSprite = new createjs.Sprite(spriteData, this.bottleSectionFilled);
        bottleMiddleSprite.framerate = 1;
        bottleMiddleSprite.gotoAndStop(this.bottleSectionFilled);
        middlePieceSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleSectionFilled);
        for (i = 0; i < numberOfMiddlePieces; i ++) {
            missCounter ++;
            if (i == 0) {
                bottleMiddleSpriteCloned = bottleMiddleSprite;
            } else {
                bottleMiddleSpriteCloned = bottleMiddleSprite.clone();
            }
            groupDisplayObject.addChild(bottleMiddleSpriteCloned);
            bottleMiddleSpriteCloned.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (middlePieceSize.width * 0.5) | 0, 0);
            bottleMiddleSpriteCloned.name = 'miss' + missCounter.toString();
            nextY += middlePieceSize.height;
        }
        missCounter ++;
        bottleBottomSprite = new createjs.Sprite(spriteData, this.bottleBottomFilled);
        bottleBottomSprite.framerate = 1;
        bottleBottomSprite.name = 'miss' + missCounter.toString();
        bottleBottomSprite.gotoAndStop(this.bottleBottomFilled);
        tileSize = MemoryMatch.getSpriteFrameSize(spriteFrameData, this.bottleBottomFilled);
        bottleBottomSprite.setTransform(groupCenterX, nextY, 1, 1, 0, 0, 0, (tileSize.width * 0.5) | 0, 0);
        nextY += tileSize.height;
        groupDisplayObject.addChild(bottleBottomSprite);

        groupDisplayObject.setTransform((x - tileSize.width - (tileSize.width * 0.14)) | 0, y, scale, scale, 0, 0, 0, 0, nextY * 0.5);
        parentDisplayObject.addChild(groupDisplayObject);
    },

    moveNemesisCharacter: function () {

        // function called when the Nemesis character should advance.
        // Based on number of misses update all the sections.

        var spritePiece,
            emptyPieces = this.maxNumberOfPieces - MemoryMatch.levelTolerance + MemoryMatch.missCount,
            nextFrame,
            i;

        for (i = 1; i <= this.maxNumberOfPieces; i ++) {
            spritePiece = this.nemesisGroupDisplayObject.getChildByName('miss' + i.toString());
            if (spritePiece != null) {
                if (i <= emptyPieces) { // set to empty
                    if (i == 1) { // top
                        nextFrame = this.bottleTopEmpty;
                    } else if (i == 2) { // neck
                        if (emptyPieces > i) {
                            nextFrame = this.bottleNeckEmptyEmpty;
                        } else {
                            nextFrame = this.bottleNeckEmpty;
                        }
                    } else if (i == this.maxNumberOfPieces) { // bottom
                        nextFrame = this.bottleBottomEmpty;
                    } else { // middle
                        if (emptyPieces > i) {
                            nextFrame = this.bottleSectionEmptyEmpty;
                        } else {
                            nextFrame = this.bottleSectionEmpty;
                        }
                    }
                } else {
                    if (i == 1) { // top
                        nextFrame = this.bottleTopFilled;
                    } else if (i == 2) { // neck
                        nextFrame = this.bottleNeckFilled;
                    } else if (i == this.maxNumberOfPieces) { // bottom
                        nextFrame = this.bottleBottomFilled;
                    } else { // middle
                        nextFrame = this.bottleSectionFilled;
                    }
                }
            }
            spritePiece.gotoAndStop(nextFrame);
        }
    },

    moveNemesisCharacterDemo: function (parentDisplayObject, missCount) {

        // function called when the Nemesis character should advance.
        // Based on number of misses update all the sections.

        var spritePiece,
            groupDisplayObject,
            maxNumberOfPieces,
            emptyPieces,
            nextFrame,
            i;

        if (parentDisplayObject == null) {
            return;
        }
        groupDisplayObject = parentDisplayObject.getChildByName('nemesisContainer');
        if (groupDisplayObject != null) {
            maxNumberOfPieces = groupDisplayObject.maxNumberOfPieces;
            emptyPieces = missCount;
            for (i = 1; i <= maxNumberOfPieces; i ++) {
                spritePiece = groupDisplayObject.getChildByName('miss' + i.toString());
                if (spritePiece != null) {
                    if (i <= emptyPieces) { // set to empty
                        if (i == 1) { // top
                            nextFrame = this.bottleTopEmpty;
                        } else if (i == 2) { // neck
                            if (emptyPieces > i) {
                                nextFrame = this.bottleNeckEmptyEmpty;
                            } else {
                                nextFrame = this.bottleNeckEmpty;
                            }
                        } else if (i == maxNumberOfPieces) { // bottom
                            nextFrame = this.bottleBottomEmpty;
                        } else { // middle
                            if (emptyPieces > i) {
                                nextFrame = this.bottleSectionEmptyEmpty;
                            } else {
                                nextFrame = this.bottleSectionEmpty;
                            }
                        }
                    } else {
                        if (i == 1) { // top
                            nextFrame = this.bottleTopFilled;
                        } else if (i == 2) { // neck
                            nextFrame = this.bottleNeckFilled;
                        } else if (i == maxNumberOfPieces) { // bottom
                            nextFrame = this.bottleBottomFilled;
                        } else { // middle
                            nextFrame = this.bottleSectionFilled;
                        }
                    }
                }
                spritePiece.gotoAndStop(nextFrame);
            }
        }
    },

    awakeNemesisCharacter: function () {

        // function to call to update a Nemesis character animation. Only advance animation if character is in the idle state.

    },

    removeNemesisCharacter: function () {

        // function to call to remove the Nemesis from the stage.

        if (this.nemesisGroupDisplayObject != null) {
            this.spriteFrameData = null;
            this.nemesisGroupDisplayObject.removeAllChildren();
            this.parentDisplayObject.removeChild(this.nemesisGroupDisplayObject);
            this.nemesisCharacterSprite = null;
            this.nemesisGroupDisplayObject = null;
            MemoryMatch.stageUpdated = true;
        }
    },

    moveNemesisCharacterComplete: function () {
        if (this.nemesisCharacterSprite != null) {
            this.nemesisCharacterSprite.gotoAndStop("stand");
            MemoryMatch.stageUpdated = true;
        }
    },

    scale: function(scaleFactor) {
        if (scaleFactor >= 0 && scaleFactor <= 1 && this.nemesisGroupDisplayObject != null) {
            this.nemesisGroupDisplayObject.scaleX = scaleFactor;
            this.nemesisGroupDisplayObject.scaleY = scaleFactor;
        }
    }
};

/**
 * SharePopup.js
 *
 * Show a share popup:
 * Allow user to pick a network to share game
 *
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.SharePopup = {
    shareNetworks: [{id: 'facebook', icon: 'facebook-icon', initialized: false}, {id: 'twitter', icon: 'twitter-icon', initialized: false}, {id: 'googleplus', icon: 'googleplus-icon', initialized: false}],
    stateCompleteCallback: null,
    parentDisplayObject: null,
    groupDisplayObject: null,
    buttonInstances: null,
    backgroundWidth: 0,
    backgroundHeight: 0,
    backgroundCover: null,
    marginTop: 0,
    marginLeft: 0,
    lineHeight: 0,
    isEnabled: false,
    title: null,
    message: null,
    closeButton: true,
    continueButton: false,
    domElementEmailForm: null,
    noscale: false,
    closeEventType: null,
    primaryColorFilter: null,
    secondaryColorFilter: null,
    primaryColorValue: null,
    secondaryColorValue: null,
    shareMessage: null,


    setParameters: function (parameters) {
        if (parameters != null) {
            if (parameters.title != null) {
                this.title = parameters.title;
            } else if (this.title == null) {
                this.title = "";
            }
            if (parameters.message != null) {
                this.message = parameters.message;
            } else if (this.message == null) {
                this.message = "";
            }
            if (parameters.domElementEmailForm != null) {
                this.domElementEmailForm = parameters.domElementEmailForm;
            }
            if (parameters.closeButton != null) {
                this.closeButton = parameters.closeButton;
            }
            if (parameters.continueButton != null) {
                this.continueButton = parameters.continueButton;
            }
            if (parameters.callback != null) {
                this.stateCompleteCallback = parameters.callback;
            }
            if (parameters.noscale != null) {
                this.noscale = parameters.noscale;
            }
            if (parameters.shareMessage != null) {
                this.shareMessage = parameters.shareMessage;
            }
        }
    },

    setup: function (displayObject, parameters) {
        this.parentDisplayObject = displayObject;
        this.buttonInstances = [];
        this.setParameters(parameters);
    },

    buildScreen: function (autoStart) {
        if (this.groupDisplayObject !== null) {
            return;
        }
        // layout the screen
        this.groupDisplayObject = new createjs.Container();
        this.setColorFilters();
        this.showBackgroundImage();
        this.marginTop = this.backgroundHeight * 0.05;
        this.marginLeft = this.backgroundWidth * 0.09;
        this.setupTitleText();
        if (this.domElement == null) {
            this.setupMessageText();
        }
        this.setupButtons();
        this.parentDisplayObject.addChild(this.groupDisplayObject);
        this.groupDisplayObject.setTransform(this.parentDisplayObject.canvas.width * 0.5, this.parentDisplayObject.canvas.height * 0.5, 1, 1, 0, 0, 0, this.backgroundWidth * 0.5, this.backgroundHeight * 0.5);
        if (autoStart == null) {
            autoStart = false;
        }
        if (autoStart) {
            this.start();
        }
    },

    start: function () {
        // begin animation, initialize all the networks
        var i,
            parameters,
            shareButtonsCount;

        this.isEnabled = true;
        parameters = {
            facebookAppId: MemoryMatch.GameSetup.facebookAppId
        };
        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            enginesisSession.ShareHelper.initialize(this.shareNetworks[i].id, parameters, this.onNetworksInitializeComplete.bind(this));
        }
    },

    closeStartAnimation: function () {
        var duration = 0.1, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeShrink.bind(this));

        if (animator != null) {
            animator.endYScale = animator.endXScale = 1.08;
            animator.vYScale = animator.vXScale = animator.endXScale / (duration * MemoryMatch.fps);
        }
        if (this.stateCompleteCallback != null) {
            this.stateCompleteCallback(this.closeEventType);
        }
    },

    closeShrink: function () {
        var duration = 0.3, // seconds of animation
            animator = MemoryMatch.AnimationHandler.addToAnimationQueue(this.groupDisplayObject, 0, duration * 1000, false, null, this.closeComplete.bind(this));

        if (animator != null) {
            animator.endYScale = animator.endXScale = 0;
            animator.vYScale = animator.vXScale = (-1 * this.groupDisplayObject.scaleX) / (duration * MemoryMatch.fps);
        }
    },

    closeComplete: function () {
        this.killScreen();
    },

    closePopup: function (closeEventType) {
        var domElement = this.groupDisplayObject.getChildByName(this.domElementEmailForm);

        this.isEnabled = false;
        this.closeEventType = closeEventType;
        if (domElement != null) {
            domElement.visible = false;
        }
        // begin animation, then once close is complete send notification
        this.closeStartAnimation();
    },

    onClickClose: function (event) {
        if (this.isEnabled) {
            this.closePopup("close");
        }
    },

    onClickNetworkButton: function (networkId) {
        var i,
            shareButtonsCount,
            parameters;

        if (this.isEnabled) {
            this.isEnabled = false; // do not allow clicking any other button until this completes

            shareButtonsCount = this.shareNetworks.length;
            for (i = 0; i < shareButtonsCount; i ++) {
                if (networkId == this.shareNetworks[i].id) {
                    if (this.shareNetworks[i].initalized) {
                        this.networkShare(networkId);
                    } else {
                        parameters = {
                            facebookAppId: MemoryMatch.GameSetup.facebookAppId
                        };
                        enginesisSession.ShareHelper.initialize(networkId, parameters, this.onNetworkInitializeComplete.bind(this));
                    }
                }
            }
        }
    },

    onClickSend: function () {
        var name,
            fromEmail,
            toEmail,
            message,
            parameters,
            isOKToSend;

        isOKToSend = false;
        name = document.getElementById('fromname').value;
        fromEmail = document.getElementById('fromemail').value;
        toEmail = document.getElementById('toemail').value;
        message = document.getElementById('message').value;
        if (fromEmail.length < 4) {
            message = 'Please provide your email address as the sender.';
        } else if (toEmail.length < 4) {
            message = 'Please provide the email address of a recipient.';
        } else if ( ! MemoryMatch.isValidEmail(fromEmail)) {
            message = 'Please provide a valid sender email address.';
        } else if ( ! MemoryMatch.isValidEmail(toEmail)) {
            message = 'Please provide a valid email address of a recipient.';
        } else {
            isOKToSend = true;
        }
        if (isOKToSend) {
            document.getElementById('errorMessage').innerText = '';
            MemoryMatch.UserData.updateUser(-1, name, null, fromEmail, null);
            MemoryMatch.UserData.flush();
            document.getElementById('toemail').value = '';
            parameters = {
                fromName: name,
                fromEmail: fromEmail,
                toEmail: toEmail,
                message: message,
                picture: null,
                link: null
            };
            enginesisSession.ShareHelper.share('email', parameters, this.onNetworkShareComplete.bind(this));
        } else {
            document.getElementById('errorMessage').innerText = message;
        }
    },

    onClickBackground: function (event) {
        // this just eats the click so anything under the popup is not activated
    },

    onNetworksInitializeComplete: function (networkId) {
        // mark this network as initialized
        var i,
            shareButtonsCount;

        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            if (networkId == this.shareNetworks[i].id) {
                this.shareNetworks[i].initalized = true;
            }
        }
    },

    networkShare: function (networkId) {
        var parameters;

        if (networkId != 'email') { // hand off to the network to ask the user to share
            parameters = {
                description: '',
                title: MemoryMatch.GameSetup.gameTitle,
                caption: MemoryMatch.GameSetup.gameSubTitle,
                picture: MemoryMatch.GameSetup.promoImage,
                socialHashTags: MemoryMatch.GameSetup.socialHashTag,
                viaId: MemoryMatch.GameSetup.twitterId,
                link: MemoryMatch.GameSetup.gameLink
            };
            if (this.shareMessage != null) {
                parameters.description = this.shareMessage;
            } else {
                parameters.description = MemoryMatch.GameSetup.gameSubTitle;
            }
            enginesisSession.ShareHelper.share(networkId, parameters, this.onNetworkShareComplete.bind(this));
        } else { // we need to prompt the user for the share info
            this.showEmailForm();
        }
    },

    onNetworkInitializeComplete: function (networkId) {
        // the requested network was initialized now try to call it
        this.onNetworksInitializeComplete(networkId);
        this.networkShare(networkId);
    },

    onNetworkShareComplete: function (networkId) {
        // the requested share is done
        this.closePopup("continue");
    },

    showBackgroundImage: function () {

        // This method will scale the background image to fit the current stage if it is too big.

        var canvas = this.parentDisplayObject.canvas,
            popupImageAsset = MemoryMatch.assetLoader.getResult("popup-bg"),
            bgImage = new createjs.Bitmap(popupImageAsset),
            xScale,
            yScale,
            backgroundCover;

        if (popupImageAsset.width > canvas.width) {
            xScale = canvas.width / popupImageAsset.width;
        } else {
            xScale = 1;
        }
        if (popupImageAsset.height > canvas.height) {
            yScale = canvas.height / popupImageAsset.height;
        } else {
            yScale = 1;
        }
        bgImage.alpha = 1;
        bgImage.scaleX = xScale;
        bgImage.scaleY = yScale;

        backgroundCover = new createjs.Shape();
        backgroundCover.graphics.beginFill("#CCCCCC").drawRect(0, 0, canvas.width, canvas.height);
        backgroundCover.alpha = 0.1;
        backgroundCover.addEventListener("click", this.onClickBackground);
        this.backgroundCover = backgroundCover;
        this.parentDisplayObject.addChild(backgroundCover);
        this.groupDisplayObject.addChild(bgImage);
        this.backgroundWidth = popupImageAsset.width * xScale;
        this.backgroundHeight = popupImageAsset.height * yScale;
        if (this.primaryColorFilter != null) {
            bgImage.filters = [this.primaryColorFilter];
            bgImage.cache(0, 0, this.backgroundWidth, this.backgroundHeight);
        }
    },

    setupDOMElement: function (domElementId) {
        // Position a DOM element in the center of the popup. Expecting the element to be a div containing what we want to show.
        // Register domElement to its center
        var pageElement = document.getElementById(domElementId),
            domElement,
            scaleFactorX,
            scaleFactorY,
            x,
            y,
            width,
            height;

        if (pageElement != null) {
            domElement = new createjs.DOMElement(pageElement)
            if (domElement != null) {
                domElement.name = domElementId;
                width = pageElement.clientWidth;
                height = pageElement.clientHeight;
                // the div is independent of the CSS container to we need to center it and scale it based on where the background is placed
                if (MemoryMatch.stageScaleFactor == 0.5) {
                    scaleFactorX = 1;
                    x = width * -0.12;
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * (-0.5 * scaleFactorX));
                } else if (MemoryMatch.stageScaleFactor < 0.5) {
//                    scaleFactorX = 0.8; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
//                    scaleFactorY = 0.8; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
                    scaleFactorX = 0.8;
                    x = width * 0.05; // Math.floor((MemoryMatch.stageWidth - width) * 0.5);
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * 0.5);
                } else {
//                    scaleFactorX = 1; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledWidth / MemoryMatch.stageWidth);
//                    scaleFactorY = 1; // MemoryMatch.stageScaleFactor * (MemoryMatch.cssScaledHeight / MemoryMatch.stageHeight);
//                    x = Math.floor((MemoryMatch.stageWidth - width) * 0.5 * scaleFactorX);
//                    y = Math.floor((MemoryMatch.stageHeight - height) * 0.5 * scaleFactorX);
                    scaleFactorX = 1; // this.backgroundWidth / width;
                    x = width * -0.12; // Math.floor((MemoryMatch.stageWidth - width) * (-0.5 * scaleFactorX));
                    y = MemoryMatch.stageHeight * 0.15; // Math.floor((MemoryMatch.stageHeight - height) * (-0.5 * scaleFactorX));
                }
                MemoryMatch.debugLog("X,Y=(" + x + "," + y + "); Scale=" + scaleFactorX + "; Client w/h (" + width + "," + height + "); background (" + this.backgroundWidth + "," + this.backgroundHeight + "); stage(" + MemoryMatch.stageWidth + "," + MemoryMatch.stageHeight + ")");
                this.groupDisplayObject.addChildAt(domElement, 0);
                domElement.setTransform(x, y, scaleFactorX, scaleFactorX, 0, 0, 0, 0, 0);
                pageElement = document.getElementById('send');
                if (pageElement != null) {
                    pageElement.onclick = this.onClickSend.bind(this);
                }
            }
        }
    },

    setupTitleText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.title, MemoryMatch.getScaledFontSize(72) + " " + MemoryMatch.GameSetup.guiBoldFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "center";
        titleTextField.x = this.backgroundWidth * 0.5;
        titleTextField.y = this.marginTop;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupMessageText: function () {
        var titleTextField;

        titleTextField = new createjs.Text(this.message, MemoryMatch.getScaledFontSize(48) + " " + MemoryMatch.GameSetup.guiMediumFontName, MemoryMatch.GameSetup.guiFontColor);
        titleTextField.textAlign = "left";
        titleTextField.x = this.marginLeft;
        titleTextField.y = this.backgroundHeight * 0.2;
        titleTextField.lineWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.maxWidth = this.backgroundWidth - (this.marginLeft * 2);
        titleTextField.name = 'title';
        this.groupDisplayObject.addChild(titleTextField);
    },

    setupButtons: function () {
        var buttonScale = 1.0,
            gameButton,
            shareButton,
            shareButtonsCount,
            shareButtonsStartX,
            shareButtonsMargin,
            shareButtonsWidth = 0,
            buttonTagCounter = 0,
            buttonSize,
            networkId,
            icon,
            i;

        // Close button always shows in its own special place
        buttonTagCounter ++;
        gameButton = MemoryMatch.GUIButton({name: "close", tag: buttonTagCounter, disabled: false, callback: this.onClickClose.bind(this), baseUp: "closeButtonUp", baseOver: "closeButtonDown", baseDown: "closeButtonDown"});
        buttonSize = gameButton.getSize();
        gameButton.setTransform(this.backgroundWidth * 0.94 - buttonSize.width, this.backgroundHeight * 0.05, buttonScale, buttonScale);
        this.groupDisplayObject.addChild(gameButton);
        this.buttonInstances.push(gameButton);

        // Show the share buttons
        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            networkId = this.shareNetworks[i].id;
            icon = this.shareNetworks[i].icon;
            buttonTagCounter ++;
            shareButton = MemoryMatch.GUIButton({name: networkId, tag: buttonTagCounter, disabled: false, callback: this.onClickNetworkButton.bind(this), spriteFrames: MemoryMatch.GameSetup.shareIconsFrames, baseUp: icon, baseOver: icon, baseDown: icon});
            if (shareButtonsWidth == 0) {
                // we are assuming all share buttons are the exact same size, otherwise this logic is incorrect.
                buttonSize = gameButton.getSize();
                shareButtonsMargin = Math.floor(buttonSize.width * 0.3333);
                shareButtonsWidth = ((buttonSize.width + shareButtonsMargin) * shareButtonsCount) - shareButtonsMargin;
                shareButtonsStartX = (this.backgroundWidth - shareButtonsWidth) * 0.5;
            }
            shareButton.setTransform(shareButtonsStartX + ((buttonSize.width + shareButtonsMargin) * i), this.backgroundHeight * 0.4, buttonScale, buttonScale);
            this.groupDisplayObject.addChild(shareButton);
            this.buttonInstances.push(shareButton);
        }
    },

    showEmailForm: function () {
        // the email form is a DOM element we need to show it, hide the buttons
        // Hide the share buttons
        var shareButton,
            shareButtonsCount,
            networkId,
            userInfo,
            i;

        this.isEnabled = true;
        shareButtonsCount = this.shareNetworks.length;
        for (i = 0; i < shareButtonsCount; i ++) {
            networkId = this.shareNetworks[i].id;
            shareButton = this.groupDisplayObject.getChildByName(networkId);
            if (shareButton != null) {
                shareButton.visible = false;
            }
        }
        shareButton = this.groupDisplayObject.getChildByName('title');
        if (shareButton != null) {
            shareButton.visible = false;
        }
        if (this.domElementEmailForm != null) {
            this.setupDOMElement(this.domElementEmailForm);
        }
        userInfo = MemoryMatch.UserData.getById();
        document.getElementById('fromname').value = userInfo.userName;
        document.getElementById('fromemail').value = userInfo.email;
        document.getElementById('toemail').value = '';
        document.getElementById('message').value = 'Come play ' + MemoryMatch.GameSetup.gameTitle + '. I really enjoy this game, you will too!';
    },

    isShowing: function () {
        return this.groupDisplayObject !== null && this.groupDisplayObject.visible;
    },

    setColorFilters: function () {
        var primaryColor,
            secondaryColor;

        this.primaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        this.secondaryColorValue = MemoryMatch.GameSetup.levels[MemoryMatch.gameLevel - 1].primaryColor;
        if (this.primaryColorValue != null) {
            primaryColor = MemoryMatch.htmlColorStringToColorArray(this.primaryColorValue);
            this.primaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, primaryColor[0], primaryColor[1], primaryColor[2], 0);
        } else {
            this.primaryColorFilter = null;
        }
        if (this.secondaryColorValue != null) {
            secondaryColor = MemoryMatch.htmlColorStringToColorArray(this.secondaryColorValue);
            this.secondaryColorFilter = new createjs.ColorFilter(0, 0, 0, 1, secondaryColor[0], secondaryColor[1], secondaryColor[2], 0);
        } else {
            this.secondaryColorFilter = null;
        }
    },

    killScreen: function () {
        // remove all display objects and object references:
        var i,
            pageElement;

        this.primaryColorFilter = null;
        this.secondaryColorFilter = null;
        if (this.buttonInstances !== null) {
            for (i = 0; i < this.buttonInstances.length; i ++) {
                this.buttonInstances[i].removeAllEventListeners();
            }
            this.buttonInstances = null;
        }
        if (this.domElement != null) {
            pageElement = document.getElementById(this.domElement);
            if (pageElement != null) {
                pageElement.style.visibility = "hidden";
            }
        }
        this.domElement = null;
        this.title = null;
        this.message = null;
        if (this.groupDisplayObject != null) {
            this.groupDisplayObject.removeAllChildren();
            this.parentDisplayObject.removeChild(this.groupDisplayObject);
            this.groupDisplayObject = null;
        }
        if (this.parentDisplayObject != null) {
            this.parentDisplayObject.removeChild(this.backgroundCover);
            this.backgroundCover = null;
            this.stateCompleteCallback = null;
            this.parentDisplayObject = null;
        }
    }
};
/**
 * UserData.js
 *
 * This object manages the user data. Data is organized by a user id and it is
 * a structured object for a specific game instance. This helps separate the API
 * interface from the actual data organization.
 *
 * Features:
 *   userDataObject: an object of key/value pairs held on behalf of the userId.
 *      .userId = internal, unique, id of the user
 *      .userName = name assigned to the user
 *      .password = users password to access the data record
 *      .email = users email address
 *      .ageCheck = true indicates use is over 13, false otherwise
 *      .. the app will add additional data items to this object e.g. userDataObject['myItem'] = myValue;
 *   levelDataArray: an array of level data, the index being the level number (- 1, e.g. level 1 is index 0) the data being an object.
 *   userAchievements: an array of earned achievements
 *   userTips: an array of seen/unseen tips, each item is a flag (true=seen, false=unseen) indexed by tipId - 1 (e.g. tip # 1 is index 0)
 */
MemoryMatch = MemoryMatch || {};

MemoryMatch.UserData = {
    userDataCollection: null,
    currentUser: null,
    dataUpdatedFlag: false,
    dataLoadedFromStorage: false,
    dataLoadedFromServer: false,

    addUser: function (userId, userName, password, email, ageCheck) {
        var userDataObject;

        if (this.userDataCollection == null) {
            this.userDataCollection = [];
        }
        if (userId == null || userId < 1) {
            userId = this.getNextUserId();
        }
        userDataObject = this.getById(userId);
        if (userDataObject == null) {
            userDataObject = {userId: userId, userName: userName, password: password, email: email, ageCheck: ageCheck, userDataObject: {}, levelDataArray: [], userAchievements: [], userTips: []};
            this.userDataCollection.push(userDataObject);
            this.dataUpdatedFlag = true;
        } else {
            userDataObject.userName = userName;
            userDataObject.password = password;
            userDataObject.email = email;
            userDataObject.ageCheck = ageCheck;
            this.dataUpdatedFlag = true;
        }
        this.sync();
        if (this.currentUser == null) {
            this.currentUser = userDataObject;
        }
        return userDataObject;
    },

    updateUser: function (userId, userName, password, email, ageCheck) {
        var userDataObject;

        if (userId == undefined || userId == null || userId < 1) {
            userId = this.getCurrentUserId();
        }
        userDataObject = this.getById(userId);
        if (userDataObject == null) {
            if (userName == null) {
                userName = '';
            }
            if (password == null) {
                password = '';
            }
            if (email == null) {
                email = '';
            }
            if (ageCheck == null) {
                ageCheck = false;
            }
            userDataObject = this.addUser(userId, userName, password, email, ageCheck);
        } else {
            if (userName != null) {
                userDataObject.userName = userName;
            }
            if (password != null) {
                userDataObject.password = password;
            }
            if (email != null) {
                userDataObject.email = email;
            }
            if (ageCheck != null) {
                userDataObject.ageCheck = ageCheck;
            }
            this.dataUpdatedFlag = true;
        }
        return userDataObject;
    },

    deleteUser: function (userId) {
        var i,
            userExists = false,
            userDataObject;

        if (this.currentUser === userDataObject) {
            this.currentUser = null;
        }
        if (this.userDataCollection !== null && this.userDataCollection.length > 0 && userId !== null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId === userDataObject.userId) {
                    userExists = true;
                    if (this.currentUser == userDataObject) {
                        this.currentUser = null;
                    }
                    break;
                }
            }
            if (userExists) {
                this.userDataCollection.splice(i, 1);
                this.dataUpdatedFlag = true;
            }
        }
        return userExists;
    },

    getById: function (userId) {
        var i,
            userDataObject,
            returnThisData = null;

        if (userId == undefined || userId == null || userId < 1) {
            userId = this.getCurrentUserId();
        }
        if (this.userDataCollection != null && this.userDataCollection.length > 0 && userId != null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId == userDataObject.userId) {
                    returnThisData = userDataObject;
                    break;
                }
            }
        }
        return returnThisData;
    },

    getByName: function (userName) {
        var i,
            userDataObject,
            returnThisData = null;

        if (this.userDataCollection != null && this.userDataCollection.length > 0 && userName != null) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userName == userDataObject.userName) {
                    returnThisData = userDataObject;
                    break;
                }
            }
        }
        return returnThisData;
    },

    getNextUserId: function () {
        var i,
            userId = 0,
            userDataObject;

        if (this.userDataCollection != null && this.userDataCollection.length > 0) {
            for (i = 0; i < this.userDataCollection.length; i ++) {
                userDataObject = this.userDataCollection[i];
                if (userId < userDataObject.userId) {
                    userId = userDataObject.userId;
                }
            }
        }
        return ++ userId;
    },

    count: function () {
        return this.userDataCollection.length;
    },

    setCurrentUser: function (userId) {
        this.currentUser = this.getById(userId);
        return this.currentUser;
    },

    getCurrentUserId: function () {
        if (this.currentUser === null) {
            this.setCurrentUser(1);
        }
        return this.currentUser.userId;
    },

    setUserDataObject: function (userDataObject) {
        if (this.currentUser != null) {
            this.currentUser.userDataObject = userDataObject;
            this.dataUpdatedFlag = true;
        }
        return userDataObject;
    },

    getUserDataObject: function () {
        var userDataObject = null;
        if (this.currentUser !== null) {
            userDataObject = this.currentUser.userDataObject;
            if (userDataObject === null) {
                userDataObject = {};
            } else if (userDataObject.userAchievements !== null && ! Array.isArray(userDataObject.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                userDataObject.userAchievements = [];
                userDataObject.userTips = [];
            }
        }
        return userDataObject;
    },

    setUserDataItem: function (itemKey, itemValue) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userDataObject !== null) {
            this.currentUser.userDataObject[itemKey] = itemValue;
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    getUserDataItem: function (itemKey) {
        var itemValue = null;
        if (this.currentUser != null && this.currentUser.userDataObject != null) {
            itemValue = this.currentUser.userDataObject[itemKey];
        }
        return itemValue;
    },

    setLevelDataObject: function (levelNumber, levelDataObject) {
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            this.currentUser.levelDataArray[levelNumber - 1] = levelDataObject;
            this.dataUpdatedFlag = true;
        }
        return levelDataObject;
    },

    getLevelDataObject: function (levelNumber) {
        var levelDataObject = null;
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            levelDataObject = this.currentUser.levelDataArray[levelNumber - 1];
        }
        return levelDataObject;
    },

    setLevelDataItem: function (levelNumber, itemId, itemData) {
        var wasSet = false;
        if (this.currentUser != null && this.currentUser.levelDataArray != null && levelNumber > 0) {
            if (this.currentUser.levelDataArray[levelNumber - 1] == null) {
                this.currentUser.levelDataArray[levelNumber - 1] = {};
            }
            this.currentUser.levelDataArray[levelNumber - 1][itemId] = itemData;
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    getLevelDataItem: function (levelNumber, itemId) {
        var itemData = null;
        if (this.currentUser !== null && this.currentUser.levelDataArray !== null && levelNumber > 0 && this.currentUser.levelDataArray[levelNumber - 1] !== null) {
            itemData = this.currentUser.levelDataArray[levelNumber - 1][itemId];
        }
        return itemData;
    },

    setUserAchievementArray: function (achievementArray) {
        if (this.currentUser !== null) {
            this.currentUser.userAchievements = achievementArray;
            this.dataUpdatedFlag = true;
        }
        return achievementObject;
    },

    setUserAchievement: function (achievementId) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userAchievements !== null) {
            if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                this.currentUser.userAchievements = [];
            }
            this.currentUser.userAchievements.push(achievementId);
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    isUserAchievementSet: function (achievementId) {
        var wasSet = false;
        if (this.currentUser !== null && this.currentUser.userAchievements !== null) {
            if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
                // Deal with legacy setting this to an object instead of an array
                this.currentUser.userAchievements = [];
            }
            wasSet = this.currentUser.userAchievements.indexOf(achievementId) !== -1;
        }
        return wasSet;
    },

    getUserAchievements: function () {
        if (this.currentUser.userAchievements !== null && ! Array.isArray(this.currentUser.userAchievements)) {
            // Deal with legacy setting this to an object instead of an array
            this.currentUser.userAchievements = [];
        }
        return this.currentUser.userAchievements;
    },

    clearAllUserAchievements: function () {
        this.currentUser.userAchievements = [];
        return this.currentUser.userAchievements;
    },

    setUserTipSeen: function (tipId) {
        var wasSet = false,
            tipIndex = tipId - 1,
            i,
            userTipsArray;

        if (tipIndex < 0) {
            tipIndex = 0;
        }
        if (this.currentUser !== null && this.currentUser.userTips !== null) {
            if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
                this.currentUser.userTips = [];
            }
            userTipsArray = this.currentUser.userTips;
            userTipsArray[tipIndex] = true;
            // Here we make sure there are no gaps in the array
            for (i = 0; i < userTipsArray.length; i ++) {
                if (userTipsArray[i] === undefined) {
                    userTipsArray[i] = false;
                }
            }
            wasSet = true;
            this.dataUpdatedFlag = true;
        }
        return wasSet;
    },

    isUserTipSeen: function (tipId) {
        var wasSeen = false,
            tipIndex = tipId - 1;

        if (this.currentUser !== null && this.currentUser.userTips !== null) {
            if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
                this.currentUser.userTips = [];
            }
            wasSeen = this.currentUser.userTips[tipIndex];
            if (wasSeen === undefined) {
                wasSeen = false;
            }
        }
        return wasSeen;
    },

    getUserTips: function () {
        if (this.currentUser.userTips !== null && ! Array.isArray(this.currentUser.userTips)) {
            this.currentUser.userTips = [];
        }
        return this.currentUser.userTips;
    },

    clearAllUserTips: function () {
        this.currentUser.userTips = [];
        return this.currentUser.userTips;
    },

    sync: function () {
        // synchronize the data with the local storage and the server if connected
        var gameSaveJson;

        if (MemoryMatch.hasHTML5LocalStorage()) {
            gameSaveJson = JSON.stringify(this.userDataCollection);
            window.localStorage[MemoryMatch.getGameKey('userData')] = gameSaveJson;
            this.dataUpdatedFlag = false;
        }
    },

    load: function () {
        // load the data from local storage or the server if connected
        var gameSaveJson,
            wasLoaded = false;

        if (MemoryMatch.hasHTML5LocalStorage()) {
            gameSaveJson = window.localStorage[MemoryMatch.getGameKey('userData')];
            if (gameSaveJson != null && gameSaveJson != "null") {
                this.userDataCollection = JSON.parse(gameSaveJson);
                this.dataUpdatedFlag = false;
                wasLoaded = true;
            }
        }
        return wasLoaded;
    },

    flush: function () {
        // this.debug();
        this.dataUpdatedFlag = true;
        this.sync();
    },

    debug: function () {
        MemoryMatch.debugLog(JSON.stringify(this.userDataCollection));
    }
};
